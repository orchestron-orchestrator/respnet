import base64
import json
import xml
import yang.adata
import yang.gdata

# == This file is generated ==


mut def from_json_netinfra_inter__netinfra__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra_inter__netinfra__router__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_netinfra_inter__netinfra__router__role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra_inter__netinfra__router__mock(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

mut def from_json_netinfra_inter__netinfra__router__base_config__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_netinfra_inter__netinfra__router__base_config__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra_inter__netinfra__router__base_config__ipv6_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class netinfra_inter__netinfra__router__base_config(yang.adata.MNode):
    asn: int
    ipv4_address: str
    ipv6_address: str

    mut def __init__(self, asn: int, ipv4_address: str, ipv6_address: str):
        self._ns = "http://example.com/netinfra-inter"
        self.asn = asn
        self.ipv4_address = ipv4_address
        self.ipv6_address = ipv6_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _asn = self.asn
        _ipv4_address = self.ipv4_address
        _ipv6_address = self.ipv6_address
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        if _ipv4_address is not None:
            children['ipv4-address'] = yang.gdata.Leaf('string', _ipv4_address)
        if _ipv6_address is not None:
            children['ipv6-address'] = yang.gdata.Leaf('string', _ipv6_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> netinfra_inter__netinfra__router__base_config:
        if n != None:
            return netinfra_inter__netinfra__router__base_config(asn=n.get_int("asn"), ipv4_address=n.get_str("ipv4-address"), ipv6_address=n.get_str("ipv6-address"))
        raise ValueError("Missing required subtree netinfra_inter__netinfra__router__base_config")

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> netinfra_inter__netinfra__router__base_config:
        if n != None:
            return netinfra_inter__netinfra__router__base_config(asn=yang.gdata.from_xml_int(n, "asn"), ipv4_address=yang.gdata.from_xml_str(n, "ipv4-address"), ipv6_address=yang.gdata.from_xml_str(n, "ipv6-address"))
        raise ValueError("Missing required subtree netinfra_inter__netinfra__router__base_config")


mut def from_json_path_netinfra_inter__netinfra__router__base_config(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'netinfra-inter:asn' or point == 'asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'netinfra-inter:ipv4-address' or point == 'ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'netinfra-inter:ipv6-address' or point == 'ipv6-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_netinfra_inter__netinfra__router__base_config(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_netinfra_inter__netinfra__router__base_config(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_asn_full = jd.get('netinfra-inter:asn')
    child_asn = child_asn_full if child_asn_full is not None else jd.get('asn')
    if child_asn is not None:
        children['asn'] = from_json_netinfra_inter__netinfra__router__base_config__asn(child_asn)
    child_ipv4_address_full = jd.get('netinfra-inter:ipv4-address')
    child_ipv4_address = child_ipv4_address_full if child_ipv4_address_full is not None else jd.get('ipv4-address')
    if child_ipv4_address is not None:
        children['ipv4-address'] = from_json_netinfra_inter__netinfra__router__base_config__ipv4_address(child_ipv4_address)
    child_ipv6_address_full = jd.get('netinfra-inter:ipv6-address')
    child_ipv6_address = child_ipv6_address_full if child_ipv6_address_full is not None else jd.get('ipv6-address')
    if child_ipv6_address is not None:
        children['ipv6-address'] = from_json_netinfra_inter__netinfra__router__base_config__ipv6_address(child_ipv6_address)
    return yang.gdata.Container(children)

mut def to_json_netinfra_inter__netinfra__router__base_config(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_asn = n.children.get('asn')
    if child_asn is not None:
        if isinstance(child_asn, yang.gdata.Leaf):
            children['asn'] = child_asn.val
    child_ipv4_address = n.children.get('ipv4-address')
    if child_ipv4_address is not None:
        if isinstance(child_ipv4_address, yang.gdata.Leaf):
            children['ipv4-address'] = child_ipv4_address.val
    child_ipv6_address = n.children.get('ipv6-address')
    if child_ipv6_address is not None:
        if isinstance(child_ipv6_address, yang.gdata.Leaf):
            children['ipv6-address'] = child_ipv6_address.val
    return children

mut def from_json_netinfra_inter__netinfra__router__l3vpn_vrf__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra_inter__netinfra__router__l3vpn_vrf__ebgp_customer_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class netinfra_inter__netinfra__router__l3vpn_vrf_entry(yang.adata.MNode):
    vpn_id: str
    ebgp_customer_address: list[str]

    mut def __init__(self, vpn_id: str, ebgp_customer_address: ?list[str]=None):
        self._ns = "http://example.com/netinfra-inter"
        self.vpn_id = vpn_id
        if ebgp_customer_address is not None:
            self.ebgp_customer_address = ebgp_customer_address
        else:
            self.ebgp_customer_address = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        children['ebgp-customer-address'] = yang.gdata.LeafList(self.ebgp_customer_address)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.vpn_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__router__l3vpn_vrf_entry:
        return netinfra_inter__netinfra__router__l3vpn_vrf_entry(vpn_id=n.get_str("vpn-id"), ebgp_customer_address=n.get_opt_strs("ebgp-customer-address"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> netinfra_inter__netinfra__router__l3vpn_vrf_entry:
        return netinfra_inter__netinfra__router__l3vpn_vrf_entry(vpn_id=yang.gdata.from_xml_str(n, "vpn-id"), ebgp_customer_address=yang.gdata.from_xml_opt_strs(n, "ebgp-customer-address"))

class netinfra_inter__netinfra__router__l3vpn_vrf(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__router__l3vpn_vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://example.com/netinfra-inter"
        self._name = 'l3vpn-vrf'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__router__l3vpn_vrf_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__router__l3vpn_vrf_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__router__l3vpn_vrf_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[netinfra_inter__netinfra__router__l3vpn_vrf_entry]:
        res = []
        for node in nodes:
            res.append(netinfra_inter__netinfra__router__l3vpn_vrf_entry.from_xml(node))
        return res


mut def from_json_path_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['vpn-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'ebgp-customer-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__router__l3vpn_vrf(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id_full = jd.get('netinfra-inter:vpn-id')
    child_vpn_id = child_vpn_id_full if child_vpn_id_full is not None else jd.get('vpn-id')
    if child_vpn_id is not None:
        children['vpn-id'] = from_json_netinfra_inter__netinfra__router__l3vpn_vrf__vpn_id(child_vpn_id)
    child_ebgp_customer_address_full = jd.get('netinfra-inter:ebgp-customer-address')
    child_ebgp_customer_address = child_ebgp_customer_address_full if child_ebgp_customer_address_full is not None else jd.get('ebgp-customer-address')
    if child_ebgp_customer_address is not None and isinstance(child_ebgp_customer_address, list):
        children['ebgp-customer-address'] = from_json_netinfra_inter__netinfra__router__l3vpn_vrf__ebgp_customer_address(child_ebgp_customer_address)
    return yang.gdata.Container(children, [str(child_vpn_id if child_vpn_id is not None else "")])

mut def from_json_netinfra_inter__netinfra__router__l3vpn_vrf(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(e))
    return yang.gdata.List(keys=['vpn-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_vpn_id = n.children.get('vpn-id')
    if child_vpn_id is not None:
        if isinstance(child_vpn_id, yang.gdata.Leaf):
            children['vpn-id'] = child_vpn_id.val
    child_ebgp_customer_address = n.children.get('ebgp-customer-address')
    if child_ebgp_customer_address is not None:
        if isinstance(child_ebgp_customer_address, yang.gdata.LeafList):
            children['ebgp-customer-address'] = child_ebgp_customer_address.vals
    return children

mut def to_json_netinfra_inter__netinfra__router__l3vpn_vrf(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(e))
    return elements

class netinfra_inter__netinfra__router_entry(yang.adata.MNode):
    name: str
    id: int
    role: ?str
    mock: ?str
    base_config: netinfra_inter__netinfra__router__base_config
    l3vpn_vrf: netinfra_inter__netinfra__router__l3vpn_vrf

    mut def __init__(self, name: str, id: int, base_config: netinfra_inter__netinfra__router__base_config, role: ?str, mock: ?str, l3vpn_vrf: list[netinfra_inter__netinfra__router__l3vpn_vrf_entry]=[]):
        self._ns = "http://example.com/netinfra-inter"
        self.name = name
        self.id = id
        self.role = role
        self.mock = mock
        self.base_config = base_config
        self.l3vpn_vrf = netinfra_inter__netinfra__router__l3vpn_vrf(elements=l3vpn_vrf)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        _id = self.id
        _role = self.role
        _mock = self.mock
        _base_config = self.base_config
        _l3vpn_vrf = self.l3vpn_vrf
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint32', _id)
        if _role is not None:
            children['role'] = yang.gdata.Leaf('string', _role)
        if _mock is not None:
            children['mock'] = yang.gdata.Leaf('enumeration', _mock)
        if _base_config is not None:
            children['base-config'] = _base_config.to_gdata()
        if _l3vpn_vrf is not None:
            children['l3vpn-vrf'] = _l3vpn_vrf.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__router_entry:
        return netinfra_inter__netinfra__router_entry(name=n.get_str("name"), id=n.get_int("id"), role=n.get_opt_str("role"), mock=n.get_opt_str("mock"), base_config=netinfra_inter__netinfra__router__base_config.from_gdata(n.get_container("base-config")), l3vpn_vrf=netinfra_inter__netinfra__router__l3vpn_vrf.from_gdata(n.get_opt_list("l3vpn-vrf")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> netinfra_inter__netinfra__router_entry:
        return netinfra_inter__netinfra__router_entry(name=yang.gdata.from_xml_str(n, "name"), id=yang.gdata.from_xml_int(n, "id"), role=yang.gdata.from_xml_opt_str(n, "role"), mock=yang.gdata.from_xml_opt_str(n, "mock"), base_config=netinfra_inter__netinfra__router__base_config.from_xml(yang.gdata.get_xml_child(n, "base-config")), l3vpn_vrf=netinfra_inter__netinfra__router__l3vpn_vrf.from_xml(yang.gdata.get_xml_children(n, "l3vpn-vrf")))

class netinfra_inter__netinfra__router(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__router_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://example.com/netinfra-inter"
        self._name = 'router'
        self.elements = elements

    mut def create(self, name, id, base_config):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__router_entry(name, id, base_config)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__router_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__router_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[netinfra_inter__netinfra__router_entry]:
        res = []
        for node in nodes:
            res.append(netinfra_inter__netinfra__router_entry.from_xml(node))
        return res


mut def from_json_path_netinfra_inter__netinfra__router_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__router_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['name']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'role':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'mock':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'base-config':
            children['base-config'] = from_json_path_netinfra_inter__netinfra__router__base_config(jd, rest_path, op)
        if point == 'l3vpn-vrf':
            children['l3vpn-vrf'] = from_json_path_netinfra_inter__netinfra__router__l3vpn_vrf(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__router(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__router_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_netinfra_inter__netinfra__router_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__router_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name_full = jd.get('netinfra-inter:name')
    child_name = child_name_full if child_name_full is not None else jd.get('name')
    if child_name is not None:
        children['name'] = from_json_netinfra_inter__netinfra__router__name(child_name)
    child_id_full = jd.get('netinfra-inter:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_netinfra_inter__netinfra__router__id(child_id)
    child_role_full = jd.get('netinfra-inter:role')
    child_role = child_role_full if child_role_full is not None else jd.get('role')
    if child_role is not None:
        children['role'] = from_json_netinfra_inter__netinfra__router__role(child_role)
    child_mock_full = jd.get('netinfra-inter:mock')
    child_mock = child_mock_full if child_mock_full is not None else jd.get('mock')
    if child_mock is not None:
        children['mock'] = from_json_netinfra_inter__netinfra__router__mock(child_mock)
    child_base_config_full = jd.get('netinfra-inter:base-config')
    child_base_config = child_base_config_full if child_base_config_full is not None else jd.get('base-config')
    if child_base_config is not None and isinstance(child_base_config, dict):
        children['base-config'] = from_json_netinfra_inter__netinfra__router__base_config(child_base_config)
    child_l3vpn_vrf_full = jd.get('netinfra-inter:l3vpn-vrf')
    child_l3vpn_vrf = child_l3vpn_vrf_full if child_l3vpn_vrf_full is not None else jd.get('l3vpn-vrf')
    if child_l3vpn_vrf is not None and isinstance(child_l3vpn_vrf, list):
        children['l3vpn-vrf'] = from_json_netinfra_inter__netinfra__router__l3vpn_vrf(child_l3vpn_vrf)
    return yang.gdata.Container(children, [str(child_name if child_name is not None else "")])

mut def from_json_netinfra_inter__netinfra__router(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__router_element(e))
    return yang.gdata.List(keys=['name'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_netinfra_inter__netinfra__router_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_name = n.children.get('name')
    if child_name is not None:
        if isinstance(child_name, yang.gdata.Leaf):
            children['name'] = child_name.val
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    child_role = n.children.get('role')
    if child_role is not None:
        if isinstance(child_role, yang.gdata.Leaf):
            children['role'] = child_role.val
    child_mock = n.children.get('mock')
    if child_mock is not None:
        if isinstance(child_mock, yang.gdata.Leaf):
            children['mock'] = child_mock.val
    child_base_config = n.children.get('base-config')
    if child_base_config is not None:
        if isinstance(child_base_config, yang.gdata.Container):
            children['base-config'] = to_json_netinfra_inter__netinfra__router__base_config(child_base_config)
    child_l3vpn_vrf = n.children.get('l3vpn-vrf')
    if child_l3vpn_vrf is not None:
        if isinstance(child_l3vpn_vrf, yang.gdata.List):
            children['l3vpn-vrf'] = to_json_netinfra_inter__netinfra__router__l3vpn_vrf(child_l3vpn_vrf)
    return children

mut def to_json_netinfra_inter__netinfra__router(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_netinfra_inter__netinfra__router_element(e))
    return elements

mut def from_json_netinfra_inter__netinfra__backbone_link__left_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra_inter__netinfra__backbone_link__left_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra_inter__netinfra__backbone_link__right_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra_inter__netinfra__backbone_link__right_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class netinfra_inter__netinfra__backbone_link_entry(yang.adata.MNode):
    left_router: str
    left_interface: str
    right_router: str
    right_interface: str

    mut def __init__(self, left_router: str, left_interface: str, right_router: str, right_interface: str):
        self._ns = "http://example.com/netinfra-inter"
        self.left_router = left_router
        self.left_interface = left_interface
        self.right_router = right_router
        self.right_interface = right_interface

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _left_router = self.left_router
        _left_interface = self.left_interface
        _right_router = self.right_router
        _right_interface = self.right_interface
        if _left_router is not None:
            children['left-router'] = yang.gdata.Leaf('string', _left_router)
        if _left_interface is not None:
            children['left-interface'] = yang.gdata.Leaf('string', _left_interface)
        if _right_router is not None:
            children['right-router'] = yang.gdata.Leaf('string', _right_router)
        if _right_interface is not None:
            children['right-interface'] = yang.gdata.Leaf('string', _right_interface)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.left_router), yang.gdata.yang_str(self.left_interface), yang.gdata.yang_str(self.right_router), yang.gdata.yang_str(self.right_interface)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__backbone_link_entry:
        return netinfra_inter__netinfra__backbone_link_entry(left_router=n.get_str("left-router"), left_interface=n.get_str("left-interface"), right_router=n.get_str("right-router"), right_interface=n.get_str("right-interface"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> netinfra_inter__netinfra__backbone_link_entry:
        return netinfra_inter__netinfra__backbone_link_entry(left_router=yang.gdata.from_xml_str(n, "left-router"), left_interface=yang.gdata.from_xml_str(n, "left-interface"), right_router=yang.gdata.from_xml_str(n, "right-router"), right_interface=yang.gdata.from_xml_str(n, "right-interface"))

class netinfra_inter__netinfra__backbone_link(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__backbone_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://example.com/netinfra-inter"
        self._name = 'backbone-link'
        self.elements = elements

    mut def create(self, left_router, left_interface, right_router, right_interface):
        for e in self.elements:
            match = True
            if e.left_router != left_router:
                match = False
                continue
            if e.left_interface != left_interface:
                match = False
                continue
            if e.right_router != right_router:
                match = False
                continue
            if e.right_interface != right_interface:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__backbone_link_entry(left_router, left_interface, right_router, right_interface)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__backbone_link_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__backbone_link_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[netinfra_inter__netinfra__backbone_link_entry]:
        res = []
        for node in nodes:
            res.append(netinfra_inter__netinfra__backbone_link_entry.from_xml(node))
        return res


mut def from_json_path_netinfra_inter__netinfra__backbone_link_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__backbone_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['left-router', 'left-interface', 'right-router', 'right-interface']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__backbone_link(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['left-router', 'left-interface', 'right-router', 'right-interface']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__backbone_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], [from_json_path_netinfra_inter__netinfra__backbone_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__backbone_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_left_router_full = jd.get('netinfra-inter:left-router')
    child_left_router = child_left_router_full if child_left_router_full is not None else jd.get('left-router')
    if child_left_router is not None:
        children['left-router'] = from_json_netinfra_inter__netinfra__backbone_link__left_router(child_left_router)
    child_left_interface_full = jd.get('netinfra-inter:left-interface')
    child_left_interface = child_left_interface_full if child_left_interface_full is not None else jd.get('left-interface')
    if child_left_interface is not None:
        children['left-interface'] = from_json_netinfra_inter__netinfra__backbone_link__left_interface(child_left_interface)
    child_right_router_full = jd.get('netinfra-inter:right-router')
    child_right_router = child_right_router_full if child_right_router_full is not None else jd.get('right-router')
    if child_right_router is not None:
        children['right-router'] = from_json_netinfra_inter__netinfra__backbone_link__right_router(child_right_router)
    child_right_interface_full = jd.get('netinfra-inter:right-interface')
    child_right_interface = child_right_interface_full if child_right_interface_full is not None else jd.get('right-interface')
    if child_right_interface is not None:
        children['right-interface'] = from_json_netinfra_inter__netinfra__backbone_link__right_interface(child_right_interface)
    return yang.gdata.Container(children, [str(child_left_router if child_left_router is not None else ""), str(child_left_interface if child_left_interface is not None else ""), str(child_right_router if child_right_router is not None else ""), str(child_right_interface if child_right_interface is not None else "")])

mut def from_json_netinfra_inter__netinfra__backbone_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__backbone_link_element(e))
    return yang.gdata.List(keys=['left-router', 'left-interface', 'right-router', 'right-interface'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_netinfra_inter__netinfra__backbone_link_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_left_router = n.children.get('left-router')
    if child_left_router is not None:
        if isinstance(child_left_router, yang.gdata.Leaf):
            children['left-router'] = child_left_router.val
    child_left_interface = n.children.get('left-interface')
    if child_left_interface is not None:
        if isinstance(child_left_interface, yang.gdata.Leaf):
            children['left-interface'] = child_left_interface.val
    child_right_router = n.children.get('right-router')
    if child_right_router is not None:
        if isinstance(child_right_router, yang.gdata.Leaf):
            children['right-router'] = child_right_router.val
    child_right_interface = n.children.get('right-interface')
    if child_right_interface is not None:
        if isinstance(child_right_interface, yang.gdata.Leaf):
            children['right-interface'] = child_right_interface.val
    return children

mut def to_json_netinfra_inter__netinfra__backbone_link(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_netinfra_inter__netinfra__backbone_link_element(e))
    return elements

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__authentication_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__router__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class netinfra_inter__netinfra__ibgp_fullmesh__router_entry(yang.adata.MNode):
    name: str
    ipv4_address: str

    mut def __init__(self, name: str, ipv4_address: str):
        self._ns = "http://example.com/netinfra-inter"
        self.name = name
        self.ipv4_address = ipv4_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        _ipv4_address = self.ipv4_address
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        if _ipv4_address is not None:
            children['ipv4-address'] = yang.gdata.Leaf('string', _ipv4_address)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__ibgp_fullmesh__router_entry:
        return netinfra_inter__netinfra__ibgp_fullmesh__router_entry(name=n.get_str("name"), ipv4_address=n.get_str("ipv4-address"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> netinfra_inter__netinfra__ibgp_fullmesh__router_entry:
        return netinfra_inter__netinfra__ibgp_fullmesh__router_entry(name=yang.gdata.from_xml_str(n, "name"), ipv4_address=yang.gdata.from_xml_str(n, "ipv4-address"))

class netinfra_inter__netinfra__ibgp_fullmesh__router(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__ibgp_fullmesh__router_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://example.com/netinfra-inter"
        self._name = 'router'
        self.elements = elements

    mut def create(self, name, ipv4_address):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__ibgp_fullmesh__router_entry(name, ipv4_address)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__ibgp_fullmesh__router_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__ibgp_fullmesh__router_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[netinfra_inter__netinfra__ibgp_fullmesh__router_entry]:
        res = []
        for node in nodes:
            res.append(netinfra_inter__netinfra__ibgp_fullmesh__router_entry.from_xml(node))
        return res


mut def from_json_path_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['name']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__ibgp_fullmesh__router(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name_full = jd.get('netinfra-inter:name')
    child_name = child_name_full if child_name_full is not None else jd.get('name')
    if child_name is not None:
        children['name'] = from_json_netinfra_inter__netinfra__ibgp_fullmesh__router__name(child_name)
    child_ipv4_address_full = jd.get('netinfra-inter:ipv4-address')
    child_ipv4_address = child_ipv4_address_full if child_ipv4_address_full is not None else jd.get('ipv4-address')
    if child_ipv4_address is not None:
        children['ipv4-address'] = from_json_netinfra_inter__netinfra__ibgp_fullmesh__router__ipv4_address(child_ipv4_address)
    return yang.gdata.Container(children, [str(child_name if child_name is not None else "")])

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__router(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(e))
    return yang.gdata.List(keys=['name'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_name = n.children.get('name')
    if child_name is not None:
        if isinstance(child_name, yang.gdata.Leaf):
            children['name'] = child_name.val
    child_ipv4_address = n.children.get('ipv4-address')
    if child_ipv4_address is not None:
        if isinstance(child_ipv4_address, yang.gdata.Leaf):
            children['ipv4-address'] = child_ipv4_address.val
    return children

mut def to_json_netinfra_inter__netinfra__ibgp_fullmesh__router(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(e))
    return elements

class netinfra_inter__netinfra__ibgp_fullmesh_entry(yang.adata.MNode):
    asn: int
    authentication_key: str
    router: netinfra_inter__netinfra__ibgp_fullmesh__router

    mut def __init__(self, asn: int, authentication_key: str, router: list[netinfra_inter__netinfra__ibgp_fullmesh__router_entry]=[]):
        self._ns = "http://example.com/netinfra-inter"
        self.asn = asn
        self.authentication_key = authentication_key
        self.router = netinfra_inter__netinfra__ibgp_fullmesh__router(elements=router)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _asn = self.asn
        _authentication_key = self.authentication_key
        _router = self.router
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        if _authentication_key is not None:
            children['authentication-key'] = yang.gdata.Leaf('string', _authentication_key)
        if _router is not None:
            children['router'] = _router.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.asn)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__ibgp_fullmesh_entry:
        return netinfra_inter__netinfra__ibgp_fullmesh_entry(asn=n.get_int("asn"), authentication_key=n.get_str("authentication-key"), router=netinfra_inter__netinfra__ibgp_fullmesh__router.from_gdata(n.get_opt_list("router")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> netinfra_inter__netinfra__ibgp_fullmesh_entry:
        return netinfra_inter__netinfra__ibgp_fullmesh_entry(asn=yang.gdata.from_xml_int(n, "asn"), authentication_key=yang.gdata.from_xml_str(n, "authentication-key"), router=netinfra_inter__netinfra__ibgp_fullmesh__router.from_xml(yang.gdata.get_xml_children(n, "router")))

class netinfra_inter__netinfra__ibgp_fullmesh(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__ibgp_fullmesh_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://example.com/netinfra-inter"
        self._name = 'ibgp-fullmesh'
        self.elements = elements

    mut def create(self, asn, authentication_key):
        for e in self.elements:
            match = True
            if e.asn != asn:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__ibgp_fullmesh_entry(asn, authentication_key)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['asn'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__ibgp_fullmesh_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__ibgp_fullmesh_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[netinfra_inter__netinfra__ibgp_fullmesh_entry]:
        res = []
        for node in nodes:
            res.append(netinfra_inter__netinfra__ibgp_fullmesh_entry.from_xml(node))
        return res


mut def from_json_path_netinfra_inter__netinfra__ibgp_fullmesh_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__ibgp_fullmesh_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['asn']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'authentication-key':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'router':
            children['router'] = from_json_path_netinfra_inter__netinfra__ibgp_fullmesh__router(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__ibgp_fullmesh(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['asn']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__ibgp_fullmesh_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['asn'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['asn'], [from_json_path_netinfra_inter__netinfra__ibgp_fullmesh_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_asn_full = jd.get('netinfra-inter:asn')
    child_asn = child_asn_full if child_asn_full is not None else jd.get('asn')
    if child_asn is not None:
        children['asn'] = from_json_netinfra_inter__netinfra__ibgp_fullmesh__asn(child_asn)
    child_authentication_key_full = jd.get('netinfra-inter:authentication-key')
    child_authentication_key = child_authentication_key_full if child_authentication_key_full is not None else jd.get('authentication-key')
    if child_authentication_key is not None:
        children['authentication-key'] = from_json_netinfra_inter__netinfra__ibgp_fullmesh__authentication_key(child_authentication_key)
    child_router_full = jd.get('netinfra-inter:router')
    child_router = child_router_full if child_router_full is not None else jd.get('router')
    if child_router is not None and isinstance(child_router, list):
        children['router'] = from_json_netinfra_inter__netinfra__ibgp_fullmesh__router(child_router)
    return yang.gdata.Container(children, [str(child_asn if child_asn is not None else "")])

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__ibgp_fullmesh_element(e))
    return yang.gdata.List(keys=['asn'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_netinfra_inter__netinfra__ibgp_fullmesh_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_asn = n.children.get('asn')
    if child_asn is not None:
        if isinstance(child_asn, yang.gdata.Leaf):
            children['asn'] = child_asn.val
    child_authentication_key = n.children.get('authentication-key')
    if child_authentication_key is not None:
        if isinstance(child_authentication_key, yang.gdata.Leaf):
            children['authentication-key'] = child_authentication_key.val
    child_router = n.children.get('router')
    if child_router is not None:
        if isinstance(child_router, yang.gdata.List):
            children['router'] = to_json_netinfra_inter__netinfra__ibgp_fullmesh__router(child_router)
    return children

mut def to_json_netinfra_inter__netinfra__ibgp_fullmesh(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_netinfra_inter__netinfra__ibgp_fullmesh_element(e))
    return elements

class netinfra_inter__netinfra(yang.adata.MNode):
    router: netinfra_inter__netinfra__router
    backbone_link: netinfra_inter__netinfra__backbone_link
    ibgp_fullmesh: netinfra_inter__netinfra__ibgp_fullmesh

    mut def __init__(self, router: list[netinfra_inter__netinfra__router_entry]=[], backbone_link: list[netinfra_inter__netinfra__backbone_link_entry]=[], ibgp_fullmesh: list[netinfra_inter__netinfra__ibgp_fullmesh_entry]=[]):
        self._ns = "http://example.com/netinfra-inter"
        self.router = netinfra_inter__netinfra__router(elements=router)
        self.backbone_link = netinfra_inter__netinfra__backbone_link(elements=backbone_link)
        self.ibgp_fullmesh = netinfra_inter__netinfra__ibgp_fullmesh(elements=ibgp_fullmesh)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _router = self.router
        _backbone_link = self.backbone_link
        _ibgp_fullmesh = self.ibgp_fullmesh
        if _router is not None:
            children['router'] = _router.to_gdata()
        if _backbone_link is not None:
            children['backbone-link'] = _backbone_link.to_gdata()
        if _ibgp_fullmesh is not None:
            children['ibgp-fullmesh'] = _ibgp_fullmesh.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/netinfra-inter')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> netinfra_inter__netinfra:
        if n != None:
            return netinfra_inter__netinfra(router=netinfra_inter__netinfra__router.from_gdata(n.get_opt_list("router")), backbone_link=netinfra_inter__netinfra__backbone_link.from_gdata(n.get_opt_list("backbone-link")), ibgp_fullmesh=netinfra_inter__netinfra__ibgp_fullmesh.from_gdata(n.get_opt_list("ibgp-fullmesh")))
        return netinfra_inter__netinfra()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> netinfra_inter__netinfra:
        if n != None:
            return netinfra_inter__netinfra(router=netinfra_inter__netinfra__router.from_xml(yang.gdata.get_xml_children(n, "router")), backbone_link=netinfra_inter__netinfra__backbone_link.from_xml(yang.gdata.get_xml_children(n, "backbone-link")), ibgp_fullmesh=netinfra_inter__netinfra__ibgp_fullmesh.from_xml(yang.gdata.get_xml_children(n, "ibgp-fullmesh")))
        return netinfra_inter__netinfra()


mut def from_json_path_netinfra_inter__netinfra(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'netinfra-inter:router' or point == 'router':
            child = {'router': from_json_path_netinfra_inter__netinfra__router(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'netinfra-inter:backbone-link' or point == 'backbone-link':
            child = {'backbone-link': from_json_path_netinfra_inter__netinfra__backbone_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'netinfra-inter:ibgp-fullmesh' or point == 'ibgp-fullmesh':
            child = {'ibgp-fullmesh': from_json_path_netinfra_inter__netinfra__ibgp_fullmesh(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_netinfra_inter__netinfra(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_netinfra_inter__netinfra(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_router_full = jd.get('netinfra-inter:router')
    child_router = child_router_full if child_router_full is not None else jd.get('router')
    if child_router is not None and isinstance(child_router, list):
        children['router'] = from_json_netinfra_inter__netinfra__router(child_router)
    child_backbone_link_full = jd.get('netinfra-inter:backbone-link')
    child_backbone_link = child_backbone_link_full if child_backbone_link_full is not None else jd.get('backbone-link')
    if child_backbone_link is not None and isinstance(child_backbone_link, list):
        children['backbone-link'] = from_json_netinfra_inter__netinfra__backbone_link(child_backbone_link)
    child_ibgp_fullmesh_full = jd.get('netinfra-inter:ibgp-fullmesh')
    child_ibgp_fullmesh = child_ibgp_fullmesh_full if child_ibgp_fullmesh_full is not None else jd.get('ibgp-fullmesh')
    if child_ibgp_fullmesh is not None and isinstance(child_ibgp_fullmesh, list):
        children['ibgp-fullmesh'] = from_json_netinfra_inter__netinfra__ibgp_fullmesh(child_ibgp_fullmesh)
    return yang.gdata.Container(children)

mut def to_json_netinfra_inter__netinfra(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_router = n.children.get('router')
    if child_router is not None:
        if isinstance(child_router, yang.gdata.List):
            children['router'] = to_json_netinfra_inter__netinfra__router(child_router)
    child_backbone_link = n.children.get('backbone-link')
    if child_backbone_link is not None:
        if isinstance(child_backbone_link, yang.gdata.List):
            children['backbone-link'] = to_json_netinfra_inter__netinfra__backbone_link(child_backbone_link)
    child_ibgp_fullmesh = n.children.get('ibgp-fullmesh')
    if child_ibgp_fullmesh is not None:
        if isinstance(child_ibgp_fullmesh, yang.gdata.List):
            children['ibgp-fullmesh'] = to_json_netinfra_inter__netinfra__ibgp_fullmesh(child_ibgp_fullmesh)
    return children

mut def from_json_l3vpn_inter__l3vpns__l3vpn__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__device(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__site_network_access(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__provider_ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__customer_ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__ipv4_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

class l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(yang.adata.MNode):
    as_number: int

    mut def __init__(self, as_number: int):
        self._ns = "http://example.com/l3vpn-inter"
        self.as_number = as_number

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('uint32', _as_number)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?l3vpn_inter__l3vpns__l3vpn__endpoint__bgp:
        if n != None:
            return l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(as_number=n.get_int("as-number"))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?l3vpn_inter__l3vpns__l3vpn__endpoint__bgp:
        if n != None:
            return l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(as_number=yang.gdata.from_xml_int(n, "as-number"))
        return None


mut def from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-inter:as-number' or point == 'as-number':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_as_number_full = jd.get('l3vpn-inter:as-number')
    child_as_number = child_as_number_full if child_as_number_full is not None else jd.get('as-number')
    if child_as_number is not None:
        children['as-number'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp__as_number(child_as_number)
    return yang.gdata.Container(children)

mut def to_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_as_number = n.children.get('as-number')
    if child_as_number is not None:
        if isinstance(child_as_number, yang.gdata.Leaf):
            children['as-number'] = child_as_number.val
    return children

class l3vpn_inter__l3vpns__l3vpn__endpoint_entry(yang.adata.MNode):
    device: str
    interface: str
    site: str
    site_network_access: str
    provider_ipv4_address: str
    customer_ipv4_address: ?str
    ipv4_prefix_length: int
    bgp: ?l3vpn_inter__l3vpns__l3vpn__endpoint__bgp

    mut def __init__(self, device: str, interface: str, site: str, site_network_access: str, provider_ipv4_address: str, ipv4_prefix_length: int, customer_ipv4_address: ?str, bgp: ?l3vpn_inter__l3vpns__l3vpn__endpoint__bgp=None):
        self._ns = "http://example.com/l3vpn-inter"
        self.device = device
        self.interface = interface
        self.site = site
        self.site_network_access = site_network_access
        self.provider_ipv4_address = provider_ipv4_address
        self.customer_ipv4_address = customer_ipv4_address
        self.ipv4_prefix_length = ipv4_prefix_length
        self.bgp = bgp

    mut def create_bgp(self, as_number):
        res = l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(as_number)
        self.bgp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device = self.device
        _interface = self.interface
        _site = self.site
        _site_network_access = self.site_network_access
        _provider_ipv4_address = self.provider_ipv4_address
        _customer_ipv4_address = self.customer_ipv4_address
        _ipv4_prefix_length = self.ipv4_prefix_length
        _bgp = self.bgp
        if _device is not None:
            children['device'] = yang.gdata.Leaf('string', _device)
        if _interface is not None:
            children['interface'] = yang.gdata.Leaf('string', _interface)
        if _site is not None:
            children['site'] = yang.gdata.Leaf('string', _site)
        if _site_network_access is not None:
            children['site-network-access'] = yang.gdata.Leaf('string', _site_network_access)
        if _provider_ipv4_address is not None:
            children['provider-ipv4-address'] = yang.gdata.Leaf('string', _provider_ipv4_address)
        if _customer_ipv4_address is not None:
            children['customer-ipv4-address'] = yang.gdata.Leaf('string', _customer_ipv4_address)
        if _ipv4_prefix_length is not None:
            children['ipv4-prefix-length'] = yang.gdata.Leaf('uint8', _ipv4_prefix_length)
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.device), yang.gdata.yang_str(self.interface)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> l3vpn_inter__l3vpns__l3vpn__endpoint_entry:
        return l3vpn_inter__l3vpns__l3vpn__endpoint_entry(device=n.get_str("device"), interface=n.get_str("interface"), site=n.get_str("site"), site_network_access=n.get_str("site-network-access"), provider_ipv4_address=n.get_str("provider-ipv4-address"), customer_ipv4_address=n.get_opt_str("customer-ipv4-address"), ipv4_prefix_length=n.get_int("ipv4-prefix-length"), bgp=l3vpn_inter__l3vpns__l3vpn__endpoint__bgp.from_gdata(n.get_opt_container("bgp")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> l3vpn_inter__l3vpns__l3vpn__endpoint_entry:
        return l3vpn_inter__l3vpns__l3vpn__endpoint_entry(device=yang.gdata.from_xml_str(n, "device"), interface=yang.gdata.from_xml_str(n, "interface"), site=yang.gdata.from_xml_str(n, "site"), site_network_access=yang.gdata.from_xml_str(n, "site-network-access"), provider_ipv4_address=yang.gdata.from_xml_str(n, "provider-ipv4-address"), customer_ipv4_address=yang.gdata.from_xml_opt_str(n, "customer-ipv4-address"), ipv4_prefix_length=yang.gdata.from_xml_int(n, "ipv4-prefix-length"), bgp=l3vpn_inter__l3vpns__l3vpn__endpoint__bgp.from_xml(yang.gdata.get_xml_opt_child(n, "bgp")))

class l3vpn_inter__l3vpns__l3vpn__endpoint(yang.adata.MNode):
    elements: list[l3vpn_inter__l3vpns__l3vpn__endpoint_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://example.com/l3vpn-inter"
        self._name = 'endpoint'
        self.elements = elements

    mut def create(self, device, interface, site, site_network_access, provider_ipv4_address, ipv4_prefix_length, bgp):
        for e in self.elements:
            match = True
            if e.device != device:
                match = False
                continue
            if e.interface != interface:
                match = False
                continue
            if match:
                return e

        res = l3vpn_inter__l3vpns__l3vpn__endpoint_entry(device, interface, site, site_network_access, provider_ipv4_address, ipv4_prefix_length, bgp)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['device', 'interface'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[l3vpn_inter__l3vpns__l3vpn__endpoint_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(l3vpn_inter__l3vpns__l3vpn__endpoint_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[l3vpn_inter__l3vpns__l3vpn__endpoint_entry]:
        res = []
        for node in nodes:
            res.append(l3vpn_inter__l3vpns__l3vpn__endpoint_entry.from_xml(node))
        return res


mut def from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['device', 'interface']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'site-network-access':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'provider-ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bgp':
            children['bgp'] = from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['device', 'interface']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['device', 'interface'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['device', 'interface'], [from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_device_full = jd.get('l3vpn-inter:device')
    child_device = child_device_full if child_device_full is not None else jd.get('device')
    if child_device is not None:
        children['device'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__device(child_device)
    child_interface_full = jd.get('l3vpn-inter:interface')
    child_interface = child_interface_full if child_interface_full is not None else jd.get('interface')
    if child_interface is not None:
        children['interface'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__interface(child_interface)
    child_site_full = jd.get('l3vpn-inter:site')
    child_site = child_site_full if child_site_full is not None else jd.get('site')
    if child_site is not None:
        children['site'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__site(child_site)
    child_site_network_access_full = jd.get('l3vpn-inter:site-network-access')
    child_site_network_access = child_site_network_access_full if child_site_network_access_full is not None else jd.get('site-network-access')
    if child_site_network_access is not None:
        children['site-network-access'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__site_network_access(child_site_network_access)
    child_provider_ipv4_address_full = jd.get('l3vpn-inter:provider-ipv4-address')
    child_provider_ipv4_address = child_provider_ipv4_address_full if child_provider_ipv4_address_full is not None else jd.get('provider-ipv4-address')
    if child_provider_ipv4_address is not None:
        children['provider-ipv4-address'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__provider_ipv4_address(child_provider_ipv4_address)
    child_customer_ipv4_address_full = jd.get('l3vpn-inter:customer-ipv4-address')
    child_customer_ipv4_address = child_customer_ipv4_address_full if child_customer_ipv4_address_full is not None else jd.get('customer-ipv4-address')
    if child_customer_ipv4_address is not None:
        children['customer-ipv4-address'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__customer_ipv4_address(child_customer_ipv4_address)
    child_ipv4_prefix_length_full = jd.get('l3vpn-inter:ipv4-prefix-length')
    child_ipv4_prefix_length = child_ipv4_prefix_length_full if child_ipv4_prefix_length_full is not None else jd.get('ipv4-prefix-length')
    if child_ipv4_prefix_length is not None:
        children['ipv4-prefix-length'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__ipv4_prefix_length(child_ipv4_prefix_length)
    child_bgp_full = jd.get('l3vpn-inter:bgp')
    child_bgp = child_bgp_full if child_bgp_full is not None else jd.get('bgp')
    if child_bgp is not None and isinstance(child_bgp, dict):
        children['bgp'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(child_bgp)
    return yang.gdata.Container(children, [str(child_device if child_device is not None else ""), str(child_interface if child_interface is not None else "")])

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(e))
    return yang.gdata.List(keys=['device', 'interface'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_device = n.children.get('device')
    if child_device is not None:
        if isinstance(child_device, yang.gdata.Leaf):
            children['device'] = child_device.val
    child_interface = n.children.get('interface')
    if child_interface is not None:
        if isinstance(child_interface, yang.gdata.Leaf):
            children['interface'] = child_interface.val
    child_site = n.children.get('site')
    if child_site is not None:
        if isinstance(child_site, yang.gdata.Leaf):
            children['site'] = child_site.val
    child_site_network_access = n.children.get('site-network-access')
    if child_site_network_access is not None:
        if isinstance(child_site_network_access, yang.gdata.Leaf):
            children['site-network-access'] = child_site_network_access.val
    child_provider_ipv4_address = n.children.get('provider-ipv4-address')
    if child_provider_ipv4_address is not None:
        if isinstance(child_provider_ipv4_address, yang.gdata.Leaf):
            children['provider-ipv4-address'] = child_provider_ipv4_address.val
    child_customer_ipv4_address = n.children.get('customer-ipv4-address')
    if child_customer_ipv4_address is not None:
        if isinstance(child_customer_ipv4_address, yang.gdata.Leaf):
            children['customer-ipv4-address'] = child_customer_ipv4_address.val
    child_ipv4_prefix_length = n.children.get('ipv4-prefix-length')
    if child_ipv4_prefix_length is not None:
        if isinstance(child_ipv4_prefix_length, yang.gdata.Leaf):
            children['ipv4-prefix-length'] = child_ipv4_prefix_length.val
    child_bgp = n.children.get('bgp')
    if child_bgp is not None:
        if isinstance(child_bgp, yang.gdata.Container):
            children['bgp'] = to_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(child_bgp)
    return children

mut def to_json_l3vpn_inter__l3vpns__l3vpn__endpoint(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(e))
    return elements

class l3vpn_inter__l3vpns__l3vpn_entry(yang.adata.MNode):
    name: str
    description: ?str
    endpoint: l3vpn_inter__l3vpns__l3vpn__endpoint

    mut def __init__(self, name: str, description: ?str, endpoint: list[l3vpn_inter__l3vpns__l3vpn__endpoint_entry]=[]):
        self._ns = "http://example.com/l3vpn-inter"
        self.name = name
        self.description = description
        self.endpoint = l3vpn_inter__l3vpns__l3vpn__endpoint(elements=endpoint)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        _description = self.description
        _endpoint = self.endpoint
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        if _endpoint is not None:
            children['endpoint'] = _endpoint.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> l3vpn_inter__l3vpns__l3vpn_entry:
        return l3vpn_inter__l3vpns__l3vpn_entry(name=n.get_str("name"), description=n.get_opt_str("description"), endpoint=l3vpn_inter__l3vpns__l3vpn__endpoint.from_gdata(n.get_opt_list("endpoint")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> l3vpn_inter__l3vpns__l3vpn_entry:
        return l3vpn_inter__l3vpns__l3vpn_entry(name=yang.gdata.from_xml_str(n, "name"), description=yang.gdata.from_xml_opt_str(n, "description"), endpoint=l3vpn_inter__l3vpns__l3vpn__endpoint.from_xml(yang.gdata.get_xml_children(n, "endpoint")))

class l3vpn_inter__l3vpns__l3vpn(yang.adata.MNode):
    elements: list[l3vpn_inter__l3vpns__l3vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://example.com/l3vpn-inter"
        self._name = 'l3vpn'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = l3vpn_inter__l3vpns__l3vpn_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[l3vpn_inter__l3vpns__l3vpn_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(l3vpn_inter__l3vpns__l3vpn_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[l3vpn_inter__l3vpns__l3vpn_entry]:
        res = []
        for node in nodes:
            res.append(l3vpn_inter__l3vpns__l3vpn_entry.from_xml(node))
        return res


mut def from_json_path_l3vpn_inter__l3vpns__l3vpn_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_l3vpn_inter__l3vpns__l3vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['name']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'description':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'endpoint':
            children['endpoint'] = from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_l3vpn_inter__l3vpns__l3vpn(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_l3vpn_inter__l3vpns__l3vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_l3vpn_inter__l3vpns__l3vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_l3vpn_inter__l3vpns__l3vpn_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name_full = jd.get('l3vpn-inter:name')
    child_name = child_name_full if child_name_full is not None else jd.get('name')
    if child_name is not None:
        children['name'] = from_json_l3vpn_inter__l3vpns__l3vpn__name(child_name)
    child_description_full = jd.get('l3vpn-inter:description')
    child_description = child_description_full if child_description_full is not None else jd.get('description')
    if child_description is not None:
        children['description'] = from_json_l3vpn_inter__l3vpns__l3vpn__description(child_description)
    child_endpoint_full = jd.get('l3vpn-inter:endpoint')
    child_endpoint = child_endpoint_full if child_endpoint_full is not None else jd.get('endpoint')
    if child_endpoint is not None and isinstance(child_endpoint, list):
        children['endpoint'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint(child_endpoint)
    return yang.gdata.Container(children, [str(child_name if child_name is not None else "")])

mut def from_json_l3vpn_inter__l3vpns__l3vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_l3vpn_inter__l3vpns__l3vpn_element(e))
    return yang.gdata.List(keys=['name'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_l3vpn_inter__l3vpns__l3vpn_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_name = n.children.get('name')
    if child_name is not None:
        if isinstance(child_name, yang.gdata.Leaf):
            children['name'] = child_name.val
    child_description = n.children.get('description')
    if child_description is not None:
        if isinstance(child_description, yang.gdata.Leaf):
            children['description'] = child_description.val
    child_endpoint = n.children.get('endpoint')
    if child_endpoint is not None:
        if isinstance(child_endpoint, yang.gdata.List):
            children['endpoint'] = to_json_l3vpn_inter__l3vpns__l3vpn__endpoint(child_endpoint)
    return children

mut def to_json_l3vpn_inter__l3vpns__l3vpn(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_l3vpn_inter__l3vpns__l3vpn_element(e))
    return elements

class l3vpn_inter__l3vpns(yang.adata.MNode):
    l3vpn: l3vpn_inter__l3vpns__l3vpn

    mut def __init__(self, l3vpn: list[l3vpn_inter__l3vpns__l3vpn_entry]=[]):
        self._ns = "http://example.com/l3vpn-inter"
        self.l3vpn = l3vpn_inter__l3vpns__l3vpn(elements=l3vpn)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l3vpn = self.l3vpn
        if _l3vpn is not None:
            children['l3vpn'] = _l3vpn.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/l3vpn-inter')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> l3vpn_inter__l3vpns:
        if n != None:
            return l3vpn_inter__l3vpns(l3vpn=l3vpn_inter__l3vpns__l3vpn.from_gdata(n.get_opt_list("l3vpn")))
        return l3vpn_inter__l3vpns()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> l3vpn_inter__l3vpns:
        if n != None:
            return l3vpn_inter__l3vpns(l3vpn=l3vpn_inter__l3vpns__l3vpn.from_xml(yang.gdata.get_xml_children(n, "l3vpn")))
        return l3vpn_inter__l3vpns()


mut def from_json_path_l3vpn_inter__l3vpns(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-inter:l3vpn' or point == 'l3vpn':
            child = {'l3vpn': from_json_path_l3vpn_inter__l3vpns__l3vpn(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_l3vpn_inter__l3vpns(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_l3vpn_inter__l3vpns(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l3vpn_full = jd.get('l3vpn-inter:l3vpn')
    child_l3vpn = child_l3vpn_full if child_l3vpn_full is not None else jd.get('l3vpn')
    if child_l3vpn is not None and isinstance(child_l3vpn, list):
        children['l3vpn'] = from_json_l3vpn_inter__l3vpns__l3vpn(child_l3vpn)
    return yang.gdata.Container(children)

mut def to_json_l3vpn_inter__l3vpns(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_l3vpn = n.children.get('l3vpn')
    if child_l3vpn is not None:
        if isinstance(child_l3vpn, yang.gdata.List):
            children['l3vpn'] = to_json_l3vpn_inter__l3vpns__l3vpn(child_l3vpn)
    return children

class root(yang.adata.MNode):
    netinfra: netinfra_inter__netinfra
    l3vpns: l3vpn_inter__l3vpns

    mut def __init__(self, netinfra: ?netinfra_inter__netinfra=None, l3vpns: ?l3vpn_inter__l3vpns=None):
        self._ns = ""
        if netinfra is not None:
            self.netinfra = netinfra
        else:
            self.netinfra = netinfra_inter__netinfra()
        if l3vpns is not None:
            self.l3vpns = l3vpns
        else:
            self.l3vpns = l3vpn_inter__l3vpns()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _netinfra = self.netinfra
        _l3vpns = self.l3vpns
        if _netinfra is not None:
            children['netinfra'] = _netinfra.to_gdata()
        if _l3vpns is not None:
            children['l3vpns'] = _l3vpns.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n != None:
            return root(netinfra=netinfra_inter__netinfra.from_gdata(n.get_opt_container("netinfra")), l3vpns=l3vpn_inter__l3vpns.from_gdata(n.get_opt_container("l3vpns")))
        return root()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> root:
        if n != None:
            return root(netinfra=netinfra_inter__netinfra.from_xml(yang.gdata.get_xml_opt_child(n, "netinfra", "http://example.com/netinfra-inter")), l3vpns=l3vpn_inter__l3vpns.from_xml(yang.gdata.get_xml_opt_child(n, "l3vpns", "http://example.com/l3vpn-inter")))
        return root()


mut def from_json_path(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'netinfra-inter:netinfra':
            child = {'netinfra': from_json_path_netinfra_inter__netinfra(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-inter:l3vpns':
            child = {'l3vpns': from_json_path_l3vpn_inter__l3vpns(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_netinfra = jd.get('netinfra-inter:netinfra')
    if child_netinfra is not None and isinstance(child_netinfra, dict):
        children['netinfra'] = from_json_netinfra_inter__netinfra(child_netinfra)
    child_l3vpns = jd.get('l3vpn-inter:l3vpns')
    if child_l3vpns is not None and isinstance(child_l3vpns, dict):
        children['l3vpns'] = from_json_l3vpn_inter__l3vpns(child_l3vpns)
    return yang.gdata.Container(children)

mut def to_json(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_netinfra = n.children.get('netinfra')
    if child_netinfra is not None:
        if isinstance(child_netinfra, yang.gdata.Container):
            children['netinfra-inter:netinfra'] = to_json_netinfra_inter__netinfra(child_netinfra)
    child_l3vpns = n.children.get('l3vpns')
    if child_l3vpns is not None:
        if isinstance(child_l3vpns, yang.gdata.Container):
            children['l3vpn-inter:l3vpns'] = to_json_l3vpn_inter__l3vpns(child_l3vpns)
    return children

schema_namespaces: set[str] = {
    "http://example.com/netinfra-inter",
    "http://example.com/l3vpn-inter",
}
