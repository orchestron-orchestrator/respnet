import base64
import json
import xml
import yang.adata
import yang.gdata

# == This file is generated ==


mut def from_json_netinfra__netinfra__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra__netinfra__router__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_netinfra__netinfra__router__role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra__netinfra__router__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_netinfra__netinfra__router__mock(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

class netinfra__netinfra__router_entry(yang.adata.MNode):
    name: str
    id: ?int
    role: ?str
    asn: ?int
    mock: ?str

    mut def __init__(self, name: str, id: ?int, role: ?str, asn: ?int, mock: ?str):
        self._ns = "http://example.com/netinfra"
        self.name = name
        self.id = id
        self.role = role
        self.asn = asn
        self.mock = mock

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        _id = self.id
        _role = self.role
        _asn = self.asn
        _mock = self.mock
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint32', _id)
        if _role is not None:
            children['role'] = yang.gdata.Leaf('string', _role)
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        if _mock is not None:
            children['mock'] = yang.gdata.Leaf('enumeration', _mock)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.name)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__router_entry:
        return netinfra__netinfra__router_entry(name=n.get_str("name"), id=n.get_opt_int("id"), role=n.get_opt_str("role"), asn=n.get_opt_int("asn"), mock=n.get_opt_str("mock"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> netinfra__netinfra__router_entry:
        return netinfra__netinfra__router_entry(name=yang.gdata.from_xml_str(n, "name"), id=yang.gdata.from_xml_opt_int(n, "id"), role=yang.gdata.from_xml_opt_str(n, "role"), asn=yang.gdata.from_xml_opt_int(n, "asn"), mock=yang.gdata.from_xml_opt_str(n, "mock"))

class netinfra__netinfra__router(yang.adata.MNode):
    elements: list[netinfra__netinfra__router_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://example.com/netinfra"
        self._name = 'router'
        self.elements = elements

    mut def create(self, name, id, asn):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__router_entry(name, id, asn)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__router_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra__netinfra__router_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[netinfra__netinfra__router_entry]:
        res = []
        for node in nodes:
            res.append(netinfra__netinfra__router_entry.from_xml(node))
        return res


mut def from_json_path_netinfra__netinfra__router_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra__netinfra__router_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['name']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'role':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'mock':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra__netinfra__router(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra__netinfra__router_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_netinfra__netinfra__router_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra__netinfra__router_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_name_full = jd.get('netinfra:name')
    child_name = child_name_full if child_name_full is not None else jd.get('name')
    if child_name is not None:
        children['name'] = from_json_netinfra__netinfra__router__name(child_name)
    child_id_full = jd.get('netinfra:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_netinfra__netinfra__router__id(child_id)
    child_role_full = jd.get('netinfra:role')
    child_role = child_role_full if child_role_full is not None else jd.get('role')
    if child_role is not None:
        children['role'] = from_json_netinfra__netinfra__router__role(child_role)
    child_asn_full = jd.get('netinfra:asn')
    child_asn = child_asn_full if child_asn_full is not None else jd.get('asn')
    if child_asn is not None:
        children['asn'] = from_json_netinfra__netinfra__router__asn(child_asn)
    child_mock_full = jd.get('netinfra:mock')
    child_mock = child_mock_full if child_mock_full is not None else jd.get('mock')
    if child_mock is not None:
        children['mock'] = from_json_netinfra__netinfra__router__mock(child_mock)
    return yang.gdata.ListElement([str(child_name if child_name is not None else "")], children)

mut def from_json_netinfra__netinfra__router(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra__netinfra__router_element(e))
    return yang.gdata.List(keys=['name'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_netinfra__netinfra__router_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_name = n.children.get('name')
    if child_name is not None:
        if isinstance(child_name, yang.gdata.Leaf):
            children['name'] = child_name.val
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    child_role = n.children.get('role')
    if child_role is not None:
        if isinstance(child_role, yang.gdata.Leaf):
            children['role'] = child_role.val
    child_asn = n.children.get('asn')
    if child_asn is not None:
        if isinstance(child_asn, yang.gdata.Leaf):
            children['asn'] = child_asn.val
    child_mock = n.children.get('mock')
    if child_mock is not None:
        if isinstance(child_mock, yang.gdata.Leaf):
            children['mock'] = child_mock.val
    return children

mut def to_json_netinfra__netinfra__router(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_netinfra__netinfra__router_element(e))
    return elements

mut def from_json_netinfra__netinfra__backbone_link__left_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra__netinfra__backbone_link__left_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra__netinfra__backbone_link__right_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_netinfra__netinfra__backbone_link__right_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class netinfra__netinfra__backbone_link_entry(yang.adata.MNode):
    left_router: str
    left_interface: str
    right_router: str
    right_interface: str

    mut def __init__(self, left_router: str, left_interface: str, right_router: str, right_interface: str):
        self._ns = "http://example.com/netinfra"
        self.left_router = left_router
        self.left_interface = left_interface
        self.right_router = right_router
        self.right_interface = right_interface

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _left_router = self.left_router
        _left_interface = self.left_interface
        _right_router = self.right_router
        _right_interface = self.right_interface
        if _left_router is not None:
            children['left-router'] = yang.gdata.Leaf('string', _left_router)
        if _left_interface is not None:
            children['left-interface'] = yang.gdata.Leaf('string', _left_interface)
        if _right_router is not None:
            children['right-router'] = yang.gdata.Leaf('string', _right_router)
        if _right_interface is not None:
            children['right-interface'] = yang.gdata.Leaf('string', _right_interface)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.left_router), yang.gdata.yang_str(self.left_interface), yang.gdata.yang_str(self.right_router), yang.gdata.yang_str(self.right_interface)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__backbone_link_entry:
        return netinfra__netinfra__backbone_link_entry(left_router=n.get_str("left-router"), left_interface=n.get_str("left-interface"), right_router=n.get_str("right-router"), right_interface=n.get_str("right-interface"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> netinfra__netinfra__backbone_link_entry:
        return netinfra__netinfra__backbone_link_entry(left_router=yang.gdata.from_xml_str(n, "left-router"), left_interface=yang.gdata.from_xml_str(n, "left-interface"), right_router=yang.gdata.from_xml_str(n, "right-router"), right_interface=yang.gdata.from_xml_str(n, "right-interface"))

class netinfra__netinfra__backbone_link(yang.adata.MNode):
    elements: list[netinfra__netinfra__backbone_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://example.com/netinfra"
        self._name = 'backbone-link'
        self.elements = elements

    mut def create(self, left_router, left_interface, right_router, right_interface):
        for e in self.elements:
            match = True
            if e.left_router != left_router:
                match = False
                continue
            if e.left_interface != left_interface:
                match = False
                continue
            if e.right_router != right_router:
                match = False
                continue
            if e.right_interface != right_interface:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__backbone_link_entry(left_router, left_interface, right_router, right_interface)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__backbone_link_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra__netinfra__backbone_link_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[netinfra__netinfra__backbone_link_entry]:
        res = []
        for node in nodes:
            res.append(netinfra__netinfra__backbone_link_entry.from_xml(node))
        return res


mut def from_json_path_netinfra__netinfra__backbone_link_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra__netinfra__backbone_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['left-router', 'left-interface', 'right-router', 'right-interface']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra__netinfra__backbone_link(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['left-router', 'left-interface', 'right-router', 'right-interface']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra__netinfra__backbone_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], [from_json_path_netinfra__netinfra__backbone_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra__netinfra__backbone_link_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_left_router_full = jd.get('netinfra:left-router')
    child_left_router = child_left_router_full if child_left_router_full is not None else jd.get('left-router')
    if child_left_router is not None:
        children['left-router'] = from_json_netinfra__netinfra__backbone_link__left_router(child_left_router)
    child_left_interface_full = jd.get('netinfra:left-interface')
    child_left_interface = child_left_interface_full if child_left_interface_full is not None else jd.get('left-interface')
    if child_left_interface is not None:
        children['left-interface'] = from_json_netinfra__netinfra__backbone_link__left_interface(child_left_interface)
    child_right_router_full = jd.get('netinfra:right-router')
    child_right_router = child_right_router_full if child_right_router_full is not None else jd.get('right-router')
    if child_right_router is not None:
        children['right-router'] = from_json_netinfra__netinfra__backbone_link__right_router(child_right_router)
    child_right_interface_full = jd.get('netinfra:right-interface')
    child_right_interface = child_right_interface_full if child_right_interface_full is not None else jd.get('right-interface')
    if child_right_interface is not None:
        children['right-interface'] = from_json_netinfra__netinfra__backbone_link__right_interface(child_right_interface)
    return yang.gdata.ListElement([str(child_left_router if child_left_router is not None else ""), str(child_left_interface if child_left_interface is not None else ""), str(child_right_router if child_right_router is not None else ""), str(child_right_interface if child_right_interface is not None else "")], children)

mut def from_json_netinfra__netinfra__backbone_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra__netinfra__backbone_link_element(e))
    return yang.gdata.List(keys=['left-router', 'left-interface', 'right-router', 'right-interface'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_netinfra__netinfra__backbone_link_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_left_router = n.children.get('left-router')
    if child_left_router is not None:
        if isinstance(child_left_router, yang.gdata.Leaf):
            children['left-router'] = child_left_router.val
    child_left_interface = n.children.get('left-interface')
    if child_left_interface is not None:
        if isinstance(child_left_interface, yang.gdata.Leaf):
            children['left-interface'] = child_left_interface.val
    child_right_router = n.children.get('right-router')
    if child_right_router is not None:
        if isinstance(child_right_router, yang.gdata.Leaf):
            children['right-router'] = child_right_router.val
    child_right_interface = n.children.get('right-interface')
    if child_right_interface is not None:
        if isinstance(child_right_interface, yang.gdata.Leaf):
            children['right-interface'] = child_right_interface.val
    return children

mut def to_json_netinfra__netinfra__backbone_link(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_netinfra__netinfra__backbone_link_element(e))
    return elements

class netinfra__netinfra(yang.adata.MNode):
    router: netinfra__netinfra__router
    backbone_link: netinfra__netinfra__backbone_link

    mut def __init__(self, router: list[netinfra__netinfra__router_entry]=[], backbone_link: list[netinfra__netinfra__backbone_link_entry]=[]):
        self._ns = "http://example.com/netinfra"
        self.router = netinfra__netinfra__router(elements=router)
        self.router._parent = self
        self.backbone_link = netinfra__netinfra__backbone_link(elements=backbone_link)
        self.backbone_link._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _router = self.router
        _backbone_link = self.backbone_link
        if _router is not None:
            children['router'] = _router.to_gdata()
        if _backbone_link is not None:
            children['backbone-link'] = _backbone_link.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/netinfra')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> netinfra__netinfra:
        if n != None:
            return netinfra__netinfra(router=netinfra__netinfra__router.from_gdata(n.get_opt_list("router")), backbone_link=netinfra__netinfra__backbone_link.from_gdata(n.get_opt_list("backbone-link")))
        return netinfra__netinfra()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> netinfra__netinfra:
        if n != None:
            return netinfra__netinfra(router=netinfra__netinfra__router.from_xml(yang.gdata.get_xml_children(n, "router")), backbone_link=netinfra__netinfra__backbone_link.from_xml(yang.gdata.get_xml_children(n, "backbone-link")))
        return netinfra__netinfra()


mut def from_json_path_netinfra__netinfra(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'netinfra:router' or point == 'router':
            child = {'router': from_json_path_netinfra__netinfra__router(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'netinfra:backbone-link' or point == 'backbone-link':
            child = {'backbone-link': from_json_path_netinfra__netinfra__backbone_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_netinfra__netinfra(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_netinfra__netinfra(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_router_full = jd.get('netinfra:router')
    child_router = child_router_full if child_router_full is not None else jd.get('router')
    if child_router is not None and isinstance(child_router, list):
        children['router'] = from_json_netinfra__netinfra__router(child_router)
    child_backbone_link_full = jd.get('netinfra:backbone-link')
    child_backbone_link = child_backbone_link_full if child_backbone_link_full is not None else jd.get('backbone-link')
    if child_backbone_link is not None and isinstance(child_backbone_link, list):
        children['backbone-link'] = from_json_netinfra__netinfra__backbone_link(child_backbone_link)
    return yang.gdata.Container(children)

mut def to_json_netinfra__netinfra(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_router = n.children.get('router')
    if child_router is not None:
        if isinstance(child_router, yang.gdata.List):
            children['router'] = to_json_netinfra__netinfra__router(child_router)
    child_backbone_link = n.children.get('backbone-link')
    if child_backbone_link is not None:
        if isinstance(child_backbone_link, yang.gdata.List):
            children['backbone-link'] = to_json_netinfra__netinfra__backbone_link(child_backbone_link)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id=n.get_str("id"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id=yang.gdata.from_xml_str(n, "id"))

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'cloud-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_id_full = jd.get('l3vpn-svc:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(child_id)
    return yang.gdata.ListElement([str(child_id if child_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(e))
    return elements

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id=n.get_str("id"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id=yang.gdata.from_xml_str(n, "id"))

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'encryption-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_id_full = jd.get('l3vpn-svc:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(child_id)
    return yang.gdata.ListElement([str(child_id if child_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(e))
    return elements

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id=n.get_str("id"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id=yang.gdata.from_xml_str(n, "id"))

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'qos-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_id_full = jd.get('l3vpn-svc:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(child_id)
    return yang.gdata.ListElement([str(child_id if child_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(e))
    return elements

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id=n.get_str("id"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id=yang.gdata.from_xml_str(n, "id"))

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'bfd-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_id_full = jd.get('l3vpn-svc:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(child_id)
    return yang.gdata.ListElement([str(child_id if child_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(yang.adata.MNode):
    cloud_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier
    encryption_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier
    qos_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier
    bfd_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier

    mut def __init__(self, cloud_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]=[], encryption_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]=[], qos_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]=[], bfd_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.cloud_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(elements=cloud_identifier)
        self.cloud_identifier._parent = self
        self.encryption_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(elements=encryption_profile_identifier)
        self.encryption_profile_identifier._parent = self
        self.qos_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(elements=qos_profile_identifier)
        self.qos_profile_identifier._parent = self
        self.bfd_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(elements=bfd_profile_identifier)
        self.bfd_profile_identifier._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_identifier = self.cloud_identifier
        _encryption_profile_identifier = self.encryption_profile_identifier
        _qos_profile_identifier = self.qos_profile_identifier
        _bfd_profile_identifier = self.bfd_profile_identifier
        if _cloud_identifier is not None:
            children['cloud-identifier'] = _cloud_identifier.to_gdata()
        if _encryption_profile_identifier is not None:
            children['encryption-profile-identifier'] = _encryption_profile_identifier.to_gdata()
        if _qos_profile_identifier is not None:
            children['qos-profile-identifier'] = _qos_profile_identifier.to_gdata()
        if _bfd_profile_identifier is not None:
            children['bfd-profile-identifier'] = _bfd_profile_identifier.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(cloud_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier.from_gdata(n.get_opt_list("cloud-identifier")), encryption_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier.from_gdata(n.get_opt_list("encryption-profile-identifier")), qos_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier.from_gdata(n.get_opt_list("qos-profile-identifier")), bfd_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier.from_gdata(n.get_opt_list("bfd-profile-identifier")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(cloud_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier.from_xml(yang.gdata.get_xml_children(n, "cloud-identifier")), encryption_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier.from_xml(yang.gdata.get_xml_children(n, "encryption-profile-identifier")), qos_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier.from_xml(yang.gdata.get_xml_children(n, "qos-profile-identifier")), bfd_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier.from_xml(yang.gdata.get_xml_children(n, "bfd-profile-identifier")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:cloud-identifier' or point == 'cloud-identifier':
            child = {'cloud-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:encryption-profile-identifier' or point == 'encryption-profile-identifier':
            child = {'encryption-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:qos-profile-identifier' or point == 'qos-profile-identifier':
            child = {'qos-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:bfd-profile-identifier' or point == 'bfd-profile-identifier':
            child = {'bfd-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cloud_identifier_full = jd.get('l3vpn-svc:cloud-identifier')
    child_cloud_identifier = child_cloud_identifier_full if child_cloud_identifier_full is not None else jd.get('cloud-identifier')
    if child_cloud_identifier is not None and isinstance(child_cloud_identifier, list):
        children['cloud-identifier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(child_cloud_identifier)
    child_encryption_profile_identifier_full = jd.get('l3vpn-svc:encryption-profile-identifier')
    child_encryption_profile_identifier = child_encryption_profile_identifier_full if child_encryption_profile_identifier_full is not None else jd.get('encryption-profile-identifier')
    if child_encryption_profile_identifier is not None and isinstance(child_encryption_profile_identifier, list):
        children['encryption-profile-identifier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(child_encryption_profile_identifier)
    child_qos_profile_identifier_full = jd.get('l3vpn-svc:qos-profile-identifier')
    child_qos_profile_identifier = child_qos_profile_identifier_full if child_qos_profile_identifier_full is not None else jd.get('qos-profile-identifier')
    if child_qos_profile_identifier is not None and isinstance(child_qos_profile_identifier, list):
        children['qos-profile-identifier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(child_qos_profile_identifier)
    child_bfd_profile_identifier_full = jd.get('l3vpn-svc:bfd-profile-identifier')
    child_bfd_profile_identifier = child_bfd_profile_identifier_full if child_bfd_profile_identifier_full is not None else jd.get('bfd-profile-identifier')
    if child_bfd_profile_identifier is not None and isinstance(child_bfd_profile_identifier, list):
        children['bfd-profile-identifier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(child_bfd_profile_identifier)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_cloud_identifier = n.children.get('cloud-identifier')
    if child_cloud_identifier is not None:
        if isinstance(child_cloud_identifier, yang.gdata.List):
            children['cloud-identifier'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(child_cloud_identifier)
    child_encryption_profile_identifier = n.children.get('encryption-profile-identifier')
    if child_encryption_profile_identifier is not None:
        if isinstance(child_encryption_profile_identifier, yang.gdata.List):
            children['encryption-profile-identifier'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(child_encryption_profile_identifier)
    child_qos_profile_identifier = n.children.get('qos-profile-identifier')
    if child_qos_profile_identifier is not None:
        if isinstance(child_qos_profile_identifier, yang.gdata.List):
            children['qos-profile-identifier'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(child_qos_profile_identifier)
    child_bfd_profile_identifier = n.children.get('bfd-profile-identifier')
    if child_bfd_profile_identifier is not None:
        if isinstance(child_bfd_profile_identifier, yang.gdata.List):
            children['bfd-profile-identifier'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(child_bfd_profile_identifier)
    return children

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(yang.adata.MNode):
    valid_provider_identifiers: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers

    mut def __init__(self, valid_provider_identifiers: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if valid_provider_identifiers is not None:
            self.valid_provider_identifiers = valid_provider_identifiers
        else:
            self.valid_provider_identifiers = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()
        self_valid_provider_identifiers = self.valid_provider_identifiers
        if self_valid_provider_identifiers is not None:
            self_valid_provider_identifiers._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _valid_provider_identifiers = self.valid_provider_identifiers
        if _valid_provider_identifiers is not None:
            children['valid-provider-identifiers'] = _valid_provider_identifiers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(valid_provider_identifiers=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers.from_gdata(n.get_opt_container("valid-provider-identifiers")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(valid_provider_identifiers=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers.from_xml(yang.gdata.get_xml_opt_child(n, "valid-provider-identifiers")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:valid-provider-identifiers' or point == 'valid-provider-identifiers':
            child = {'valid-provider-identifiers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_valid_provider_identifiers_full = jd.get('l3vpn-svc:valid-provider-identifiers')
    child_valid_provider_identifiers = child_valid_provider_identifiers_full if child_valid_provider_identifiers_full is not None else jd.get('valid-provider-identifiers')
    if child_valid_provider_identifiers is not None and isinstance(child_valid_provider_identifiers, dict):
        children['valid-provider-identifiers'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(child_valid_provider_identifiers)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_valid_provider_identifiers = n.children.get('valid-provider-identifiers')
    if child_valid_provider_identifiers is not None:
        if isinstance(child_valid_provider_identifiers, yang.gdata.Container):
            children['valid-provider-identifiers'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(child_valid_provider_identifiers)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(yang.adata.MNode):
    enabled: ?bool
    nat44_customer_address: ?str

    mut def __init__(self, enabled: ?bool, nat44_customer_address: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.enabled = enabled
        self.nat44_customer_address = nat44_customer_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        _nat44_customer_address = self.nat44_customer_address
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        if _nat44_customer_address is not None:
            children['nat44-customer-address'] = yang.gdata.Leaf('string', _nat44_customer_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(enabled=n.get_opt_bool("enabled"), nat44_customer_address=n.get_opt_str("nat44-customer-address"))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(enabled=yang.gdata.from_xml_opt_bool(n, "enabled"), nat44_customer_address=yang.gdata.from_xml_opt_str(n, "nat44-customer-address"))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:enabled' or point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:nat44-customer-address' or point == 'nat44-customer-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled_full = jd.get('l3vpn-svc:enabled')
    child_enabled = child_enabled_full if child_enabled_full is not None else jd.get('enabled')
    if child_enabled is not None:
        children['enabled'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled(child_enabled)
    child_nat44_customer_address_full = jd.get('l3vpn-svc:nat44-customer-address')
    child_nat44_customer_address = child_nat44_customer_address_full if child_nat44_customer_address_full is not None else jd.get('nat44-customer-address')
    if child_nat44_customer_address is not None:
        children['nat44-customer-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address(child_nat44_customer_address)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_enabled = n.children.get('enabled')
    if child_enabled is not None:
        if isinstance(child_enabled, yang.gdata.Leaf):
            children['enabled'] = child_enabled.val
    child_nat44_customer_address = n.children.get('nat44-customer-address')
    if child_nat44_customer_address is not None:
        if isinstance(child_nat44_customer_address, yang.gdata.Leaf):
            children['nat44-customer-address'] = child_nat44_customer_address.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(yang.adata.MNode):
    nat44: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44

    mut def __init__(self, nat44: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if nat44 is not None:
            self.nat44 = nat44
        else:
            self.nat44 = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()
        self_nat44 = self.nat44
        if self_nat44 is not None:
            self_nat44._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _nat44 = self.nat44
        if _nat44 is not None:
            children['nat44'] = _nat44.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(nat44=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44.from_gdata(n.get_opt_container("nat44")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(nat44=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44.from_xml(yang.gdata.get_xml_opt_child(n, "nat44")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:nat44' or point == 'nat44':
            child = {'nat44': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_nat44_full = jd.get('l3vpn-svc:nat44')
    child_nat44 = child_nat44_full if child_nat44_full is not None else jd.get('nat44')
    if child_nat44 is not None and isinstance(child_nat44, dict):
        children['nat44'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(child_nat44)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_nat44 = n.children.get('nat44')
    if child_nat44 is not None:
        if isinstance(child_nat44, yang.gdata.Container):
            children['nat44'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(child_nat44)
    return children

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(yang.adata.MNode):
    cloud_identifier: str
    permit_any: ?bool
    permit_site: list[str]
    deny_site: list[str]
    address_translation: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation

    mut def __init__(self, cloud_identifier: str, permit_any: ?bool, permit_site: ?list[str]=None, deny_site: ?list[str]=None, address_translation: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.cloud_identifier = cloud_identifier
        self.permit_any = permit_any
        if permit_site is not None:
            self.permit_site = permit_site
        else:
            self.permit_site = []
        if deny_site is not None:
            self.deny_site = deny_site
        else:
            self.deny_site = []
        if address_translation is not None:
            self.address_translation = address_translation
        else:
            self.address_translation = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()
        self_address_translation = self.address_translation
        if self_address_translation is not None:
            self_address_translation._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_identifier = self.cloud_identifier
        _permit_any = self.permit_any
        _address_translation = self.address_translation
        if _cloud_identifier is not None:
            children['cloud-identifier'] = yang.gdata.Leaf('leafref', _cloud_identifier)
        if _permit_any is not None:
            children['permit-any'] = yang.gdata.Leaf('empty', _permit_any)
        children['permit-site'] = yang.gdata.LeafList(self.permit_site)
        children['deny-site'] = yang.gdata.LeafList(self.deny_site)
        if _address_translation is not None:
            children['address-translation'] = _address_translation.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.cloud_identifier)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier=n.get_str("cloud-identifier"), permit_any=n.get_opt_bool("permit-any"), permit_site=n.get_opt_strs("permit-site"), deny_site=n.get_opt_strs("deny-site"), address_translation=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation.from_gdata(n.get_opt_container("address-translation")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier=yang.gdata.from_xml_str(n, "cloud-identifier"), permit_any=yang.gdata.from_xml_opt_bool(n, "permit-any"), permit_site=yang.gdata.from_xml_opt_strs(n, "permit-site"), deny_site=yang.gdata.from_xml_opt_strs(n, "deny-site"), address_translation=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation.from_xml(yang.gdata.get_xml_opt_child(n, "address-translation")))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'cloud-access'
        self.elements = elements

    mut def create(self, cloud_identifier):
        for e in self.elements:
            match = True
            if e.cloud_identifier != cloud_identifier:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['cloud-identifier'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['cloud-identifier']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'permit-any':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'permit-site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'deny-site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-translation':
            children['address-translation'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['cloud-identifier']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['cloud-identifier'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['cloud-identifier'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_cloud_identifier_full = jd.get('l3vpn-svc:cloud-identifier')
    child_cloud_identifier = child_cloud_identifier_full if child_cloud_identifier_full is not None else jd.get('cloud-identifier')
    if child_cloud_identifier is not None:
        children['cloud-identifier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(child_cloud_identifier)
    child_permit_any_full = jd.get('l3vpn-svc:permit-any')
    child_permit_any = child_permit_any_full if child_permit_any_full is not None else jd.get('permit-any')
    if child_permit_any is not None:
        children['permit-any'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any(child_permit_any)
    child_permit_site_full = jd.get('l3vpn-svc:permit-site')
    child_permit_site = child_permit_site_full if child_permit_site_full is not None else jd.get('permit-site')
    if child_permit_site is not None and isinstance(child_permit_site, list):
        children['permit-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site(child_permit_site)
    child_deny_site_full = jd.get('l3vpn-svc:deny-site')
    child_deny_site = child_deny_site_full if child_deny_site_full is not None else jd.get('deny-site')
    if child_deny_site is not None and isinstance(child_deny_site, list):
        children['deny-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site(child_deny_site)
    child_address_translation_full = jd.get('l3vpn-svc:address-translation')
    child_address_translation = child_address_translation_full if child_address_translation_full is not None else jd.get('address-translation')
    if child_address_translation is not None and isinstance(child_address_translation, dict):
        children['address-translation'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(child_address_translation)
    return yang.gdata.ListElement([str(child_cloud_identifier if child_cloud_identifier is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(e))
    return yang.gdata.List(keys=['cloud-identifier'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_cloud_identifier = n.children.get('cloud-identifier')
    if child_cloud_identifier is not None:
        if isinstance(child_cloud_identifier, yang.gdata.Leaf):
            children['cloud-identifier'] = child_cloud_identifier.val
    child_permit_any = n.children.get('permit-any')
    if child_permit_any is not None:
        if isinstance(child_permit_any, yang.gdata.Leaf):
            children['permit-any'] = child_permit_any.val
    child_permit_site = n.children.get('permit-site')
    if child_permit_site is not None:
        if isinstance(child_permit_site, yang.gdata.LeafList):
            children['permit-site'] = child_permit_site.vals
    child_deny_site = n.children.get('deny-site')
    if child_deny_site is not None:
        if isinstance(child_deny_site, yang.gdata.LeafList):
            children['deny-site'] = child_deny_site.vals
    child_address_translation = n.children.get('address-translation')
    if child_address_translation is not None:
        if isinstance(child_address_translation, yang.gdata.Container):
            children['address-translation'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(child_address_translation)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(yang.adata.MNode):
    cloud_access: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access

    mut def __init__(self, cloud_access: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.cloud_access = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(elements=cloud_access)
        self.cloud_access._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_access = self.cloud_access
        if _cloud_access is not None:
            children['cloud-access'] = _cloud_access.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(cloud_access=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access.from_gdata(n.get_opt_list("cloud-access")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(cloud_access=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access.from_xml(yang.gdata.get_xml_children(n, "cloud-access")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:cloud-access' or point == 'cloud-access':
            child = {'cloud-access': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cloud_access_full = jd.get('l3vpn-svc:cloud-access')
    child_cloud_access = child_cloud_access_full if child_cloud_access_full is not None else jd.get('cloud-access')
    if child_cloud_access is not None and isinstance(child_cloud_access, list):
        children['cloud-access'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(child_cloud_access)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_cloud_access = n.children.get('cloud-access')
    if child_cloud_access is not None:
        if isinstance(child_cloud_access, yang.gdata.List):
            children['cloud-access'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(child_cloud_access)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(yang.adata.MNode):
    tree_flavor: list[str]

    mut def __init__(self, tree_flavor: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if tree_flavor is not None:
            self.tree_flavor = tree_flavor
        else:
            self.tree_flavor = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['tree-flavor'] = yang.gdata.LeafList(self.tree_flavor)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(tree_flavor=n.get_opt_strs("tree-flavor"))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(tree_flavor=yang.gdata.from_xml_opt_strs(n, "tree-flavor"))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:tree-flavor' or point == 'tree-flavor':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_tree_flavor_full = jd.get('l3vpn-svc:tree-flavor')
    child_tree_flavor = child_tree_flavor_full if child_tree_flavor_full is not None else jd.get('tree-flavor')
    if child_tree_flavor is not None and isinstance(child_tree_flavor, list):
        children['tree-flavor'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor(child_tree_flavor)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_tree_flavor = n.children.get('tree-flavor')
    if child_tree_flavor is not None:
        if isinstance(child_tree_flavor, yang.gdata.LeafList):
            children['tree-flavor'] = child_tree_flavor.vals
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(yang.adata.MNode):
    enabled: ?bool
    rp_redundancy: ?bool
    optimal_traffic_delivery: ?bool

    mut def __init__(self, enabled: ?bool, rp_redundancy: ?bool, optimal_traffic_delivery: ?bool):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.enabled = enabled
        self.rp_redundancy = rp_redundancy
        self.optimal_traffic_delivery = optimal_traffic_delivery

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        _rp_redundancy = self.rp_redundancy
        _optimal_traffic_delivery = self.optimal_traffic_delivery
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        if _rp_redundancy is not None:
            children['rp-redundancy'] = yang.gdata.Leaf('boolean', _rp_redundancy)
        if _optimal_traffic_delivery is not None:
            children['optimal-traffic-delivery'] = yang.gdata.Leaf('boolean', _optimal_traffic_delivery)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(enabled=n.get_opt_bool("enabled"), rp_redundancy=n.get_opt_bool("rp-redundancy"), optimal_traffic_delivery=n.get_opt_bool("optimal-traffic-delivery"))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(enabled=yang.gdata.from_xml_opt_bool(n, "enabled"), rp_redundancy=yang.gdata.from_xml_opt_bool(n, "rp-redundancy"), optimal_traffic_delivery=yang.gdata.from_xml_opt_bool(n, "optimal-traffic-delivery"))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:enabled' or point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:rp-redundancy' or point == 'rp-redundancy':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:optimal-traffic-delivery' or point == 'optimal-traffic-delivery':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled_full = jd.get('l3vpn-svc:enabled')
    child_enabled = child_enabled_full if child_enabled_full is not None else jd.get('enabled')
    if child_enabled is not None:
        children['enabled'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled(child_enabled)
    child_rp_redundancy_full = jd.get('l3vpn-svc:rp-redundancy')
    child_rp_redundancy = child_rp_redundancy_full if child_rp_redundancy_full is not None else jd.get('rp-redundancy')
    if child_rp_redundancy is not None:
        children['rp-redundancy'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy(child_rp_redundancy)
    child_optimal_traffic_delivery_full = jd.get('l3vpn-svc:optimal-traffic-delivery')
    child_optimal_traffic_delivery = child_optimal_traffic_delivery_full if child_optimal_traffic_delivery_full is not None else jd.get('optimal-traffic-delivery')
    if child_optimal_traffic_delivery is not None:
        children['optimal-traffic-delivery'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery(child_optimal_traffic_delivery)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_enabled = n.children.get('enabled')
    if child_enabled is not None:
        if isinstance(child_enabled, yang.gdata.Leaf):
            children['enabled'] = child_enabled.val
    child_rp_redundancy = n.children.get('rp-redundancy')
    if child_rp_redundancy is not None:
        if isinstance(child_rp_redundancy, yang.gdata.Leaf):
            children['rp-redundancy'] = child_rp_redundancy.val
    child_optimal_traffic_delivery = n.children.get('optimal-traffic-delivery')
    if child_optimal_traffic_delivery is not None:
        if isinstance(child_optimal_traffic_delivery, yang.gdata.Leaf):
            children['optimal-traffic-delivery'] = child_optimal_traffic_delivery.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("union", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("union", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("union", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("union", val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(yang.adata.MNode):
    id: int
    group_address: ?str
    group_start: ?str
    group_end: ?str

    mut def __init__(self, id: int, group_address: ?str, group_start: ?str, group_end: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.id = id
        self.group_address = group_address
        self.group_start = group_start
        self.group_end = group_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        _group_address = self.group_address
        _group_start = self.group_start
        _group_end = self.group_end
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint16', _id)
        if _group_address is not None:
            children['group-address'] = yang.gdata.Leaf('union', _group_address)
        if _group_start is not None:
            children['group-start'] = yang.gdata.Leaf('union', _group_start)
        if _group_end is not None:
            children['group-end'] = yang.gdata.Leaf('union', _group_end)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id=n.get_int("id"), group_address=n.get_opt_str("group-address"), group_start=n.get_opt_str("group-start"), group_end=n.get_opt_str("group-end"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id=yang.gdata.from_xml_int(n, "id"), group_address=yang.gdata.from_xml_opt_str(n, "group-address"), group_start=yang.gdata.from_xml_opt_str(n, "group-start"), group_end=yang.gdata.from_xml_opt_str(n, "group-end"))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'group'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'group-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'group-start':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'group-end':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_id_full = jd.get('l3vpn-svc:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(child_id)
    child_group_address_full = jd.get('l3vpn-svc:group-address')
    child_group_address = child_group_address_full if child_group_address_full is not None else jd.get('group-address')
    if child_group_address is not None:
        children['group-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address(child_group_address)
    child_group_start_full = jd.get('l3vpn-svc:group-start')
    child_group_start = child_group_start_full if child_group_start_full is not None else jd.get('group-start')
    if child_group_start is not None:
        children['group-start'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start(child_group_start)
    child_group_end_full = jd.get('l3vpn-svc:group-end')
    child_group_end = child_group_end_full if child_group_end_full is not None else jd.get('group-end')
    if child_group_end is not None:
        children['group-end'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end(child_group_end)
    return yang.gdata.ListElement([str(child_id if child_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    child_group_address = n.children.get('group-address')
    if child_group_address is not None:
        if isinstance(child_group_address, yang.gdata.Leaf):
            children['group-address'] = child_group_address.val
    child_group_start = n.children.get('group-start')
    if child_group_start is not None:
        if isinstance(child_group_start, yang.gdata.Leaf):
            children['group-start'] = child_group_start.val
    child_group_end = n.children.get('group-end')
    if child_group_end is not None:
        if isinstance(child_group_end, yang.gdata.Leaf):
            children['group-end'] = child_group_end.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.group = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(elements=group)
        self.group._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(group=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group.from_gdata(n.get_opt_list("group")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(group=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group.from_xml(yang.gdata.get_xml_children(n, "group")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:group' or point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group_full = jd.get('l3vpn-svc:group')
    child_group = child_group_full if child_group_full is not None else jd.get('group')
    if child_group is not None and isinstance(child_group, list):
        children['group'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(child_group)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_group = n.children.get('group')
    if child_group is not None:
        if isinstance(child_group, yang.gdata.List):
            children['group'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(child_group)
    return children

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(yang.adata.MNode):
    id: int
    provider_managed: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed
    rp_address: ?str
    groups: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups

    mut def __init__(self, id: int, provider_managed: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed=None, rp_address: ?str, groups: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.id = id
        if provider_managed is not None:
            self.provider_managed = provider_managed
        else:
            self.provider_managed = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()
        self_provider_managed = self.provider_managed
        if self_provider_managed is not None:
            self_provider_managed._parent = self
        self.rp_address = rp_address
        if groups is not None:
            self.groups = groups
        else:
            self.groups = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()
        self_groups = self.groups
        if self_groups is not None:
            self_groups._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        _provider_managed = self.provider_managed
        _rp_address = self.rp_address
        _groups = self.groups
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint16', _id)
        if _provider_managed is not None:
            children['provider-managed'] = _provider_managed.to_gdata()
        if _rp_address is not None:
            children['rp-address'] = yang.gdata.Leaf('union', _rp_address)
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id=n.get_int("id"), provider_managed=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed.from_gdata(n.get_opt_container("provider-managed")), rp_address=n.get_opt_str("rp-address"), groups=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups.from_gdata(n.get_opt_container("groups")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id=yang.gdata.from_xml_int(n, "id"), provider_managed=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed.from_xml(yang.gdata.get_xml_opt_child(n, "provider-managed")), rp_address=yang.gdata.from_xml_opt_str(n, "rp-address"), groups=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups.from_xml(yang.gdata.get_xml_opt_child(n, "groups")))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'rp-group-mapping'
        self.elements = elements

    mut def create(self, id, rp_address):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id, rp_address)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'provider-managed':
            children['provider-managed'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd, rest_path, op)
        if point == 'rp-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'groups':
            children['groups'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_id_full = jd.get('l3vpn-svc:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(child_id)
    child_provider_managed_full = jd.get('l3vpn-svc:provider-managed')
    child_provider_managed = child_provider_managed_full if child_provider_managed_full is not None else jd.get('provider-managed')
    if child_provider_managed is not None and isinstance(child_provider_managed, dict):
        children['provider-managed'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(child_provider_managed)
    child_rp_address_full = jd.get('l3vpn-svc:rp-address')
    child_rp_address = child_rp_address_full if child_rp_address_full is not None else jd.get('rp-address')
    if child_rp_address is not None:
        children['rp-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address(child_rp_address)
    child_groups_full = jd.get('l3vpn-svc:groups')
    child_groups = child_groups_full if child_groups_full is not None else jd.get('groups')
    if child_groups is not None and isinstance(child_groups, dict):
        children['groups'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(child_groups)
    return yang.gdata.ListElement([str(child_id if child_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    child_provider_managed = n.children.get('provider-managed')
    if child_provider_managed is not None:
        if isinstance(child_provider_managed, yang.gdata.Container):
            children['provider-managed'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(child_provider_managed)
    child_rp_address = n.children.get('rp-address')
    if child_rp_address is not None:
        if isinstance(child_rp_address, yang.gdata.Leaf):
            children['rp-address'] = child_rp_address.val
    child_groups = n.children.get('groups')
    if child_groups is not None:
        if isinstance(child_groups, yang.gdata.Container):
            children['groups'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(child_groups)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(yang.adata.MNode):
    rp_group_mapping: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping

    mut def __init__(self, rp_group_mapping: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.rp_group_mapping = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(elements=rp_group_mapping)
        self.rp_group_mapping._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_group_mapping = self.rp_group_mapping
        if _rp_group_mapping is not None:
            children['rp-group-mapping'] = _rp_group_mapping.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(rp_group_mapping=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping.from_gdata(n.get_opt_list("rp-group-mapping")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(rp_group_mapping=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping.from_xml(yang.gdata.get_xml_children(n, "rp-group-mapping")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:rp-group-mapping' or point == 'rp-group-mapping':
            child = {'rp-group-mapping': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_group_mapping_full = jd.get('l3vpn-svc:rp-group-mapping')
    child_rp_group_mapping = child_rp_group_mapping_full if child_rp_group_mapping_full is not None else jd.get('rp-group-mapping')
    if child_rp_group_mapping is not None and isinstance(child_rp_group_mapping, list):
        children['rp-group-mapping'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(child_rp_group_mapping)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_rp_group_mapping = n.children.get('rp-group-mapping')
    if child_rp_group_mapping is not None:
        if isinstance(child_rp_group_mapping, yang.gdata.List):
            children['rp-group-mapping'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(child_rp_group_mapping)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(yang.adata.MNode):
    bsr_candidate_address: list[str]

    mut def __init__(self, bsr_candidate_address: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if bsr_candidate_address is not None:
            self.bsr_candidate_address = bsr_candidate_address
        else:
            self.bsr_candidate_address = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['bsr-candidate-address'] = yang.gdata.LeafList(self.bsr_candidate_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(bsr_candidate_address=n.get_opt_strs("bsr-candidate-address"))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(bsr_candidate_address=yang.gdata.from_xml_opt_strs(n, "bsr-candidate-address"))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:bsr-candidate-address' or point == 'bsr-candidate-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_bsr_candidate_address_full = jd.get('l3vpn-svc:bsr-candidate-address')
    child_bsr_candidate_address = child_bsr_candidate_address_full if child_bsr_candidate_address_full is not None else jd.get('bsr-candidate-address')
    if child_bsr_candidate_address is not None and isinstance(child_bsr_candidate_address, list):
        children['bsr-candidate-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address(child_bsr_candidate_address)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_bsr_candidate_address = n.children.get('bsr-candidate-address')
    if child_bsr_candidate_address is not None:
        if isinstance(child_bsr_candidate_address, yang.gdata.LeafList):
            children['bsr-candidate-address'] = child_bsr_candidate_address.vals
    return children

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(yang.adata.MNode):
    rp_discovery_type: ?str
    bsr_candidates: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates

    mut def __init__(self, rp_discovery_type: ?str, bsr_candidates: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.rp_discovery_type = rp_discovery_type
        if bsr_candidates is not None:
            self.bsr_candidates = bsr_candidates
        else:
            self.bsr_candidates = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()
        self_bsr_candidates = self.bsr_candidates
        if self_bsr_candidates is not None:
            self_bsr_candidates._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_discovery_type = self.rp_discovery_type
        _bsr_candidates = self.bsr_candidates
        if _rp_discovery_type is not None:
            children['rp-discovery-type'] = yang.gdata.Leaf('identityref', _rp_discovery_type)
        if _bsr_candidates is not None:
            children['bsr-candidates'] = _bsr_candidates.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(rp_discovery_type=n.get_opt_str("rp-discovery-type"), bsr_candidates=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates.from_gdata(n.get_opt_container("bsr-candidates")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(rp_discovery_type=yang.gdata.from_xml_opt_str(n, "rp-discovery-type"), bsr_candidates=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates.from_xml(yang.gdata.get_xml_opt_child(n, "bsr-candidates")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:rp-discovery-type' or point == 'rp-discovery-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:bsr-candidates' or point == 'bsr-candidates':
            child = {'bsr-candidates': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_discovery_type_full = jd.get('l3vpn-svc:rp-discovery-type')
    child_rp_discovery_type = child_rp_discovery_type_full if child_rp_discovery_type_full is not None else jd.get('rp-discovery-type')
    if child_rp_discovery_type is not None:
        children['rp-discovery-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type(child_rp_discovery_type)
    child_bsr_candidates_full = jd.get('l3vpn-svc:bsr-candidates')
    child_bsr_candidates = child_bsr_candidates_full if child_bsr_candidates_full is not None else jd.get('bsr-candidates')
    if child_bsr_candidates is not None and isinstance(child_bsr_candidates, dict):
        children['bsr-candidates'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(child_bsr_candidates)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_rp_discovery_type = n.children.get('rp-discovery-type')
    if child_rp_discovery_type is not None:
        if isinstance(child_rp_discovery_type, yang.gdata.Leaf):
            children['rp-discovery-type'] = child_rp_discovery_type.val
    child_bsr_candidates = n.children.get('bsr-candidates')
    if child_bsr_candidates is not None:
        if isinstance(child_bsr_candidates, yang.gdata.Container):
            children['bsr-candidates'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(child_bsr_candidates)
    return children

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(yang.adata.MNode):
    rp_group_mappings: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings
    rp_discovery: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery

    mut def __init__(self, rp_group_mappings: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings=None, rp_discovery: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if rp_group_mappings is not None:
            self.rp_group_mappings = rp_group_mappings
        else:
            self.rp_group_mappings = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()
        self_rp_group_mappings = self.rp_group_mappings
        if self_rp_group_mappings is not None:
            self_rp_group_mappings._parent = self
        if rp_discovery is not None:
            self.rp_discovery = rp_discovery
        else:
            self.rp_discovery = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()
        self_rp_discovery = self.rp_discovery
        if self_rp_discovery is not None:
            self_rp_discovery._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_group_mappings = self.rp_group_mappings
        _rp_discovery = self.rp_discovery
        if _rp_group_mappings is not None:
            children['rp-group-mappings'] = _rp_group_mappings.to_gdata()
        if _rp_discovery is not None:
            children['rp-discovery'] = _rp_discovery.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(rp_group_mappings=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings.from_gdata(n.get_opt_container("rp-group-mappings")), rp_discovery=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery.from_gdata(n.get_opt_container("rp-discovery")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(rp_group_mappings=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings.from_xml(yang.gdata.get_xml_opt_child(n, "rp-group-mappings")), rp_discovery=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery.from_xml(yang.gdata.get_xml_opt_child(n, "rp-discovery")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:rp-group-mappings' or point == 'rp-group-mappings':
            child = {'rp-group-mappings': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:rp-discovery' or point == 'rp-discovery':
            child = {'rp-discovery': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_group_mappings_full = jd.get('l3vpn-svc:rp-group-mappings')
    child_rp_group_mappings = child_rp_group_mappings_full if child_rp_group_mappings_full is not None else jd.get('rp-group-mappings')
    if child_rp_group_mappings is not None and isinstance(child_rp_group_mappings, dict):
        children['rp-group-mappings'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(child_rp_group_mappings)
    child_rp_discovery_full = jd.get('l3vpn-svc:rp-discovery')
    child_rp_discovery = child_rp_discovery_full if child_rp_discovery_full is not None else jd.get('rp-discovery')
    if child_rp_discovery is not None and isinstance(child_rp_discovery, dict):
        children['rp-discovery'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(child_rp_discovery)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_rp_group_mappings = n.children.get('rp-group-mappings')
    if child_rp_group_mappings is not None:
        if isinstance(child_rp_group_mappings, yang.gdata.Container):
            children['rp-group-mappings'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(child_rp_group_mappings)
    child_rp_discovery = n.children.get('rp-discovery')
    if child_rp_discovery is not None:
        if isinstance(child_rp_discovery, yang.gdata.Container):
            children['rp-discovery'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(child_rp_discovery)
    return children

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(yang.adata.MNode):
    enabled: ?bool
    customer_tree_flavors: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors
    rp: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp

    mut def __init__(self, enabled: ?bool, customer_tree_flavors: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors=None, rp: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.enabled = enabled
        if customer_tree_flavors is not None:
            self.customer_tree_flavors = customer_tree_flavors
        else:
            self.customer_tree_flavors = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()
        self_customer_tree_flavors = self.customer_tree_flavors
        if self_customer_tree_flavors is not None:
            self_customer_tree_flavors._parent = self
        if rp is not None:
            self.rp = rp
        else:
            self.rp = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()
        self_rp = self.rp
        if self_rp is not None:
            self_rp._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        _customer_tree_flavors = self.customer_tree_flavors
        _rp = self.rp
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        if _customer_tree_flavors is not None:
            children['customer-tree-flavors'] = _customer_tree_flavors.to_gdata()
        if _rp is not None:
            children['rp'] = _rp.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(enabled=n.get_opt_bool("enabled"), customer_tree_flavors=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors.from_gdata(n.get_opt_container("customer-tree-flavors")), rp=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp.from_gdata(n.get_opt_container("rp")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(enabled=yang.gdata.from_xml_opt_bool(n, "enabled"), customer_tree_flavors=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors.from_xml(yang.gdata.get_xml_opt_child(n, "customer-tree-flavors")), rp=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp.from_xml(yang.gdata.get_xml_opt_child(n, "rp")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:enabled' or point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:customer-tree-flavors' or point == 'customer-tree-flavors':
            child = {'customer-tree-flavors': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:rp' or point == 'rp':
            child = {'rp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled_full = jd.get('l3vpn-svc:enabled')
    child_enabled = child_enabled_full if child_enabled_full is not None else jd.get('enabled')
    if child_enabled is not None:
        children['enabled'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled(child_enabled)
    child_customer_tree_flavors_full = jd.get('l3vpn-svc:customer-tree-flavors')
    child_customer_tree_flavors = child_customer_tree_flavors_full if child_customer_tree_flavors_full is not None else jd.get('customer-tree-flavors')
    if child_customer_tree_flavors is not None and isinstance(child_customer_tree_flavors, dict):
        children['customer-tree-flavors'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(child_customer_tree_flavors)
    child_rp_full = jd.get('l3vpn-svc:rp')
    child_rp = child_rp_full if child_rp_full is not None else jd.get('rp')
    if child_rp is not None and isinstance(child_rp, dict):
        children['rp'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(child_rp)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_enabled = n.children.get('enabled')
    if child_enabled is not None:
        if isinstance(child_enabled, yang.gdata.Leaf):
            children['enabled'] = child_enabled.val
    child_customer_tree_flavors = n.children.get('customer-tree-flavors')
    if child_customer_tree_flavors is not None:
        if isinstance(child_customer_tree_flavors, yang.gdata.Container):
            children['customer-tree-flavors'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(child_customer_tree_flavors)
    child_rp = n.children.get('rp')
    if child_rp is not None:
        if isinstance(child_rp, yang.gdata.Container):
            children['rp'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(child_rp)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(yang.adata.MNode):
    vpn_id: str
    local_sites_role: ?str

    mut def __init__(self, vpn_id: str, local_sites_role: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.vpn_id = vpn_id
        self.local_sites_role = local_sites_role

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        _local_sites_role = self.local_sites_role
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        if _local_sites_role is not None:
            children['local-sites-role'] = yang.gdata.Leaf('identityref', _local_sites_role)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.vpn_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id=n.get_str("vpn-id"), local_sites_role=n.get_opt_str("local-sites-role"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id=yang.gdata.from_xml_str(n, "vpn-id"), local_sites_role=yang.gdata.from_xml_opt_str(n, "local-sites-role"))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'extranet-vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['vpn-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'local-sites-role':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_vpn_id_full = jd.get('l3vpn-svc:vpn-id')
    child_vpn_id = child_vpn_id_full if child_vpn_id_full is not None else jd.get('vpn-id')
    if child_vpn_id is not None:
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(child_vpn_id)
    child_local_sites_role_full = jd.get('l3vpn-svc:local-sites-role')
    child_local_sites_role = child_local_sites_role_full if child_local_sites_role_full is not None else jd.get('local-sites-role')
    if child_local_sites_role is not None:
        children['local-sites-role'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role(child_local_sites_role)
    return yang.gdata.ListElement([str(child_vpn_id if child_vpn_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(e))
    return yang.gdata.List(keys=['vpn-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_vpn_id = n.children.get('vpn-id')
    if child_vpn_id is not None:
        if isinstance(child_vpn_id, yang.gdata.Leaf):
            children['vpn-id'] = child_vpn_id.val
    child_local_sites_role = n.children.get('local-sites-role')
    if child_local_sites_role is not None:
        if isinstance(child_local_sites_role, yang.gdata.Leaf):
            children['local-sites-role'] = child_local_sites_role.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(yang.adata.MNode):
    extranet_vpn: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn

    mut def __init__(self, extranet_vpn: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.extranet_vpn = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(elements=extranet_vpn)
        self.extranet_vpn._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _extranet_vpn = self.extranet_vpn
        if _extranet_vpn is not None:
            children['extranet-vpn'] = _extranet_vpn.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(extranet_vpn=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn.from_gdata(n.get_opt_list("extranet-vpn")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(extranet_vpn=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn.from_xml(yang.gdata.get_xml_children(n, "extranet-vpn")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:extranet-vpn' or point == 'extranet-vpn':
            child = {'extranet-vpn': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_extranet_vpn_full = jd.get('l3vpn-svc:extranet-vpn')
    child_extranet_vpn = child_extranet_vpn_full if child_extranet_vpn_full is not None else jd.get('extranet-vpn')
    if child_extranet_vpn is not None and isinstance(child_extranet_vpn, list):
        children['extranet-vpn'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(child_extranet_vpn)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_extranet_vpn = n.children.get('extranet-vpn')
    if child_extranet_vpn is not None:
        if isinstance(child_extranet_vpn, yang.gdata.List):
            children['extranet-vpn'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(child_extranet_vpn)
    return children

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(yang.adata.MNode):
    vpn_id: str
    customer_name: ?str
    vpn_service_topology: ?str
    cloud_accesses: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses
    multicast: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast
    carrierscarrier: ?bool
    extranet_vpns: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns

    mut def __init__(self, vpn_id: str, customer_name: ?str, vpn_service_topology: ?str, cloud_accesses: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast=None, carrierscarrier: ?bool, extranet_vpns: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.vpn_id = vpn_id
        self.customer_name = customer_name
        self.vpn_service_topology = vpn_service_topology
        if cloud_accesses is not None:
            self.cloud_accesses = cloud_accesses
        else:
            self.cloud_accesses = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()
        self_cloud_accesses = self.cloud_accesses
        if self_cloud_accesses is not None:
            self_cloud_accesses._parent = self
        if multicast is not None:
            self.multicast = multicast
        else:
            self.multicast = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()
        self_multicast = self.multicast
        if self_multicast is not None:
            self_multicast._parent = self
        self.carrierscarrier = carrierscarrier
        if extranet_vpns is not None:
            self.extranet_vpns = extranet_vpns
        else:
            self.extranet_vpns = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()
        self_extranet_vpns = self.extranet_vpns
        if self_extranet_vpns is not None:
            self_extranet_vpns._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        _customer_name = self.customer_name
        _vpn_service_topology = self.vpn_service_topology
        _cloud_accesses = self.cloud_accesses
        _multicast = self.multicast
        _carrierscarrier = self.carrierscarrier
        _extranet_vpns = self.extranet_vpns
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        if _customer_name is not None:
            children['customer-name'] = yang.gdata.Leaf('string', _customer_name)
        if _vpn_service_topology is not None:
            children['vpn-service-topology'] = yang.gdata.Leaf('identityref', _vpn_service_topology)
        if _cloud_accesses is not None:
            children['cloud-accesses'] = _cloud_accesses.to_gdata()
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        if _carrierscarrier is not None:
            children['carrierscarrier'] = yang.gdata.Leaf('boolean', _carrierscarrier)
        if _extranet_vpns is not None:
            children['extranet-vpns'] = _extranet_vpns.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.vpn_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id=n.get_str("vpn-id"), customer_name=n.get_opt_str("customer-name"), vpn_service_topology=n.get_opt_str("vpn-service-topology"), cloud_accesses=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses.from_gdata(n.get_opt_container("cloud-accesses")), multicast=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast.from_gdata(n.get_opt_container("multicast")), carrierscarrier=n.get_opt_bool("carrierscarrier"), extranet_vpns=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns.from_gdata(n.get_opt_container("extranet-vpns")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id=yang.gdata.from_xml_str(n, "vpn-id"), customer_name=yang.gdata.from_xml_opt_str(n, "customer-name"), vpn_service_topology=yang.gdata.from_xml_opt_str(n, "vpn-service-topology"), cloud_accesses=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses.from_xml(yang.gdata.get_xml_opt_child(n, "cloud-accesses")), multicast=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast.from_xml(yang.gdata.get_xml_opt_child(n, "multicast")), carrierscarrier=yang.gdata.from_xml_opt_bool(n, "carrierscarrier"), extranet_vpns=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns.from_xml(yang.gdata.get_xml_opt_child(n, "extranet-vpns")))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'vpn-service'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['vpn-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'customer-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'vpn-service-topology':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'cloud-accesses':
            children['cloud-accesses'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd, rest_path, op)
        if point == 'multicast':
            children['multicast'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd, rest_path, op)
        if point == 'carrierscarrier':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'extranet-vpns':
            children['extranet-vpns'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_vpn_id_full = jd.get('l3vpn-svc:vpn-id')
    child_vpn_id = child_vpn_id_full if child_vpn_id_full is not None else jd.get('vpn-id')
    if child_vpn_id is not None:
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(child_vpn_id)
    child_customer_name_full = jd.get('l3vpn-svc:customer-name')
    child_customer_name = child_customer_name_full if child_customer_name_full is not None else jd.get('customer-name')
    if child_customer_name is not None:
        children['customer-name'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name(child_customer_name)
    child_vpn_service_topology_full = jd.get('l3vpn-svc:vpn-service-topology')
    child_vpn_service_topology = child_vpn_service_topology_full if child_vpn_service_topology_full is not None else jd.get('vpn-service-topology')
    if child_vpn_service_topology is not None:
        children['vpn-service-topology'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology(child_vpn_service_topology)
    child_cloud_accesses_full = jd.get('l3vpn-svc:cloud-accesses')
    child_cloud_accesses = child_cloud_accesses_full if child_cloud_accesses_full is not None else jd.get('cloud-accesses')
    if child_cloud_accesses is not None and isinstance(child_cloud_accesses, dict):
        children['cloud-accesses'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(child_cloud_accesses)
    child_multicast_full = jd.get('l3vpn-svc:multicast')
    child_multicast = child_multicast_full if child_multicast_full is not None else jd.get('multicast')
    if child_multicast is not None and isinstance(child_multicast, dict):
        children['multicast'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(child_multicast)
    child_carrierscarrier_full = jd.get('l3vpn-svc:carrierscarrier')
    child_carrierscarrier = child_carrierscarrier_full if child_carrierscarrier_full is not None else jd.get('carrierscarrier')
    if child_carrierscarrier is not None:
        children['carrierscarrier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier(child_carrierscarrier)
    child_extranet_vpns_full = jd.get('l3vpn-svc:extranet-vpns')
    child_extranet_vpns = child_extranet_vpns_full if child_extranet_vpns_full is not None else jd.get('extranet-vpns')
    if child_extranet_vpns is not None and isinstance(child_extranet_vpns, dict):
        children['extranet-vpns'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(child_extranet_vpns)
    return yang.gdata.ListElement([str(child_vpn_id if child_vpn_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(e))
    return yang.gdata.List(keys=['vpn-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_vpn_id = n.children.get('vpn-id')
    if child_vpn_id is not None:
        if isinstance(child_vpn_id, yang.gdata.Leaf):
            children['vpn-id'] = child_vpn_id.val
    child_customer_name = n.children.get('customer-name')
    if child_customer_name is not None:
        if isinstance(child_customer_name, yang.gdata.Leaf):
            children['customer-name'] = child_customer_name.val
    child_vpn_service_topology = n.children.get('vpn-service-topology')
    if child_vpn_service_topology is not None:
        if isinstance(child_vpn_service_topology, yang.gdata.Leaf):
            children['vpn-service-topology'] = child_vpn_service_topology.val
    child_cloud_accesses = n.children.get('cloud-accesses')
    if child_cloud_accesses is not None:
        if isinstance(child_cloud_accesses, yang.gdata.Container):
            children['cloud-accesses'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(child_cloud_accesses)
    child_multicast = n.children.get('multicast')
    if child_multicast is not None:
        if isinstance(child_multicast, yang.gdata.Container):
            children['multicast'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(child_multicast)
    child_carrierscarrier = n.children.get('carrierscarrier')
    if child_carrierscarrier is not None:
        if isinstance(child_carrierscarrier, yang.gdata.Leaf):
            children['carrierscarrier'] = child_carrierscarrier.val
    child_extranet_vpns = n.children.get('extranet-vpns')
    if child_extranet_vpns is not None:
        if isinstance(child_extranet_vpns, yang.gdata.Container):
            children['extranet-vpns'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(child_extranet_vpns)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__vpn_services(yang.adata.MNode):
    vpn_service: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service

    mut def __init__(self, vpn_service: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.vpn_service = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(elements=vpn_service)
        self.vpn_service._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_service = self.vpn_service
        if _vpn_service is not None:
            children['vpn-service'] = _vpn_service.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services(vpn_service=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service.from_gdata(n.get_opt_list("vpn-service")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services(vpn_service=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service.from_xml(yang.gdata.get_xml_children(n, "vpn-service")))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:vpn-service' or point == 'vpn-service':
            child = {'vpn-service': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_service_full = jd.get('l3vpn-svc:vpn-service')
    child_vpn_service = child_vpn_service_full if child_vpn_service_full is not None else jd.get('vpn-service')
    if child_vpn_service is not None and isinstance(child_vpn_service, list):
        children['vpn-service'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(child_vpn_service)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_vpn_service = n.children.get('vpn-service')
    if child_vpn_service is not None:
        if isinstance(child_vpn_service, yang.gdata.List):
            children['vpn-service'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(child_vpn_service)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(yang.adata.MNode):
    location_id: str
    address: ?str
    postal_code: ?str
    state: ?str
    city: ?str
    country_code: ?str

    mut def __init__(self, location_id: str, address: ?str, postal_code: ?str, state: ?str, city: ?str, country_code: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.location_id = location_id
        self.address = address
        self.postal_code = postal_code
        self.state = state
        self.city = city
        self.country_code = country_code

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _location_id = self.location_id
        _address = self.address
        _postal_code = self.postal_code
        _state = self.state
        _city = self.city
        _country_code = self.country_code
        if _location_id is not None:
            children['location-id'] = yang.gdata.Leaf('string', _location_id)
        if _address is not None:
            children['address'] = yang.gdata.Leaf('string', _address)
        if _postal_code is not None:
            children['postal-code'] = yang.gdata.Leaf('string', _postal_code)
        if _state is not None:
            children['state'] = yang.gdata.Leaf('string', _state)
        if _city is not None:
            children['city'] = yang.gdata.Leaf('string', _city)
        if _country_code is not None:
            children['country-code'] = yang.gdata.Leaf('string', _country_code)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.location_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id=n.get_str("location-id"), address=n.get_opt_str("address"), postal_code=n.get_opt_str("postal-code"), state=n.get_opt_str("state"), city=n.get_opt_str("city"), country_code=n.get_opt_str("country-code"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id=yang.gdata.from_xml_str(n, "location-id"), address=yang.gdata.from_xml_opt_str(n, "address"), postal_code=yang.gdata.from_xml_opt_str(n, "postal-code"), state=yang.gdata.from_xml_opt_str(n, "state"), city=yang.gdata.from_xml_opt_str(n, "city"), country_code=yang.gdata.from_xml_opt_str(n, "country-code"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'location'
        self.elements = elements

    mut def create(self, location_id):
        for e in self.elements:
            match = True
            if e.location_id != location_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['location-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['location-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'postal-code':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'state':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'city':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'country-code':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['location-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['location-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['location-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_location_id_full = jd.get('l3vpn-svc:location-id')
    child_location_id = child_location_id_full if child_location_id_full is not None else jd.get('location-id')
    if child_location_id is not None:
        children['location-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(child_location_id)
    child_address_full = jd.get('l3vpn-svc:address')
    child_address = child_address_full if child_address_full is not None else jd.get('address')
    if child_address is not None:
        children['address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address(child_address)
    child_postal_code_full = jd.get('l3vpn-svc:postal-code')
    child_postal_code = child_postal_code_full if child_postal_code_full is not None else jd.get('postal-code')
    if child_postal_code is not None:
        children['postal-code'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code(child_postal_code)
    child_state_full = jd.get('l3vpn-svc:state')
    child_state = child_state_full if child_state_full is not None else jd.get('state')
    if child_state is not None:
        children['state'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state(child_state)
    child_city_full = jd.get('l3vpn-svc:city')
    child_city = child_city_full if child_city_full is not None else jd.get('city')
    if child_city is not None:
        children['city'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city(child_city)
    child_country_code_full = jd.get('l3vpn-svc:country-code')
    child_country_code = child_country_code_full if child_country_code_full is not None else jd.get('country-code')
    if child_country_code is not None:
        children['country-code'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code(child_country_code)
    return yang.gdata.ListElement([str(child_location_id if child_location_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(e))
    return yang.gdata.List(keys=['location-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_location_id = n.children.get('location-id')
    if child_location_id is not None:
        if isinstance(child_location_id, yang.gdata.Leaf):
            children['location-id'] = child_location_id.val
    child_address = n.children.get('address')
    if child_address is not None:
        if isinstance(child_address, yang.gdata.Leaf):
            children['address'] = child_address.val
    child_postal_code = n.children.get('postal-code')
    if child_postal_code is not None:
        if isinstance(child_postal_code, yang.gdata.Leaf):
            children['postal-code'] = child_postal_code.val
    child_state = n.children.get('state')
    if child_state is not None:
        if isinstance(child_state, yang.gdata.Leaf):
            children['state'] = child_state.val
    child_city = n.children.get('city')
    if child_city is not None:
        if isinstance(child_city, yang.gdata.Leaf):
            children['city'] = child_city.val
    child_country_code = n.children.get('country-code')
    if child_country_code is not None:
        if isinstance(child_country_code, yang.gdata.Leaf):
            children['country-code'] = child_country_code.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(yang.adata.MNode):
    location: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location

    mut def __init__(self, location: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.location = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(elements=location)
        self.location._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _location = self.location
        if _location is not None:
            children['location'] = _location.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(location=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location.from_gdata(n.get_opt_list("location")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(location=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location.from_xml(yang.gdata.get_xml_children(n, "location")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:location' or point == 'location':
            child = {'location': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_location_full = jd.get('l3vpn-svc:location')
    child_location = child_location_full if child_location_full is not None else jd.get('location')
    if child_location is not None and isinstance(child_location, list):
        children['location'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(child_location)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_location = n.children.get('location')
    if child_location is not None:
        if isinstance(child_location, yang.gdata.List):
            children['location'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(child_location)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("union", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(yang.adata.MNode):
    address_family: ?str
    address: ?str

    mut def __init__(self, address_family: ?str, address: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.address_family = address_family
        self.address = address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        _address = self.address
        if _address_family is not None:
            children['address-family'] = yang.gdata.Leaf('enumeration', _address_family)
        if _address is not None:
            children['address'] = yang.gdata.Leaf('union', _address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(address_family=n.get_opt_str("address-family"), address=n.get_opt_str("address"))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management")

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(address_family=yang.gdata.from_xml_opt_str(n, "address-family"), address=yang.gdata.from_xml_opt_str(n, "address"))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management")


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:address' or point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None:
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family(child_address_family)
    child_address_full = jd.get('l3vpn-svc:address')
    child_address = child_address_full if child_address_full is not None else jd.get('address')
    if child_address is not None:
        children['address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address(child_address)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.Leaf):
            children['address-family'] = child_address_family.val
    child_address = n.children.get('address')
    if child_address is not None:
        if isinstance(child_address, yang.gdata.Leaf):
            children['address'] = child_address.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(yang.adata.MNode):
    device_id: str
    location: ?str
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management

    mut def __init__(self, device_id: str, location: ?str, management: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.device_id = device_id
        self.location = location
        if management is not None:
            self.management = management
        else:
            self.management = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management()
        self_management = self.management
        if self_management is not None:
            self_management._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device_id = self.device_id
        _location = self.location
        _management = self.management
        if _device_id is not None:
            children['device-id'] = yang.gdata.Leaf('string', _device_id)
        if _location is not None:
            children['location'] = yang.gdata.Leaf('leafref', _location)
        if _management is not None:
            children['management'] = _management.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.device_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id=n.get_str("device-id"), location=n.get_opt_str("location"), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management.from_gdata(n.get_opt_container("management")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id=yang.gdata.from_xml_str(n, "device-id"), location=yang.gdata.from_xml_opt_str(n, "location"), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management.from_xml(yang.gdata.get_xml_opt_child(n, "management")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'device'
        self.elements = elements

    mut def create(self, device_id, location):
        for e in self.elements:
            match = True
            if e.device_id != device_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id, location)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['device-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['device-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'location':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'management':
            children['management'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['device-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['device-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['device-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_device_id_full = jd.get('l3vpn-svc:device-id')
    child_device_id = child_device_id_full if child_device_id_full is not None else jd.get('device-id')
    if child_device_id is not None:
        children['device-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(child_device_id)
    child_location_full = jd.get('l3vpn-svc:location')
    child_location = child_location_full if child_location_full is not None else jd.get('location')
    if child_location is not None:
        children['location'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location(child_location)
    child_management_full = jd.get('l3vpn-svc:management')
    child_management = child_management_full if child_management_full is not None else jd.get('management')
    if child_management is not None and isinstance(child_management, dict):
        children['management'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(child_management)
    return yang.gdata.ListElement([str(child_device_id if child_device_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(e))
    return yang.gdata.List(keys=['device-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_device_id = n.children.get('device-id')
    if child_device_id is not None:
        if isinstance(child_device_id, yang.gdata.Leaf):
            children['device-id'] = child_device_id.val
    child_location = n.children.get('location')
    if child_location is not None:
        if isinstance(child_location, yang.gdata.Leaf):
            children['location'] = child_location.val
    child_management = n.children.get('management')
    if child_management is not None:
        if isinstance(child_management, yang.gdata.Container):
            children['management'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(child_management)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(yang.adata.MNode):
    device: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device

    mut def __init__(self, device: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.device = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(elements=device)
        self.device._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device = self.device
        if _device is not None:
            children['device'] = _device.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(device=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device.from_gdata(n.get_opt_list("device")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(device=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device.from_xml(yang.gdata.get_xml_children(n, "device")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:device' or point == 'device':
            child = {'device': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_device_full = jd.get('l3vpn-svc:device')
    child_device = child_device_full if child_device_full is not None else jd.get('device')
    if child_device is not None and isinstance(child_device, list):
        children['device'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(child_device)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_device = n.children.get('device')
    if child_device is not None:
        if isinstance(child_device, yang.gdata.List):
            children['device'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(child_device)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.group_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id=n.get_str("group-id"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id=yang.gdata.from_xml_str(n, "group-id"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['group-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_group_id_full = jd.get('l3vpn-svc:group-id')
    child_group_id = child_group_id_full if child_group_id_full is not None else jd.get('group-id')
    if child_group_id is not None:
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(child_group_id)
    return yang.gdata.ListElement([str(child_group_id if child_group_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_group_id = n.children.get('group-id')
    if child_group_id is not None:
        if isinstance(child_group_id, yang.gdata.Leaf):
            children['group-id'] = child_group_id.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(elements=group)
        self.group._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group.from_gdata(n.get_opt_list("group")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group.from_xml(yang.gdata.get_xml_children(n, "group")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:group' or point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group_full = jd.get('l3vpn-svc:group')
    child_group = child_group_full if child_group_full is not None else jd.get('group')
    if child_group is not None and isinstance(child_group, list):
        children['group'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(child_group)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_group = n.children.get('group')
    if child_group is not None:
        if isinstance(child_group, yang.gdata.List):
            children['group'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(child_group)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if groups is not None:
            self.groups = groups
        else:
            self.groups = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()
        self_groups = self.groups
        if self_groups is not None:
            self_groups._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups.from_gdata(n.get_opt_container("groups")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups.from_xml(yang.gdata.get_xml_opt_child(n, "groups")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:groups' or point == 'groups':
            child = {'groups': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_groups_full = jd.get('l3vpn-svc:groups')
    child_groups = child_groups_full if child_groups_full is not None else jd.get('groups')
    if child_groups is not None and isinstance(child_groups, dict):
        children['groups'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(child_groups)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_groups = n.children.get('groups')
    if child_groups is not None:
        if isinstance(child_groups, yang.gdata.Container):
            children['groups'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(child_groups)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__management(yang.adata.MNode):
    type: ?str

    mut def __init__(self, type: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.type = type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('identityref', _type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__management:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__management(type=n.get_opt_str("type"))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__management")

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__management:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__management(type=yang.gdata.from_xml_opt_str(n, "type"))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__management")


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:type' or point == 'type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_type_full = jd.get('l3vpn-svc:type')
    child_type = child_type_full if child_type_full is not None else jd.get('type')
    if child_type is not None:
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type(child_type)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_type = n.children.get('type')
    if child_type is not None:
        if isinstance(child_type, yang.gdata.Leaf):
            children['type'] = child_type.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(yang.adata.MNode):
    type: str
    lan_tag: list[str]
    ipv4_lan_prefix: list[str]
    ipv6_lan_prefix: list[str]

    mut def __init__(self, type: str, lan_tag: ?list[str]=None, ipv4_lan_prefix: ?list[str]=None, ipv6_lan_prefix: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.type = type
        if lan_tag is not None:
            self.lan_tag = lan_tag
        else:
            self.lan_tag = []
        if ipv4_lan_prefix is not None:
            self.ipv4_lan_prefix = ipv4_lan_prefix
        else:
            self.ipv4_lan_prefix = []
        if ipv6_lan_prefix is not None:
            self.ipv6_lan_prefix = ipv6_lan_prefix
        else:
            self.ipv6_lan_prefix = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('identityref', _type)
        children['lan-tag'] = yang.gdata.LeafList(self.lan_tag)
        children['ipv4-lan-prefix'] = yang.gdata.LeafList(self.ipv4_lan_prefix)
        children['ipv6-lan-prefix'] = yang.gdata.LeafList(self.ipv6_lan_prefix)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.type)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type=n.get_str("type"), lan_tag=n.get_opt_strs("lan-tag"), ipv4_lan_prefix=n.get_opt_strs("ipv4-lan-prefix"), ipv6_lan_prefix=n.get_opt_strs("ipv6-lan-prefix"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type=yang.gdata.from_xml_str(n, "type"), lan_tag=yang.gdata.from_xml_opt_strs(n, "lan-tag"), ipv4_lan_prefix=yang.gdata.from_xml_opt_strs(n, "ipv4-lan-prefix"), ipv6_lan_prefix=yang.gdata.from_xml_opt_strs(n, "ipv6-lan-prefix"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'filter'
        self.elements = elements

    mut def create(self, type):
        for e in self.elements:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['type']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-lan-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-lan-prefix':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_type_full = jd.get('l3vpn-svc:type')
    child_type = child_type_full if child_type_full is not None else jd.get('type')
    if child_type is not None:
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(child_type)
    child_lan_tag_full = jd.get('l3vpn-svc:lan-tag')
    child_lan_tag = child_lan_tag_full if child_lan_tag_full is not None else jd.get('lan-tag')
    if child_lan_tag is not None and isinstance(child_lan_tag, list):
        children['lan-tag'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag(child_lan_tag)
    child_ipv4_lan_prefix_full = jd.get('l3vpn-svc:ipv4-lan-prefix')
    child_ipv4_lan_prefix = child_ipv4_lan_prefix_full if child_ipv4_lan_prefix_full is not None else jd.get('ipv4-lan-prefix')
    if child_ipv4_lan_prefix is not None and isinstance(child_ipv4_lan_prefix, list):
        children['ipv4-lan-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix(child_ipv4_lan_prefix)
    child_ipv6_lan_prefix_full = jd.get('l3vpn-svc:ipv6-lan-prefix')
    child_ipv6_lan_prefix = child_ipv6_lan_prefix_full if child_ipv6_lan_prefix_full is not None else jd.get('ipv6-lan-prefix')
    if child_ipv6_lan_prefix is not None and isinstance(child_ipv6_lan_prefix, list):
        children['ipv6-lan-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix(child_ipv6_lan_prefix)
    return yang.gdata.ListElement([str(child_type if child_type is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(e))
    return yang.gdata.List(keys=['type'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_type = n.children.get('type')
    if child_type is not None:
        if isinstance(child_type, yang.gdata.Leaf):
            children['type'] = child_type.val
    child_lan_tag = n.children.get('lan-tag')
    if child_lan_tag is not None:
        if isinstance(child_lan_tag, yang.gdata.LeafList):
            children['lan-tag'] = child_lan_tag.vals
    child_ipv4_lan_prefix = n.children.get('ipv4-lan-prefix')
    if child_ipv4_lan_prefix is not None:
        if isinstance(child_ipv4_lan_prefix, yang.gdata.LeafList):
            children['ipv4-lan-prefix'] = child_ipv4_lan_prefix.vals
    child_ipv6_lan_prefix = n.children.get('ipv6-lan-prefix')
    if child_ipv6_lan_prefix is not None:
        if isinstance(child_ipv6_lan_prefix, yang.gdata.LeafList):
            children['ipv6-lan-prefix'] = child_ipv6_lan_prefix.vals
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(yang.adata.MNode):
    filter: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter

    mut def __init__(self, filter: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.filter = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(elements=filter)
        self.filter._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _filter = self.filter
        if _filter is not None:
            children['filter'] = _filter.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(filter=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter.from_gdata(n.get_opt_list("filter")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(filter=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter.from_xml(yang.gdata.get_xml_children(n, "filter")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:filter' or point == 'filter':
            child = {'filter': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_filter_full = jd.get('l3vpn-svc:filter')
    child_filter = child_filter_full if child_filter_full is not None else jd.get('filter')
    if child_filter is not None and isinstance(child_filter, list):
        children['filter'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(child_filter)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_filter = n.children.get('filter')
    if child_filter is not None:
        if isinstance(child_filter, yang.gdata.List):
            children['filter'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(child_filter)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(yang.adata.MNode):
    vpn_id: str
    site_role: ?str

    mut def __init__(self, vpn_id: str, site_role: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.vpn_id = vpn_id
        self.site_role = site_role

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        _site_role = self.site_role
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('leafref', _vpn_id)
        if _site_role is not None:
            children['site-role'] = yang.gdata.Leaf('identityref', _site_role)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.vpn_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id=n.get_str("vpn-id"), site_role=n.get_opt_str("site-role"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id=yang.gdata.from_xml_str(n, "vpn-id"), site_role=yang.gdata.from_xml_opt_str(n, "site-role"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['vpn-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'site-role':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_vpn_id_full = jd.get('l3vpn-svc:vpn-id')
    child_vpn_id = child_vpn_id_full if child_vpn_id_full is not None else jd.get('vpn-id')
    if child_vpn_id is not None:
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(child_vpn_id)
    child_site_role_full = jd.get('l3vpn-svc:site-role')
    child_site_role = child_site_role_full if child_site_role_full is not None else jd.get('site-role')
    if child_site_role is not None:
        children['site-role'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role(child_site_role)
    return yang.gdata.ListElement([str(child_vpn_id if child_vpn_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(e))
    return yang.gdata.List(keys=['vpn-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_vpn_id = n.children.get('vpn-id')
    if child_vpn_id is not None:
        if isinstance(child_vpn_id, yang.gdata.Leaf):
            children['vpn-id'] = child_vpn_id.val
    child_site_role = n.children.get('site-role')
    if child_site_role is not None:
        if isinstance(child_site_role, yang.gdata.Leaf):
            children['site-role'] = child_site_role.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(yang.adata.MNode):
    id: str
    filters: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters
    vpn: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn

    mut def __init__(self, id: str, filters: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters=None, vpn: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.id = id
        if filters is not None:
            self.filters = filters
        else:
            self.filters = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()
        self_filters = self.filters
        if self_filters is not None:
            self_filters._parent = self
        self.vpn = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(elements=vpn)
        self.vpn._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        _filters = self.filters
        _vpn = self.vpn
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        if _filters is not None:
            children['filters'] = _filters.to_gdata()
        if _vpn is not None:
            children['vpn'] = _vpn.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id=n.get_str("id"), filters=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters.from_gdata(n.get_opt_container("filters")), vpn=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn.from_gdata(n.get_opt_list("vpn")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id=yang.gdata.from_xml_str(n, "id"), filters=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters.from_xml(yang.gdata.get_xml_opt_child(n, "filters")), vpn=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn.from_xml(yang.gdata.get_xml_children(n, "vpn")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'entries'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'filters':
            children['filters'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd, rest_path, op)
        if point == 'vpn':
            children['vpn'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_id_full = jd.get('l3vpn-svc:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(child_id)
    child_filters_full = jd.get('l3vpn-svc:filters')
    child_filters = child_filters_full if child_filters_full is not None else jd.get('filters')
    if child_filters is not None and isinstance(child_filters, dict):
        children['filters'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(child_filters)
    child_vpn_full = jd.get('l3vpn-svc:vpn')
    child_vpn = child_vpn_full if child_vpn_full is not None else jd.get('vpn')
    if child_vpn is not None and isinstance(child_vpn, list):
        children['vpn'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(child_vpn)
    return yang.gdata.ListElement([str(child_id if child_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    child_filters = n.children.get('filters')
    if child_filters is not None:
        if isinstance(child_filters, yang.gdata.Container):
            children['filters'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(child_filters)
    child_vpn = n.children.get('vpn')
    if child_vpn is not None:
        if isinstance(child_vpn, yang.gdata.List):
            children['vpn'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(child_vpn)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(yang.adata.MNode):
    vpn_policy_id: str
    entries: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries

    mut def __init__(self, vpn_policy_id: str, entries: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.vpn_policy_id = vpn_policy_id
        self.entries = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(elements=entries)
        self.entries._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy_id = self.vpn_policy_id
        _entries = self.entries
        if _vpn_policy_id is not None:
            children['vpn-policy-id'] = yang.gdata.Leaf('string', _vpn_policy_id)
        if _entries is not None:
            children['entries'] = _entries.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.vpn_policy_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id=n.get_str("vpn-policy-id"), entries=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries.from_gdata(n.get_opt_list("entries")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id=yang.gdata.from_xml_str(n, "vpn-policy-id"), entries=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries.from_xml(yang.gdata.get_xml_children(n, "entries")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'vpn-policy'
        self.elements = elements

    mut def create(self, vpn_policy_id):
        for e in self.elements:
            match = True
            if e.vpn_policy_id != vpn_policy_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-policy-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['vpn-policy-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'entries':
            children['entries'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-policy-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['vpn-policy-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-policy-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_vpn_policy_id_full = jd.get('l3vpn-svc:vpn-policy-id')
    child_vpn_policy_id = child_vpn_policy_id_full if child_vpn_policy_id_full is not None else jd.get('vpn-policy-id')
    if child_vpn_policy_id is not None:
        children['vpn-policy-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(child_vpn_policy_id)
    child_entries_full = jd.get('l3vpn-svc:entries')
    child_entries = child_entries_full if child_entries_full is not None else jd.get('entries')
    if child_entries is not None and isinstance(child_entries, list):
        children['entries'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(child_entries)
    return yang.gdata.ListElement([str(child_vpn_policy_id if child_vpn_policy_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(e))
    return yang.gdata.List(keys=['vpn-policy-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_vpn_policy_id = n.children.get('vpn-policy-id')
    if child_vpn_policy_id is not None:
        if isinstance(child_vpn_policy_id, yang.gdata.Leaf):
            children['vpn-policy-id'] = child_vpn_policy_id.val
    child_entries = n.children.get('entries')
    if child_entries is not None:
        if isinstance(child_entries, yang.gdata.List):
            children['entries'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(child_entries)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(yang.adata.MNode):
    vpn_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy

    mut def __init__(self, vpn_policy: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.vpn_policy = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(elements=vpn_policy)
        self.vpn_policy._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy = self.vpn_policy
        if _vpn_policy is not None:
            children['vpn-policy'] = _vpn_policy.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(vpn_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy.from_gdata(n.get_opt_list("vpn-policy")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(vpn_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy.from_xml(yang.gdata.get_xml_children(n, "vpn-policy")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:vpn-policy' or point == 'vpn-policy':
            child = {'vpn-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_policy_full = jd.get('l3vpn-svc:vpn-policy')
    child_vpn_policy = child_vpn_policy_full if child_vpn_policy_full is not None else jd.get('vpn-policy')
    if child_vpn_policy is not None and isinstance(child_vpn_policy, list):
        children['vpn-policy'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(child_vpn_policy)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_vpn_policy = n.children.get('vpn-policy')
    if child_vpn_policy is not None:
        if isinstance(child_vpn_policy, yang.gdata.List):
            children['vpn-policy'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(child_vpn_policy)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(yang.adata.MNode):
    af: str
    maximum_routes: ?int

    mut def __init__(self, af: str, maximum_routes: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.af = af
        self.maximum_routes = maximum_routes

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af = self.af
        _maximum_routes = self.maximum_routes
        if _af is not None:
            children['af'] = yang.gdata.Leaf('enumeration', _af)
        if _maximum_routes is not None:
            children['maximum-routes'] = yang.gdata.Leaf('uint32', _maximum_routes)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.af)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af=n.get_str("af"), maximum_routes=n.get_opt_int("maximum-routes"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af=yang.gdata.from_xml_str(n, "af"), maximum_routes=yang.gdata.from_xml_opt_int(n, "maximum-routes"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af):
        for e in self.elements:
            match = True
            if e.af != af:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['af'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['af']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'maximum-routes':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['af']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['af'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['af'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_af_full = jd.get('l3vpn-svc:af')
    child_af = child_af_full if child_af_full is not None else jd.get('af')
    if child_af is not None:
        children['af'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(child_af)
    child_maximum_routes_full = jd.get('l3vpn-svc:maximum-routes')
    child_maximum_routes = child_maximum_routes_full if child_maximum_routes_full is not None else jd.get('maximum-routes')
    if child_maximum_routes is not None:
        children['maximum-routes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes(child_maximum_routes)
    return yang.gdata.ListElement([str(child_af if child_af is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(e))
    return yang.gdata.List(keys=['af'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_af = n.children.get('af')
    if child_af is not None:
        if isinstance(child_af, yang.gdata.Leaf):
            children['af'] = child_af.val
    child_maximum_routes = n.children.get('maximum-routes')
    if child_maximum_routes is not None:
        if isinstance(child_maximum_routes, yang.gdata.Leaf):
            children['maximum-routes'] = child_maximum_routes.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(yang.adata.MNode):
    address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family

    mut def __init__(self, address_family: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.address_family = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(elements=address_family)
        self.address_family._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family.from_gdata(n.get_opt_list("address-family")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family.from_xml(yang.gdata.get_xml_children(n, "address-family")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            child = {'address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, list):
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(child_address_family)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.List):
            children['address-family'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(child_address_family)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile_name = self.profile_name
        _algorithm = self.algorithm
        _preshared_key = self.preshared_key
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('string', _algorithm)
        if _preshared_key is not None:
            children['preshared-key'] = yang.gdata.Leaf('string', _preshared_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(profile_name=n.get_opt_str("profile-name"), algorithm=n.get_opt_str("algorithm"), preshared_key=n.get_opt_str("preshared-key"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(profile_name=yang.gdata.from_xml_opt_str(n, "profile-name"), algorithm=yang.gdata.from_xml_opt_str(n, "algorithm"), preshared_key=yang.gdata.from_xml_opt_str(n, "preshared-key"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:profile-name' or point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:algorithm' or point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:preshared-key' or point == 'preshared-key':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_name_full = jd.get('l3vpn-svc:profile-name')
    child_profile_name = child_profile_name_full if child_profile_name_full is not None else jd.get('profile-name')
    if child_profile_name is not None:
        children['profile-name'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name(child_profile_name)
    child_algorithm_full = jd.get('l3vpn-svc:algorithm')
    child_algorithm = child_algorithm_full if child_algorithm_full is not None else jd.get('algorithm')
    if child_algorithm is not None:
        children['algorithm'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm(child_algorithm)
    child_preshared_key_full = jd.get('l3vpn-svc:preshared-key')
    child_preshared_key = child_preshared_key_full if child_preshared_key_full is not None else jd.get('preshared-key')
    if child_preshared_key is not None:
        children['preshared-key'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key(child_preshared_key)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_profile_name = n.children.get('profile-name')
    if child_profile_name is not None:
        if isinstance(child_profile_name, yang.gdata.Leaf):
            children['profile-name'] = child_profile_name.val
    child_algorithm = n.children.get('algorithm')
    if child_algorithm is not None:
        if isinstance(child_algorithm, yang.gdata.Leaf):
            children['algorithm'] = child_algorithm.val
    child_preshared_key = n.children.get('preshared-key')
    if child_preshared_key is not None:
        if isinstance(child_preshared_key, yang.gdata.Leaf):
            children['preshared-key'] = child_preshared_key.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(yang.adata.MNode):
    enabled: ?bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.enabled = enabled
        self.layer = layer
        if encryption_profile is not None:
            self.encryption_profile = encryption_profile
        else:
            self.encryption_profile = ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()
        self_encryption_profile = self.encryption_profile
        if self_encryption_profile is not None:
            self_encryption_profile._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        _layer = self.layer
        _encryption_profile = self.encryption_profile
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        if _layer is not None:
            children['layer'] = yang.gdata.Leaf('enumeration', _layer)
        if _encryption_profile is not None:
            children['encryption-profile'] = _encryption_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(enabled=n.get_opt_bool("enabled"), layer=n.get_opt_str("layer"), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile.from_gdata(n.get_opt_container("encryption-profile")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(enabled=yang.gdata.from_xml_opt_bool(n, "enabled"), layer=yang.gdata.from_xml_opt_str(n, "layer"), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile.from_xml(yang.gdata.get_xml_opt_child(n, "encryption-profile")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:enabled' or point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:layer' or point == 'layer':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:encryption-profile' or point == 'encryption-profile':
            child = {'encryption-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled_full = jd.get('l3vpn-svc:enabled')
    child_enabled = child_enabled_full if child_enabled_full is not None else jd.get('enabled')
    if child_enabled is not None:
        children['enabled'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled(child_enabled)
    child_layer_full = jd.get('l3vpn-svc:layer')
    child_layer = child_layer_full if child_layer_full is not None else jd.get('layer')
    if child_layer is not None:
        children['layer'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer(child_layer)
    child_encryption_profile_full = jd.get('l3vpn-svc:encryption-profile')
    child_encryption_profile = child_encryption_profile_full if child_encryption_profile_full is not None else jd.get('encryption-profile')
    if child_encryption_profile is not None and isinstance(child_encryption_profile, dict):
        children['encryption-profile'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(child_encryption_profile)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_enabled = n.children.get('enabled')
    if child_enabled is not None:
        if isinstance(child_enabled, yang.gdata.Leaf):
            children['enabled'] = child_enabled.val
    child_layer = n.children.get('layer')
    if child_layer is not None:
        if isinstance(child_layer, yang.gdata.Leaf):
            children['layer'] = child_layer.val
    child_encryption_profile = n.children.get('encryption-profile')
    if child_encryption_profile is not None:
        if isinstance(child_encryption_profile, yang.gdata.Container):
            children['encryption-profile'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(child_encryption_profile)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if authentication is not None:
            self.authentication = authentication
        else:
            self.authentication = ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        self_authentication = self.authentication
        if self_authentication is not None:
            self_authentication._parent = self
        if encryption is not None:
            self.encryption = encryption
        else:
            self.encryption = ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()
        self_encryption = self.encryption
        if self_encryption is not None:
            self_encryption._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _authentication = self.authentication
        _encryption = self.encryption
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        if _encryption is not None:
            children['encryption'] = _encryption.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication.from_gdata(n.get_opt_container("authentication")), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption.from_gdata(n.get_opt_container("encryption")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication.from_xml(yang.gdata.get_xml_opt_child(n, "authentication")), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption.from_xml(yang.gdata.get_xml_opt_child(n, "encryption")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:authentication' or point == 'authentication':
            child = {'authentication': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:encryption' or point == 'encryption':
            child = {'encryption': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_authentication_full = jd.get('l3vpn-svc:authentication')
    child_authentication = child_authentication_full if child_authentication_full is not None else jd.get('authentication')
    if child_authentication is not None and isinstance(child_authentication, dict):
        children['authentication'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(child_authentication)
    child_encryption_full = jd.get('l3vpn-svc:encryption')
    child_encryption = child_encryption_full if child_encryption_full is not None else jd.get('encryption')
    if child_encryption is not None and isinstance(child_encryption, dict):
        children['encryption'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(child_encryption)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_authentication = n.children.get('authentication')
    if child_authentication is not None:
        if isinstance(child_authentication, yang.gdata.Container):
            children['authentication'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(child_authentication)
    child_encryption = n.children.get('encryption')
    if child_encryption is not None:
        if isinstance(child_encryption, yang.gdata.Container):
            children['encryption'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(child_encryption)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        _upper_port = self.upper_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_int("lower-port"), upper_port=n.get_opt_int("upper-port"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=yang.gdata.from_xml_opt_int(n, "lower-port"), upper_port=yang.gdata.from_xml_opt_int(n, "upper-port"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:lower-port' or point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:upper-port' or point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port_full = jd.get('l3vpn-svc:lower-port')
    child_lower_port = child_lower_port_full if child_lower_port_full is not None else jd.get('lower-port')
    if child_lower_port is not None:
        children['lower-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(child_lower_port)
    child_upper_port_full = jd.get('l3vpn-svc:upper-port')
    child_upper_port = child_upper_port_full if child_upper_port_full is not None else jd.get('upper-port')
    if child_upper_port is not None:
        children['upper-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(child_upper_port)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_lower_port = n.children.get('lower-port')
    if child_lower_port is not None:
        if isinstance(child_lower_port, yang.gdata.Leaf):
            children['lower-port'] = child_lower_port.val
    child_upper_port = n.children.get('upper-port')
    if child_upper_port is not None:
        if isinstance(child_upper_port, yang.gdata.Leaf):
            children['upper-port'] = child_upper_port.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        _upper_port = self.upper_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_int("lower-port"), upper_port=n.get_opt_int("upper-port"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=yang.gdata.from_xml_opt_int(n, "lower-port"), upper_port=yang.gdata.from_xml_opt_int(n, "upper-port"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:lower-port' or point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:upper-port' or point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port_full = jd.get('l3vpn-svc:lower-port')
    child_lower_port = child_lower_port_full if child_lower_port_full is not None else jd.get('lower-port')
    if child_lower_port is not None:
        children['lower-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(child_lower_port)
    child_upper_port_full = jd.get('l3vpn-svc:upper-port')
    child_upper_port = child_upper_port_full if child_upper_port_full is not None else jd.get('upper-port')
    if child_upper_port is not None:
        children['upper-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(child_upper_port)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_lower_port = n.children.get('lower-port')
    if child_lower_port is not None:
        if isinstance(child_lower_port, yang.gdata.Leaf):
            children['lower-port'] = child_lower_port.val
    child_upper_port = n.children.get('upper-port')
    if child_upper_port is not None:
        if isinstance(child_upper_port, yang.gdata.Leaf):
            children['upper-port'] = child_upper_port.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("union", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?int
    dot1p: ?int
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?int
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?int
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?int, dot1p: ?int, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?int, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?int, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        if target_sites is not None:
            self.target_sites = target_sites
        else:
            self.target_sites = []
        if l4_src_port_range is not None:
            self.l4_src_port_range = l4_src_port_range
        else:
            self.l4_src_port_range = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self_l4_src_port_range = self.l4_src_port_range
        if self_l4_src_port_range is not None:
            self_l4_src_port_range._parent = self
        self.l4_dst_port = l4_dst_port
        if l4_dst_port_range is not None:
            self.l4_dst_port_range = l4_dst_port_range
        else:
            self.l4_dst_port_range = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self_l4_dst_port_range = self.l4_dst_port_range
        if self_l4_dst_port_range is not None:
            self_l4_dst_port_range._parent = self
        self.protocol_field = protocol_field

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _dscp = self.dscp
        _dot1p = self.dot1p
        _ipv4_src_prefix = self.ipv4_src_prefix
        _ipv6_src_prefix = self.ipv6_src_prefix
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        _l4_src_port = self.l4_src_port
        _l4_src_port_range = self.l4_src_port_range
        _l4_dst_port = self.l4_dst_port
        _l4_dst_port_range = self.l4_dst_port_range
        _protocol_field = self.protocol_field
        if _dscp is not None:
            children['dscp'] = yang.gdata.Leaf('uint8', _dscp)
        if _dot1p is not None:
            children['dot1p'] = yang.gdata.Leaf('uint8', _dot1p)
        if _ipv4_src_prefix is not None:
            children['ipv4-src-prefix'] = yang.gdata.Leaf('string', _ipv4_src_prefix)
        if _ipv6_src_prefix is not None:
            children['ipv6-src-prefix'] = yang.gdata.Leaf('string', _ipv6_src_prefix)
        if _ipv4_dst_prefix is not None:
            children['ipv4-dst-prefix'] = yang.gdata.Leaf('string', _ipv4_dst_prefix)
        if _ipv6_dst_prefix is not None:
            children['ipv6-dst-prefix'] = yang.gdata.Leaf('string', _ipv6_dst_prefix)
        if _l4_src_port is not None:
            children['l4-src-port'] = yang.gdata.Leaf('uint16', _l4_src_port)
        children['target-sites'] = yang.gdata.LeafList(self.target_sites)
        if _l4_src_port_range is not None:
            children['l4-src-port-range'] = _l4_src_port_range.to_gdata()
        if _l4_dst_port is not None:
            children['l4-dst-port'] = yang.gdata.Leaf('uint16', _l4_dst_port)
        if _l4_dst_port_range is not None:
            children['l4-dst-port-range'] = _l4_dst_port_range.to_gdata()
        if _protocol_field is not None:
            children['protocol-field'] = yang.gdata.Leaf('union', _protocol_field)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_int("dscp"), dot1p=n.get_opt_int("dot1p"), ipv4_src_prefix=n.get_opt_str("ipv4-src-prefix"), ipv6_src_prefix=n.get_opt_str("ipv6-src-prefix"), ipv4_dst_prefix=n.get_opt_str("ipv4-dst-prefix"), ipv6_dst_prefix=n.get_opt_str("ipv6-dst-prefix"), l4_src_port=n.get_opt_int("l4-src-port"), target_sites=n.get_opt_strs("target-sites"), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_container("l4-src-port-range")), l4_dst_port=n.get_opt_int("l4-dst-port"), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_container("l4-dst-port-range")), protocol_field=n.get_opt_value("protocol-field"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(dscp=yang.gdata.from_xml_opt_int(n, "dscp"), dot1p=yang.gdata.from_xml_opt_int(n, "dot1p"), ipv4_src_prefix=yang.gdata.from_xml_opt_str(n, "ipv4-src-prefix"), ipv6_src_prefix=yang.gdata.from_xml_opt_str(n, "ipv6-src-prefix"), ipv4_dst_prefix=yang.gdata.from_xml_opt_str(n, "ipv4-dst-prefix"), ipv6_dst_prefix=yang.gdata.from_xml_opt_str(n, "ipv6-dst-prefix"), l4_src_port=yang.gdata.from_xml_opt_int(n, "l4-src-port"), target_sites=yang.gdata.from_xml_opt_strs(n, "target-sites"), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_xml(yang.gdata.get_xml_opt_child(n, "l4-src-port-range")), l4_dst_port=yang.gdata.from_xml_opt_int(n, "l4-dst-port"), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_xml(yang.gdata.get_xml_opt_child(n, "l4-dst-port-range")), protocol_field=yang.gdata.from_xml_opt_value(n, "protocol-field"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:dscp' or point == 'dscp':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:dot1p' or point == 'dot1p':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv4-src-prefix' or point == 'ipv4-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv6-src-prefix' or point == 'ipv6-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv4-dst-prefix' or point == 'ipv4-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv6-dst-prefix' or point == 'ipv6-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:l4-src-port' or point == 'l4-src-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:target-sites' or point == 'target-sites':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:l4-src-port-range' or point == 'l4-src-port-range':
            child = {'l4-src-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:l4-dst-port' or point == 'l4-dst-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:l4-dst-port-range' or point == 'l4-dst-port-range':
            child = {'l4-dst-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:protocol-field' or point == 'protocol-field':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_dscp_full = jd.get('l3vpn-svc:dscp')
    child_dscp = child_dscp_full if child_dscp_full is not None else jd.get('dscp')
    if child_dscp is not None:
        children['dscp'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp(child_dscp)
    child_dot1p_full = jd.get('l3vpn-svc:dot1p')
    child_dot1p = child_dot1p_full if child_dot1p_full is not None else jd.get('dot1p')
    if child_dot1p is not None:
        children['dot1p'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p(child_dot1p)
    child_ipv4_src_prefix_full = jd.get('l3vpn-svc:ipv4-src-prefix')
    child_ipv4_src_prefix = child_ipv4_src_prefix_full if child_ipv4_src_prefix_full is not None else jd.get('ipv4-src-prefix')
    if child_ipv4_src_prefix is not None:
        children['ipv4-src-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(child_ipv4_src_prefix)
    child_ipv6_src_prefix_full = jd.get('l3vpn-svc:ipv6-src-prefix')
    child_ipv6_src_prefix = child_ipv6_src_prefix_full if child_ipv6_src_prefix_full is not None else jd.get('ipv6-src-prefix')
    if child_ipv6_src_prefix is not None:
        children['ipv6-src-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(child_ipv6_src_prefix)
    child_ipv4_dst_prefix_full = jd.get('l3vpn-svc:ipv4-dst-prefix')
    child_ipv4_dst_prefix = child_ipv4_dst_prefix_full if child_ipv4_dst_prefix_full is not None else jd.get('ipv4-dst-prefix')
    if child_ipv4_dst_prefix is not None:
        children['ipv4-dst-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(child_ipv4_dst_prefix)
    child_ipv6_dst_prefix_full = jd.get('l3vpn-svc:ipv6-dst-prefix')
    child_ipv6_dst_prefix = child_ipv6_dst_prefix_full if child_ipv6_dst_prefix_full is not None else jd.get('ipv6-dst-prefix')
    if child_ipv6_dst_prefix is not None:
        children['ipv6-dst-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(child_ipv6_dst_prefix)
    child_l4_src_port_full = jd.get('l3vpn-svc:l4-src-port')
    child_l4_src_port = child_l4_src_port_full if child_l4_src_port_full is not None else jd.get('l4-src-port')
    if child_l4_src_port is not None:
        children['l4-src-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(child_l4_src_port)
    child_target_sites_full = jd.get('l3vpn-svc:target-sites')
    child_target_sites = child_target_sites_full if child_target_sites_full is not None else jd.get('target-sites')
    if child_target_sites is not None and isinstance(child_target_sites, list):
        children['target-sites'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites(child_target_sites)
    child_l4_src_port_range_full = jd.get('l3vpn-svc:l4-src-port-range')
    child_l4_src_port_range = child_l4_src_port_range_full if child_l4_src_port_range_full is not None else jd.get('l4-src-port-range')
    if child_l4_src_port_range is not None and isinstance(child_l4_src_port_range, dict):
        children['l4-src-port-range'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(child_l4_src_port_range)
    child_l4_dst_port_full = jd.get('l3vpn-svc:l4-dst-port')
    child_l4_dst_port = child_l4_dst_port_full if child_l4_dst_port_full is not None else jd.get('l4-dst-port')
    if child_l4_dst_port is not None:
        children['l4-dst-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(child_l4_dst_port)
    child_l4_dst_port_range_full = jd.get('l3vpn-svc:l4-dst-port-range')
    child_l4_dst_port_range = child_l4_dst_port_range_full if child_l4_dst_port_range_full is not None else jd.get('l4-dst-port-range')
    if child_l4_dst_port_range is not None and isinstance(child_l4_dst_port_range, dict):
        children['l4-dst-port-range'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(child_l4_dst_port_range)
    child_protocol_field_full = jd.get('l3vpn-svc:protocol-field')
    child_protocol_field = child_protocol_field_full if child_protocol_field_full is not None else jd.get('protocol-field')
    if child_protocol_field is not None:
        children['protocol-field'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field(child_protocol_field)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_dscp = n.children.get('dscp')
    if child_dscp is not None:
        if isinstance(child_dscp, yang.gdata.Leaf):
            children['dscp'] = child_dscp.val
    child_dot1p = n.children.get('dot1p')
    if child_dot1p is not None:
        if isinstance(child_dot1p, yang.gdata.Leaf):
            children['dot1p'] = child_dot1p.val
    child_ipv4_src_prefix = n.children.get('ipv4-src-prefix')
    if child_ipv4_src_prefix is not None:
        if isinstance(child_ipv4_src_prefix, yang.gdata.Leaf):
            children['ipv4-src-prefix'] = child_ipv4_src_prefix.val
    child_ipv6_src_prefix = n.children.get('ipv6-src-prefix')
    if child_ipv6_src_prefix is not None:
        if isinstance(child_ipv6_src_prefix, yang.gdata.Leaf):
            children['ipv6-src-prefix'] = child_ipv6_src_prefix.val
    child_ipv4_dst_prefix = n.children.get('ipv4-dst-prefix')
    if child_ipv4_dst_prefix is not None:
        if isinstance(child_ipv4_dst_prefix, yang.gdata.Leaf):
            children['ipv4-dst-prefix'] = child_ipv4_dst_prefix.val
    child_ipv6_dst_prefix = n.children.get('ipv6-dst-prefix')
    if child_ipv6_dst_prefix is not None:
        if isinstance(child_ipv6_dst_prefix, yang.gdata.Leaf):
            children['ipv6-dst-prefix'] = child_ipv6_dst_prefix.val
    child_l4_src_port = n.children.get('l4-src-port')
    if child_l4_src_port is not None:
        if isinstance(child_l4_src_port, yang.gdata.Leaf):
            children['l4-src-port'] = child_l4_src_port.val
    child_target_sites = n.children.get('target-sites')
    if child_target_sites is not None:
        if isinstance(child_target_sites, yang.gdata.LeafList):
            children['target-sites'] = child_target_sites.vals
    child_l4_src_port_range = n.children.get('l4-src-port-range')
    if child_l4_src_port_range is not None:
        if isinstance(child_l4_src_port_range, yang.gdata.Container):
            children['l4-src-port-range'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(child_l4_src_port_range)
    child_l4_dst_port = n.children.get('l4-dst-port')
    if child_l4_dst_port is not None:
        if isinstance(child_l4_dst_port, yang.gdata.Leaf):
            children['l4-dst-port'] = child_l4_dst_port.val
    child_l4_dst_port_range = n.children.get('l4-dst-port-range')
    if child_l4_dst_port_range is not None:
        if isinstance(child_l4_dst_port_range, yang.gdata.Container):
            children['l4-dst-port-range'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(child_l4_dst_port_range)
    child_protocol_field = n.children.get('protocol-field')
    if child_protocol_field is not None:
        if isinstance(child_protocol_field, yang.gdata.Leaf):
            children['protocol-field'] = child_protocol_field.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?str
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?str, target_class_id: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.id = id
        if match_flow is not None:
            self.match_flow = match_flow
        else:
            self.match_flow = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()
        self_match_flow = self.match_flow
        if self_match_flow is not None:
            self_match_flow._parent = self
        self.match_application = match_application
        self.target_class_id = target_class_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        _match_flow = self.match_flow
        _match_application = self.match_application
        _target_class_id = self.target_class_id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        if _match_flow is not None:
            children['match-flow'] = _match_flow.to_gdata()
        if _match_application is not None:
            children['match-application'] = yang.gdata.Leaf('identityref', _match_application)
        if _target_class_id is not None:
            children['target-class-id'] = yang.gdata.Leaf('string', _target_class_id)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id=n.get_str("id"), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_container("match-flow")), match_application=n.get_opt_str("match-application"), target_class_id=n.get_opt_str("target-class-id"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id=yang.gdata.from_xml_str(n, "id"), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow.from_xml(yang.gdata.get_xml_opt_child(n, "match-flow")), match_application=yang.gdata.from_xml_opt_str(n, "match-application"), target_class_id=yang.gdata.from_xml_opt_str(n, "target-class-id"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'match-flow':
            children['match-flow'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd, rest_path, op)
        if point == 'match-application':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-class-id':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_id_full = jd.get('l3vpn-svc:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(child_id)
    child_match_flow_full = jd.get('l3vpn-svc:match-flow')
    child_match_flow = child_match_flow_full if child_match_flow_full is not None else jd.get('match-flow')
    if child_match_flow is not None and isinstance(child_match_flow, dict):
        children['match-flow'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(child_match_flow)
    child_match_application_full = jd.get('l3vpn-svc:match-application')
    child_match_application = child_match_application_full if child_match_application_full is not None else jd.get('match-application')
    if child_match_application is not None:
        children['match-application'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application(child_match_application)
    child_target_class_id_full = jd.get('l3vpn-svc:target-class-id')
    child_target_class_id = child_target_class_id_full if child_target_class_id_full is not None else jd.get('target-class-id')
    if child_target_class_id is not None:
        children['target-class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id(child_target_class_id)
    return yang.gdata.ListElement([str(child_id if child_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    child_match_flow = n.children.get('match-flow')
    if child_match_flow is not None:
        if isinstance(child_match_flow, yang.gdata.Container):
            children['match-flow'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(child_match_flow)
    child_match_application = n.children.get('match-application')
    if child_match_application is not None:
        if isinstance(child_match_application, yang.gdata.Leaf):
            children['match-application'] = child_match_application.val
    child_target_class_id = n.children.get('target-class-id')
    if child_target_class_id is not None:
        if isinstance(child_target_class_id, yang.gdata.Leaf):
            children['target-class-id'] = child_target_class_id.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(elements=rule)
        self.rule._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rule = self.rule
        if _rule is not None:
            children['rule'] = _rule.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list("rule")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule.from_xml(yang.gdata.get_xml_children(n, "rule")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:rule' or point == 'rule':
            child = {'rule': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rule_full = jd.get('l3vpn-svc:rule')
    child_rule = child_rule_full if child_rule_full is not None else jd.get('rule')
    if child_rule is not None and isinstance(child_rule, list):
        children['rule'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(child_rule)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_rule = n.children.get('rule')
    if child_rule is not None:
        if isinstance(child_rule, yang.gdata.List):
            children['rule'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(child_rule)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("decimal64", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: ?int

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_latency = self.use_lowest_latency
        _latency_boundary = self.latency_boundary
        if _use_lowest_latency is not None:
            children['use-lowest-latency'] = yang.gdata.Leaf('empty', _use_lowest_latency)
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint16', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_bool("use-lowest-latency"), latency_boundary=n.get_opt_int("latency-boundary"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(use_lowest_latency=yang.gdata.from_xml_opt_bool(n, "use-lowest-latency"), latency_boundary=yang.gdata.from_xml_opt_int(n, "latency-boundary"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:use-lowest-latency' or point == 'use-lowest-latency':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:latency-boundary' or point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency_full = jd.get('l3vpn-svc:use-lowest-latency')
    child_use_lowest_latency = child_use_lowest_latency_full if child_use_lowest_latency_full is not None else jd.get('use-lowest-latency')
    if child_use_lowest_latency is not None:
        children['use-lowest-latency'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency(child_use_lowest_latency)
    child_latency_boundary_full = jd.get('l3vpn-svc:latency-boundary')
    child_latency_boundary = child_latency_boundary_full if child_latency_boundary_full is not None else jd.get('latency-boundary')
    if child_latency_boundary is not None:
        children['latency-boundary'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary(child_latency_boundary)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_use_lowest_latency = n.children.get('use-lowest-latency')
    if child_use_lowest_latency is not None:
        if isinstance(child_use_lowest_latency, yang.gdata.Leaf):
            children['use-lowest-latency'] = child_use_lowest_latency.val
    child_latency_boundary = n.children.get('latency-boundary')
    if child_latency_boundary is not None:
        if isinstance(child_latency_boundary, yang.gdata.Leaf):
            children['latency-boundary'] = child_latency_boundary.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: ?int

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_jitter = self.use_lowest_jitter
        _latency_boundary = self.latency_boundary
        if _use_lowest_jitter is not None:
            children['use-lowest-jitter'] = yang.gdata.Leaf('empty', _use_lowest_jitter)
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint32', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_bool("use-lowest-jitter"), latency_boundary=n.get_opt_int("latency-boundary"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=yang.gdata.from_xml_opt_bool(n, "use-lowest-jitter"), latency_boundary=yang.gdata.from_xml_opt_int(n, "latency-boundary"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:use-lowest-jitter' or point == 'use-lowest-jitter':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:latency-boundary' or point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter_full = jd.get('l3vpn-svc:use-lowest-jitter')
    child_use_lowest_jitter = child_use_lowest_jitter_full if child_use_lowest_jitter_full is not None else jd.get('use-lowest-jitter')
    if child_use_lowest_jitter is not None:
        children['use-lowest-jitter'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(child_use_lowest_jitter)
    child_latency_boundary_full = jd.get('l3vpn-svc:latency-boundary')
    child_latency_boundary = child_latency_boundary_full if child_latency_boundary_full is not None else jd.get('latency-boundary')
    if child_latency_boundary is not None:
        children['latency-boundary'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary(child_latency_boundary)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_use_lowest_jitter = n.children.get('use-lowest-jitter')
    if child_use_lowest_jitter is not None:
        if isinstance(child_use_lowest_jitter, yang.gdata.Leaf):
            children['use-lowest-jitter'] = child_use_lowest_jitter.val
    child_latency_boundary = n.children.get('latency-boundary')
    if child_latency_boundary is not None:
        if isinstance(child_latency_boundary, yang.gdata.Leaf):
            children['latency-boundary'] = child_latency_boundary.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("decimal64", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: ?float
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: ?float, end_to_end: ?bool):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _guaranteed_bw_percent = self.guaranteed_bw_percent
        _end_to_end = self.end_to_end
        if _guaranteed_bw_percent is not None:
            children['guaranteed-bw-percent'] = yang.gdata.Leaf('decimal64', _guaranteed_bw_percent)
        if _end_to_end is not None:
            children['end-to-end'] = yang.gdata.Leaf('empty', _end_to_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_opt_float("guaranteed-bw-percent"), end_to_end=n.get_opt_bool("end-to-end"))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth")

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=yang.gdata.from_xml_opt_float(n, "guaranteed-bw-percent"), end_to_end=yang.gdata.from_xml_opt_bool(n, "end-to-end"))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth")


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:guaranteed-bw-percent' or point == 'guaranteed-bw-percent':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:end-to-end' or point == 'end-to-end':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent_full = jd.get('l3vpn-svc:guaranteed-bw-percent')
    child_guaranteed_bw_percent = child_guaranteed_bw_percent_full if child_guaranteed_bw_percent_full is not None else jd.get('guaranteed-bw-percent')
    if child_guaranteed_bw_percent is not None:
        children['guaranteed-bw-percent'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(child_guaranteed_bw_percent)
    child_end_to_end_full = jd.get('l3vpn-svc:end-to-end')
    child_end_to_end = child_end_to_end_full if child_end_to_end_full is not None else jd.get('end-to-end')
    if child_end_to_end is not None:
        children['end-to-end'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end(child_end_to_end)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_guaranteed_bw_percent = n.children.get('guaranteed-bw-percent')
    if child_guaranteed_bw_percent is not None:
        if isinstance(child_guaranteed_bw_percent, yang.gdata.Leaf):
            children['guaranteed-bw-percent'] = child_guaranteed_bw_percent.val
    child_end_to_end = n.children.get('end-to-end')
    if child_end_to_end is not None:
        if isinstance(child_end_to_end, yang.gdata.Leaf):
            children['end-to-end'] = child_end_to_end.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: ?str
    rate_limit: ?float
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, direction: ?str, rate_limit: ?float, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter=None, bandwidth: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.class_id = class_id
        self.direction = direction
        self.rate_limit = rate_limit
        if latency is not None:
            self.latency = latency
        else:
            self.latency = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()
        self_latency = self.latency
        if self_latency is not None:
            self_latency._parent = self
        if jitter is not None:
            self.jitter = jitter
        else:
            self.jitter = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()
        self_jitter = self.jitter
        if self_jitter is not None:
            self_jitter._parent = self
        if bandwidth is not None:
            self.bandwidth = bandwidth
        else:
            self.bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth()
        self_bandwidth = self.bandwidth
        if self_bandwidth is not None:
            self_bandwidth._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_id = self.class_id
        _direction = self.direction
        _rate_limit = self.rate_limit
        _latency = self.latency
        _jitter = self.jitter
        _bandwidth = self.bandwidth
        if _class_id is not None:
            children['class-id'] = yang.gdata.Leaf('string', _class_id)
        if _direction is not None:
            children['direction'] = yang.gdata.Leaf('identityref', _direction)
        if _rate_limit is not None:
            children['rate-limit'] = yang.gdata.Leaf('decimal64', _rate_limit)
        if _latency is not None:
            children['latency'] = _latency.to_gdata()
        if _jitter is not None:
            children['jitter'] = _jitter.to_gdata()
        if _bandwidth is not None:
            children['bandwidth'] = _bandwidth.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.class_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id=n.get_str("class-id"), direction=n.get_opt_str("direction"), rate_limit=n.get_opt_float("rate-limit"), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_container("latency")), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_container("jitter")), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_opt_container("bandwidth")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id=yang.gdata.from_xml_str(n, "class-id"), direction=yang.gdata.from_xml_opt_str(n, "direction"), rate_limit=yang.gdata.from_xml_opt_float(n, "rate-limit"), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency.from_xml(yang.gdata.get_xml_opt_child(n, "latency")), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter.from_xml(yang.gdata.get_xml_opt_child(n, "jitter")), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth.from_xml(yang.gdata.get_xml_opt_child(n, "bandwidth")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id):
        for e in self.elements:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['class-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['class-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'direction':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rate-limit':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency':
            children['latency'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd, rest_path, op)
        if point == 'jitter':
            children['jitter'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd, rest_path, op)
        if point == 'bandwidth':
            children['bandwidth'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['class-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['class-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['class-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_class_id_full = jd.get('l3vpn-svc:class-id')
    child_class_id = child_class_id_full if child_class_id_full is not None else jd.get('class-id')
    if child_class_id is not None:
        children['class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(child_class_id)
    child_direction_full = jd.get('l3vpn-svc:direction')
    child_direction = child_direction_full if child_direction_full is not None else jd.get('direction')
    if child_direction is not None:
        children['direction'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction(child_direction)
    child_rate_limit_full = jd.get('l3vpn-svc:rate-limit')
    child_rate_limit = child_rate_limit_full if child_rate_limit_full is not None else jd.get('rate-limit')
    if child_rate_limit is not None:
        children['rate-limit'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit(child_rate_limit)
    child_latency_full = jd.get('l3vpn-svc:latency')
    child_latency = child_latency_full if child_latency_full is not None else jd.get('latency')
    if child_latency is not None and isinstance(child_latency, dict):
        children['latency'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(child_latency)
    child_jitter_full = jd.get('l3vpn-svc:jitter')
    child_jitter = child_jitter_full if child_jitter_full is not None else jd.get('jitter')
    if child_jitter is not None and isinstance(child_jitter, dict):
        children['jitter'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(child_jitter)
    child_bandwidth_full = jd.get('l3vpn-svc:bandwidth')
    child_bandwidth = child_bandwidth_full if child_bandwidth_full is not None else jd.get('bandwidth')
    if child_bandwidth is not None and isinstance(child_bandwidth, dict):
        children['bandwidth'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(child_bandwidth)
    return yang.gdata.ListElement([str(child_class_id if child_class_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(e))
    return yang.gdata.List(keys=['class-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_class_id = n.children.get('class-id')
    if child_class_id is not None:
        if isinstance(child_class_id, yang.gdata.Leaf):
            children['class-id'] = child_class_id.val
    child_direction = n.children.get('direction')
    if child_direction is not None:
        if isinstance(child_direction, yang.gdata.Leaf):
            children['direction'] = child_direction.val
    child_rate_limit = n.children.get('rate-limit')
    if child_rate_limit is not None:
        if isinstance(child_rate_limit, yang.gdata.Leaf):
            children['rate-limit'] = child_rate_limit.val
    child_latency = n.children.get('latency')
    if child_latency is not None:
        if isinstance(child_latency, yang.gdata.Container):
            children['latency'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(child_latency)
    child_jitter = n.children.get('jitter')
    if child_jitter is not None:
        if isinstance(child_jitter, yang.gdata.Container):
            children['jitter'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(child_jitter)
    child_bandwidth = n.children.get('bandwidth')
    if child_bandwidth is not None:
        if isinstance(child_bandwidth, yang.gdata.Container):
            children['bandwidth'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(child_bandwidth)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(elements=class_)
        self.class_._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_ = self.class_
        if _class_ is not None:
            children['class'] = _class_.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list("class")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class.from_xml(yang.gdata.get_xml_children(n, "class")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:class' or point == 'class':
            child = {'class': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_class__full = jd.get('l3vpn-svc:class')
    child_class_ = child_class__full if child_class__full is not None else jd.get('class')
    if child_class_ is not None and isinstance(child_class_, list):
        children['class'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(child_class_)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_class_ = n.children.get('class')
    if child_class_ is not None:
        if isinstance(child_class_, yang.gdata.List):
            children['class'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(child_class_)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.profile = profile
        if classes is not None:
            self.classes = classes
        else:
            self.classes = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()
        self_classes = self.classes
        if self_classes is not None:
            self_classes._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile = self.profile
        _classes = self.classes
        if _profile is not None:
            children['profile'] = yang.gdata.Leaf('leafref', _profile)
        if _classes is not None:
            children['classes'] = _classes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(profile=n.get_opt_str("profile"), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes.from_gdata(n.get_opt_container("classes")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(profile=yang.gdata.from_xml_opt_str(n, "profile"), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes.from_xml(yang.gdata.get_xml_opt_child(n, "classes")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:profile' or point == 'profile':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:classes' or point == 'classes':
            child = {'classes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_full = jd.get('l3vpn-svc:profile')
    child_profile = child_profile_full if child_profile_full is not None else jd.get('profile')
    if child_profile is not None:
        children['profile'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile(child_profile)
    child_classes_full = jd.get('l3vpn-svc:classes')
    child_classes = child_classes_full if child_classes_full is not None else jd.get('classes')
    if child_classes is not None and isinstance(child_classes, dict):
        children['classes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(child_classes)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_profile = n.children.get('profile')
    if child_profile is not None:
        if isinstance(child_profile, yang.gdata.Leaf):
            children['profile'] = child_profile.val
    child_classes = n.children.get('classes')
    if child_classes is not None:
        if isinstance(child_classes, yang.gdata.Container):
            children['classes'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(child_classes)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if qos_classification_policy is not None:
            self.qos_classification_policy = qos_classification_policy
        else:
            self.qos_classification_policy = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()
        self_qos_classification_policy = self.qos_classification_policy
        if self_qos_classification_policy is not None:
            self_qos_classification_policy._parent = self
        if qos_profile is not None:
            self.qos_profile = qos_profile
        else:
            self.qos_profile = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()
        self_qos_profile = self.qos_profile
        if self_qos_profile is not None:
            self_qos_profile._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos_classification_policy = self.qos_classification_policy
        _qos_profile = self.qos_profile
        if _qos_classification_policy is not None:
            children['qos-classification-policy'] = _qos_classification_policy.to_gdata()
        if _qos_profile is not None:
            children['qos-profile'] = _qos_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy.from_gdata(n.get_opt_container("qos-classification-policy")), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile.from_gdata(n.get_opt_container("qos-profile")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy.from_xml(yang.gdata.get_xml_opt_child(n, "qos-classification-policy")), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile.from_xml(yang.gdata.get_xml_opt_child(n, "qos-profile")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:qos-classification-policy' or point == 'qos-classification-policy':
            child = {'qos-classification-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:qos-profile' or point == 'qos-profile':
            child = {'qos-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy_full = jd.get('l3vpn-svc:qos-classification-policy')
    child_qos_classification_policy = child_qos_classification_policy_full if child_qos_classification_policy_full is not None else jd.get('qos-classification-policy')
    if child_qos_classification_policy is not None and isinstance(child_qos_classification_policy, dict):
        children['qos-classification-policy'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(child_qos_classification_policy)
    child_qos_profile_full = jd.get('l3vpn-svc:qos-profile')
    child_qos_profile = child_qos_profile_full if child_qos_profile_full is not None else jd.get('qos-profile')
    if child_qos_profile is not None and isinstance(child_qos_profile, dict):
        children['qos-profile'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(child_qos_profile)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_qos_classification_policy = n.children.get('qos-classification-policy')
    if child_qos_classification_policy is not None:
        if isinstance(child_qos_classification_policy, yang.gdata.Container):
            children['qos-classification-policy'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(child_qos_classification_policy)
    child_qos_profile = n.children.get('qos-profile')
    if child_qos_profile is not None:
        if isinstance(child_qos_profile, yang.gdata.Container):
            children['qos-profile'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(child_qos_profile)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(yang.adata.MNode):
    signalling_type: ?str

    mut def __init__(self, signalling_type: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.signalling_type = signalling_type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            children['signalling-type'] = yang.gdata.Leaf('enumeration', _signalling_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(signalling_type=n.get_opt_str("signalling-type"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(signalling_type=yang.gdata.from_xml_opt_str(n, "signalling-type"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:signalling-type' or point == 'signalling-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_signalling_type_full = jd.get('l3vpn-svc:signalling-type')
    child_signalling_type = child_signalling_type_full if child_signalling_type_full is not None else jd.get('signalling-type')
    if child_signalling_type is not None:
        children['signalling-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type(child_signalling_type)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_signalling_type = n.children.get('signalling-type')
    if child_signalling_type is not None:
        if isinstance(child_signalling_type, yang.gdata.Leaf):
            children['signalling-type'] = child_signalling_type.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: ?bool
    ipv6: ?bool

    mut def __init__(self, ipv4: ?bool, ipv6: ?bool):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.ipv4 = ipv4
        self.ipv6 = ipv6

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        _ipv6 = self.ipv6
        if _ipv4 is not None:
            children['ipv4'] = yang.gdata.Leaf('boolean', _ipv4)
        if _ipv6 is not None:
            children['ipv6'] = yang.gdata.Leaf('boolean', _ipv6)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(ipv4=n.get_opt_bool("ipv4"), ipv6=n.get_opt_bool("ipv6"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(ipv4=yang.gdata.from_xml_opt_bool(n, "ipv4"), ipv6=yang.gdata.from_xml_opt_bool(n, "ipv6"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:ipv4' or point == 'ipv4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv6' or point == 'ipv6':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_full = jd.get('l3vpn-svc:ipv4')
    child_ipv4 = child_ipv4_full if child_ipv4_full is not None else jd.get('ipv4')
    if child_ipv4 is not None:
        children['ipv4'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4(child_ipv4)
    child_ipv6_full = jd.get('l3vpn-svc:ipv6')
    child_ipv6 = child_ipv6_full if child_ipv6_full is not None else jd.get('ipv6')
    if child_ipv6 is not None:
        children['ipv6'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6(child_ipv6)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_ipv4 = n.children.get('ipv4')
    if child_ipv4 is not None:
        if isinstance(child_ipv4, yang.gdata.Leaf):
            children['ipv4'] = child_ipv4.val
    child_ipv6 = n.children.get('ipv6')
    if child_ipv6 is not None:
        if isinstance(child_ipv6, yang.gdata.Leaf):
            children['ipv6'] = child_ipv6.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(yang.adata.MNode):
    multicast_site_type: ?str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family
    protocol_type: ?str

    mut def __init__(self, multicast_site_type: ?str, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family=None, protocol_type: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.multicast_site_type = multicast_site_type
        if multicast_address_family is not None:
            self.multicast_address_family = multicast_address_family
        else:
            self.multicast_address_family = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()
        self_multicast_address_family = self.multicast_address_family
        if self_multicast_address_family is not None:
            self_multicast_address_family._parent = self
        self.protocol_type = protocol_type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _multicast_site_type = self.multicast_site_type
        _multicast_address_family = self.multicast_address_family
        _protocol_type = self.protocol_type
        if _multicast_site_type is not None:
            children['multicast-site-type'] = yang.gdata.Leaf('enumeration', _multicast_site_type)
        if _multicast_address_family is not None:
            children['multicast-address-family'] = _multicast_address_family.to_gdata()
        if _protocol_type is not None:
            children['protocol-type'] = yang.gdata.Leaf('enumeration', _protocol_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(multicast_site_type=n.get_opt_str("multicast-site-type"), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family.from_gdata(n.get_opt_container("multicast-address-family")), protocol_type=n.get_opt_str("protocol-type"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(multicast_site_type=yang.gdata.from_xml_opt_str(n, "multicast-site-type"), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family.from_xml(yang.gdata.get_xml_opt_child(n, "multicast-address-family")), protocol_type=yang.gdata.from_xml_opt_str(n, "protocol-type"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:multicast-site-type' or point == 'multicast-site-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:multicast-address-family' or point == 'multicast-address-family':
            child = {'multicast-address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:protocol-type' or point == 'protocol-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type_full = jd.get('l3vpn-svc:multicast-site-type')
    child_multicast_site_type = child_multicast_site_type_full if child_multicast_site_type_full is not None else jd.get('multicast-site-type')
    if child_multicast_site_type is not None:
        children['multicast-site-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type(child_multicast_site_type)
    child_multicast_address_family_full = jd.get('l3vpn-svc:multicast-address-family')
    child_multicast_address_family = child_multicast_address_family_full if child_multicast_address_family_full is not None else jd.get('multicast-address-family')
    if child_multicast_address_family is not None and isinstance(child_multicast_address_family, dict):
        children['multicast-address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(child_multicast_address_family)
    child_protocol_type_full = jd.get('l3vpn-svc:protocol-type')
    child_protocol_type = child_protocol_type_full if child_protocol_type_full is not None else jd.get('protocol-type')
    if child_protocol_type is not None:
        children['protocol-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type(child_protocol_type)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_multicast_site_type = n.children.get('multicast-site-type')
    if child_multicast_site_type is not None:
        if isinstance(child_multicast_site_type, yang.gdata.Leaf):
            children['multicast-site-type'] = child_multicast_site_type.val
    child_multicast_address_family = n.children.get('multicast-address-family')
    if child_multicast_address_family is not None:
        if isinstance(child_multicast_address_family, yang.gdata.Container):
            children['multicast-address-family'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(child_multicast_address_family)
    child_protocol_type = n.children.get('protocol-type')
    if child_protocol_type is not None:
        if isinstance(child_protocol_type, yang.gdata.Leaf):
            children['protocol-type'] = child_protocol_type.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service(yang.adata.MNode):
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast

    mut def __init__(self, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if qos is not None:
            self.qos = qos
        else:
            self.qos = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()
        self_qos = self.qos
        if self_qos is not None:
            self_qos._parent = self
        if carrierscarrier is not None:
            self.carrierscarrier = carrierscarrier
        else:
            self.carrierscarrier = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()
        self_carrierscarrier = self.carrierscarrier
        if self_carrierscarrier is not None:
            self_carrierscarrier._parent = self
        if multicast is not None:
            self.multicast = multicast
        else:
            self.multicast = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()
        self_multicast = self.multicast
        if self_multicast is not None:
            self_multicast._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos = self.qos
        _carrierscarrier = self.carrierscarrier
        _multicast = self.multicast
        if _qos is not None:
            children['qos'] = _qos.to_gdata()
        if _carrierscarrier is not None:
            children['carrierscarrier'] = _carrierscarrier.to_gdata()
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service(qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos.from_gdata(n.get_opt_container("qos")), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier.from_gdata(n.get_opt_container("carrierscarrier")), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast.from_gdata(n.get_opt_container("multicast")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service(qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos.from_xml(yang.gdata.get_xml_opt_child(n, "qos")), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier.from_xml(yang.gdata.get_xml_opt_child(n, "carrierscarrier")), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast.from_xml(yang.gdata.get_xml_opt_child(n, "multicast")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:qos' or point == 'qos':
            child = {'qos': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:carrierscarrier' or point == 'carrierscarrier':
            child = {'carrierscarrier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:multicast' or point == 'multicast':
            child = {'multicast': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos_full = jd.get('l3vpn-svc:qos')
    child_qos = child_qos_full if child_qos_full is not None else jd.get('qos')
    if child_qos is not None and isinstance(child_qos, dict):
        children['qos'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(child_qos)
    child_carrierscarrier_full = jd.get('l3vpn-svc:carrierscarrier')
    child_carrierscarrier = child_carrierscarrier_full if child_carrierscarrier_full is not None else jd.get('carrierscarrier')
    if child_carrierscarrier is not None and isinstance(child_carrierscarrier, dict):
        children['carrierscarrier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(child_carrierscarrier)
    child_multicast_full = jd.get('l3vpn-svc:multicast')
    child_multicast = child_multicast_full if child_multicast_full is not None else jd.get('multicast')
    if child_multicast is not None and isinstance(child_multicast, dict):
        children['multicast'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(child_multicast)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_qos = n.children.get('qos')
    if child_qos is not None:
        if isinstance(child_qos, yang.gdata.Container):
            children['qos'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(child_qos)
    child_carrierscarrier = n.children.get('carrierscarrier')
    if child_carrierscarrier is not None:
        if isinstance(child_carrierscarrier, yang.gdata.Container):
            children['carrierscarrier'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(child_carrierscarrier)
    child_multicast = n.children.get('multicast')
    if child_multicast is not None:
        if isinstance(child_multicast, yang.gdata.Container):
            children['multicast'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(child_multicast)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(yang.adata.MNode):
    enabled: ?bool

    mut def __init__(self, enabled: ?bool):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.enabled = enabled

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(enabled=n.get_opt_bool("enabled"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(enabled=yang.gdata.from_xml_opt_bool(n, "enabled"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:enabled' or point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled_full = jd.get('l3vpn-svc:enabled')
    child_enabled = child_enabled_full if child_enabled_full is not None else jd.get('enabled')
    if child_enabled is not None:
        children['enabled'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled(child_enabled)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_enabled = n.children.get('enabled')
    if child_enabled is not None:
        if isinstance(child_enabled, yang.gdata.Leaf):
            children['enabled'] = child_enabled.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: ?int

    mut def __init__(self, target_site: str, metric: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.target_site = target_site
        self.metric = metric

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _target_site = self.target_site
        _metric = self.metric
        if _target_site is not None:
            children['target-site'] = yang.gdata.Leaf('string', _target_site)
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.target_site)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str("target-site"), metric=n.get_opt_int("metric"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=yang.gdata.from_xml_str(n, "target-site"), metric=yang.gdata.from_xml_opt_int(n, "metric"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self.elements:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['target-site'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['target-site']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['target-site']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['target-site'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['target-site'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_target_site_full = jd.get('l3vpn-svc:target-site')
    child_target_site = child_target_site_full if child_target_site_full is not None else jd.get('target-site')
    if child_target_site is not None:
        children['target-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(child_target_site)
    child_metric_full = jd.get('l3vpn-svc:metric')
    child_metric = child_metric_full if child_metric_full is not None else jd.get('metric')
    if child_metric is not None:
        children['metric'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(child_metric)
    return yang.gdata.ListElement([str(child_target_site if child_target_site is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e))
    return yang.gdata.List(keys=['target-site'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_target_site = n.children.get('target-site')
    if child_target_site is not None:
        if isinstance(child_target_site, yang.gdata.Leaf):
            children['target-site'] = child_target_site.val
    child_metric = n.children.get('metric')
    if child_metric is not None:
        if isinstance(child_metric, yang.gdata.Leaf):
            children['metric'] = child_metric.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)
        self.sham_link._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sham_link = self.sham_link
        if _sham_link is not None:
            children['sham-link'] = _sham_link.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list("sham-link")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_xml(yang.gdata.get_xml_children(n, "sham-link")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:sham-link' or point == 'sham-link':
            child = {'sham-link': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_sham_link_full = jd.get('l3vpn-svc:sham-link')
    child_sham_link = child_sham_link_full if child_sham_link_full is not None else jd.get('sham-link')
    if child_sham_link is not None and isinstance(child_sham_link, list):
        children['sham-link'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(child_sham_link)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_sham_link = n.children.get('sham-link')
    if child_sham_link is not None:
        if isinstance(child_sham_link, yang.gdata.List):
            children['sham-link'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(child_sham_link)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: ?str
    metric: ?int
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, address_family: ?list[str]=None, area_address: ?str, metric: ?int, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if address_family is not None:
            self.address_family = address_family
        else:
            self.address_family = []
        self.area_address = area_address
        self.metric = metric
        if sham_links is not None:
            self.sham_links = sham_links
        else:
            self.sham_links = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()
        self_sham_links = self.sham_links
        if self_sham_links is not None:
            self_sham_links._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _area_address = self.area_address
        _metric = self.metric
        _sham_links = self.sham_links
        children['address-family'] = yang.gdata.LeafList(self.address_family)
        if _area_address is not None:
            children['area-address'] = yang.gdata.Leaf('string', _area_address)
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        if _sham_links is not None:
            children['sham-links'] = _sham_links.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(address_family=n.get_opt_strs("address-family"), area_address=n.get_opt_str("area-address"), metric=n.get_opt_int("metric"), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_container("sham-links")))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(address_family=yang.gdata.from_xml_opt_strs(n, "address-family"), area_address=yang.gdata.from_xml_opt_str(n, "area-address"), metric=yang.gdata.from_xml_opt_int(n, "metric"), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links.from_xml(yang.gdata.get_xml_opt_child(n, "sham-links")))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:area-address' or point == 'area-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:metric' or point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:sham-links' or point == 'sham-links':
            child = {'sham-links': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, list):
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family(child_address_family)
    child_area_address_full = jd.get('l3vpn-svc:area-address')
    child_area_address = child_area_address_full if child_area_address_full is not None else jd.get('area-address')
    if child_area_address is not None:
        children['area-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address(child_area_address)
    child_metric_full = jd.get('l3vpn-svc:metric')
    child_metric = child_metric_full if child_metric_full is not None else jd.get('metric')
    if child_metric is not None:
        children['metric'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric(child_metric)
    child_sham_links_full = jd.get('l3vpn-svc:sham-links')
    child_sham_links = child_sham_links_full if child_sham_links_full is not None else jd.get('sham-links')
    if child_sham_links is not None and isinstance(child_sham_links, dict):
        children['sham-links'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(child_sham_links)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.LeafList):
            children['address-family'] = child_address_family.vals
    child_area_address = n.children.get('area-address')
    if child_area_address is not None:
        if isinstance(child_area_address, yang.gdata.Leaf):
            children['area-address'] = child_area_address.val
    child_metric = n.children.get('metric')
    if child_metric is not None:
        if isinstance(child_metric, yang.gdata.Leaf):
            children['metric'] = child_metric.val
    child_sham_links = n.children.get('sham-links')
    if child_sham_links is not None:
        if isinstance(child_sham_links, yang.gdata.Container):
            children['sham-links'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(child_sham_links)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: ?int
    address_family: list[str]

    mut def __init__(self, autonomous_system: ?int, address_family: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.autonomous_system = autonomous_system
        if address_family is not None:
            self.address_family = address_family
        else:
            self.address_family = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            children['autonomous-system'] = yang.gdata.Leaf('uint32', _autonomous_system)
        children['address-family'] = yang.gdata.LeafList(self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_opt_int("autonomous-system"), address_family=n.get_opt_strs("address-family"))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system=yang.gdata.from_xml_opt_int(n, "autonomous-system"), address_family=yang.gdata.from_xml_opt_strs(n, "address-family"))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:autonomous-system' or point == 'autonomous-system':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_autonomous_system_full = jd.get('l3vpn-svc:autonomous-system')
    child_autonomous_system = child_autonomous_system_full if child_autonomous_system_full is not None else jd.get('autonomous-system')
    if child_autonomous_system is not None:
        children['autonomous-system'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system(child_autonomous_system)
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, list):
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family(child_address_family)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_autonomous_system = n.children.get('autonomous-system')
    if child_autonomous_system is not None:
        if isinstance(child_autonomous_system, yang.gdata.Leaf):
            children['autonomous-system'] = child_autonomous_system.val
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.LeafList):
            children['address-family'] = child_address_family.vals
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        _next_hop = self.next_hop
        _lan_tag = self.lan_tag
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.lan), yang.gdata.yang_str(self.next_hop)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str("lan"), next_hop=n.get_str("next-hop"), lan_tag=n.get_opt_str("lan-tag"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=yang.gdata.from_xml_str(n, "lan"), next_hop=yang.gdata.from_xml_str(n, "next-hop"), lan_tag=yang.gdata.from_xml_opt_str(n, "lan-tag"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['lan', 'next-hop']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_lan_full = jd.get('l3vpn-svc:lan')
    child_lan = child_lan_full if child_lan_full is not None else jd.get('lan')
    if child_lan is not None:
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(child_lan)
    child_next_hop_full = jd.get('l3vpn-svc:next-hop')
    child_next_hop = child_next_hop_full if child_next_hop_full is not None else jd.get('next-hop')
    if child_next_hop is not None:
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(child_next_hop)
    child_lan_tag_full = jd.get('l3vpn-svc:lan-tag')
    child_lan_tag = child_lan_tag_full if child_lan_tag_full is not None else jd.get('lan-tag')
    if child_lan_tag is not None:
        children['lan-tag'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(child_lan_tag)
    return yang.gdata.ListElement([str(child_lan if child_lan is not None else ""), str(child_next_hop if child_next_hop is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e))
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_lan = n.children.get('lan')
    if child_lan is not None:
        if isinstance(child_lan, yang.gdata.Leaf):
            children['lan'] = child_lan.val
    child_next_hop = n.children.get('next-hop')
    if child_next_hop is not None:
        if isinstance(child_next_hop, yang.gdata.Leaf):
            children['next-hop'] = child_next_hop.val
    child_lan_tag = n.children.get('lan-tag')
    if child_lan_tag is not None:
        if isinstance(child_lan_tag, yang.gdata.Leaf):
            children['lan-tag'] = child_lan_tag.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e))
    return elements

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        _next_hop = self.next_hop
        _lan_tag = self.lan_tag
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.lan), yang.gdata.yang_str(self.next_hop)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str("lan"), next_hop=n.get_str("next-hop"), lan_tag=n.get_opt_str("lan-tag"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=yang.gdata.from_xml_str(n, "lan"), next_hop=yang.gdata.from_xml_str(n, "next-hop"), lan_tag=yang.gdata.from_xml_opt_str(n, "lan-tag"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['lan', 'next-hop']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_lan_full = jd.get('l3vpn-svc:lan')
    child_lan = child_lan_full if child_lan_full is not None else jd.get('lan')
    if child_lan is not None:
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(child_lan)
    child_next_hop_full = jd.get('l3vpn-svc:next-hop')
    child_next_hop = child_next_hop_full if child_next_hop_full is not None else jd.get('next-hop')
    if child_next_hop is not None:
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(child_next_hop)
    child_lan_tag_full = jd.get('l3vpn-svc:lan-tag')
    child_lan_tag = child_lan_tag_full if child_lan_tag_full is not None else jd.get('lan-tag')
    if child_lan_tag is not None:
        children['lan-tag'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(child_lan_tag)
    return yang.gdata.ListElement([str(child_lan if child_lan is not None else ""), str(child_next_hop if child_next_hop is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e))
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_lan = n.children.get('lan')
    if child_lan is not None:
        if isinstance(child_lan, yang.gdata.Leaf):
            children['lan'] = child_lan.val
    child_next_hop = n.children.get('next-hop')
    if child_next_hop is not None:
        if isinstance(child_next_hop, yang.gdata.Leaf):
            children['next-hop'] = child_next_hop.val
    child_lan_tag = n.children.get('lan-tag')
    if child_lan_tag is not None:
        if isinstance(child_lan_tag, yang.gdata.Leaf):
            children['lan-tag'] = child_lan_tag.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv4_lan_prefixes._parent = self
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)
        self.ipv6_lan_prefixes._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        if _ipv4_lan_prefixes is not None:
            children['ipv4-lan-prefixes'] = _ipv4_lan_prefixes.to_gdata()
        if _ipv6_lan_prefixes is not None:
            children['ipv6-lan-prefixes'] = _ipv6_lan_prefixes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list("ipv4-lan-prefixes")), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list("ipv6-lan-prefixes")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_xml(yang.gdata.get_xml_children(n, "ipv4-lan-prefixes")), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_xml(yang.gdata.get_xml_children(n, "ipv6-lan-prefixes")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:ipv4-lan-prefixes' or point == 'ipv4-lan-prefixes':
            child = {'ipv4-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:ipv6-lan-prefixes' or point == 'ipv6-lan-prefixes':
            child = {'ipv6-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes_full = jd.get('l3vpn-svc:ipv4-lan-prefixes')
    child_ipv4_lan_prefixes = child_ipv4_lan_prefixes_full if child_ipv4_lan_prefixes_full is not None else jd.get('ipv4-lan-prefixes')
    if child_ipv4_lan_prefixes is not None and isinstance(child_ipv4_lan_prefixes, list):
        children['ipv4-lan-prefixes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes_full = jd.get('l3vpn-svc:ipv6-lan-prefixes')
    child_ipv6_lan_prefixes = child_ipv6_lan_prefixes_full if child_ipv6_lan_prefixes_full is not None else jd.get('ipv6-lan-prefixes')
    if child_ipv6_lan_prefixes is not None and isinstance(child_ipv6_lan_prefixes, list):
        children['ipv6-lan-prefixes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_ipv4_lan_prefixes = n.children.get('ipv4-lan-prefixes')
    if child_ipv4_lan_prefixes is not None:
        if isinstance(child_ipv4_lan_prefixes, yang.gdata.List):
            children['ipv4-lan-prefixes'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = n.children.get('ipv6-lan-prefixes')
    if child_ipv6_lan_prefixes is not None:
        if isinstance(child_ipv6_lan_prefixes, yang.gdata.List):
            children['ipv6-lan-prefixes'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(child_ipv6_lan_prefixes)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if cascaded_lan_prefixes is not None:
            self.cascaded_lan_prefixes = cascaded_lan_prefixes
        else:
            self.cascaded_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()
        self_cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if self_cascaded_lan_prefixes is not None:
            self_cascaded_lan_prefixes._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            children['cascaded-lan-prefixes'] = _cascaded_lan_prefixes.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_container("cascaded-lan-prefixes")))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_xml(yang.gdata.get_xml_opt_child(n, "cascaded-lan-prefixes")))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:cascaded-lan-prefixes' or point == 'cascaded-lan-prefixes':
            child = {'cascaded-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes_full = jd.get('l3vpn-svc:cascaded-lan-prefixes')
    child_cascaded_lan_prefixes = child_cascaded_lan_prefixes_full if child_cascaded_lan_prefixes_full is not None else jd.get('cascaded-lan-prefixes')
    if child_cascaded_lan_prefixes is not None and isinstance(child_cascaded_lan_prefixes, dict):
        children['cascaded-lan-prefixes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(child_cascaded_lan_prefixes)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_cascaded_lan_prefixes = n.children.get('cascaded-lan-prefixes')
    if child_cascaded_lan_prefixes is not None:
        if isinstance(child_cascaded_lan_prefixes, yang.gdata.Container):
            children['cascaded-lan-prefixes'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(child_cascaded_lan_prefixes)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if address_family is not None:
            self.address_family = address_family
        else:
            self.address_family = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList(self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(address_family=n.get_opt_strs("address-family"))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(address_family=yang.gdata.from_xml_opt_strs(n, "address-family"))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, list):
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family(child_address_family)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.LeafList):
            children['address-family'] = child_address_family.vals
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if address_family is not None:
            self.address_family = address_family
        else:
            self.address_family = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList(self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(address_family=n.get_opt_strs("address-family"))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(address_family=yang.gdata.from_xml_opt_strs(n, "address-family"))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, list):
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family(child_address_family)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.LeafList):
            children['address-family'] = child_address_family.vals
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: str
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: str, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.type = type
        self.ospf = ospf
        self_ospf = self.ospf
        if self_ospf is not None:
            self_ospf._parent = self
        self.bgp = bgp
        self_bgp = self.bgp
        if self_bgp is not None:
            self_bgp._parent = self
        self.static = static
        self_static = self.static
        if self_static is not None:
            self_static._parent = self
        self.rip = rip
        self_rip = self.rip
        if self_rip is not None:
            self_rip._parent = self
        self.vrrp = vrrp
        self_vrrp = self.vrrp
        if self_vrrp is not None:
            self_vrrp._parent = self

    mut def create_ospf(self, area_address):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        _ospf = self.ospf
        _bgp = self.bgp
        _static = self.static
        _rip = self.rip
        _vrrp = self.vrrp
        if _type is not None:
            children['type'] = yang.gdata.Leaf('identityref', _type)
        if _ospf is not None:
            children['ospf'] = _ospf.to_gdata()
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        if _static is not None:
            children['static'] = _static.to_gdata()
        if _rip is not None:
            children['rip'] = _rip.to_gdata()
        if _vrrp is not None:
            children['vrrp'] = _vrrp.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.type)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type=n.get_str("type"), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_container("ospf")), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_container("bgp")), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_container("static")), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_container("rip")), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_container("vrrp")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type=yang.gdata.from_xml_str(n, "type"), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.from_xml(yang.gdata.get_xml_opt_child(n, "ospf")), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.from_xml(yang.gdata.get_xml_opt_child(n, "bgp")), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.from_xml(yang.gdata.get_xml_opt_child(n, "static")), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.from_xml(yang.gdata.get_xml_opt_child(n, "rip")), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.from_xml(yang.gdata.get_xml_opt_child(n, "vrrp")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self.elements:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['type']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'ospf':
            children['ospf'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd, rest_path, op)
        if point == 'bgp':
            children['bgp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd, rest_path, op)
        if point == 'static':
            children['static'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd, rest_path, op)
        if point == 'rip':
            children['rip'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd, rest_path, op)
        if point == 'vrrp':
            children['vrrp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_type_full = jd.get('l3vpn-svc:type')
    child_type = child_type_full if child_type_full is not None else jd.get('type')
    if child_type is not None:
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(child_type)
    child_ospf_full = jd.get('l3vpn-svc:ospf')
    child_ospf = child_ospf_full if child_ospf_full is not None else jd.get('ospf')
    if child_ospf is not None and isinstance(child_ospf, dict):
        children['ospf'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(child_ospf)
    child_bgp_full = jd.get('l3vpn-svc:bgp')
    child_bgp = child_bgp_full if child_bgp_full is not None else jd.get('bgp')
    if child_bgp is not None and isinstance(child_bgp, dict):
        children['bgp'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(child_bgp)
    child_static_full = jd.get('l3vpn-svc:static')
    child_static = child_static_full if child_static_full is not None else jd.get('static')
    if child_static is not None and isinstance(child_static, dict):
        children['static'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(child_static)
    child_rip_full = jd.get('l3vpn-svc:rip')
    child_rip = child_rip_full if child_rip_full is not None else jd.get('rip')
    if child_rip is not None and isinstance(child_rip, dict):
        children['rip'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(child_rip)
    child_vrrp_full = jd.get('l3vpn-svc:vrrp')
    child_vrrp = child_vrrp_full if child_vrrp_full is not None else jd.get('vrrp')
    if child_vrrp is not None and isinstance(child_vrrp, dict):
        children['vrrp'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(child_vrrp)
    return yang.gdata.ListElement([str(child_type if child_type is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(e))
    return yang.gdata.List(keys=['type'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_type = n.children.get('type')
    if child_type is not None:
        if isinstance(child_type, yang.gdata.Leaf):
            children['type'] = child_type.val
    child_ospf = n.children.get('ospf')
    if child_ospf is not None:
        if isinstance(child_ospf, yang.gdata.Container):
            children['ospf'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(child_ospf)
    child_bgp = n.children.get('bgp')
    if child_bgp is not None:
        if isinstance(child_bgp, yang.gdata.Container):
            children['bgp'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(child_bgp)
    child_static = n.children.get('static')
    if child_static is not None:
        if isinstance(child_static, yang.gdata.Container):
            children['static'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(child_static)
    child_rip = n.children.get('rip')
    if child_rip is not None:
        if isinstance(child_rip, yang.gdata.Container):
            children['rip'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(child_rip)
    child_vrrp = n.children.get('vrrp')
    if child_vrrp is not None:
        if isinstance(child_vrrp, yang.gdata.Container):
            children['vrrp'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(child_vrrp)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(elements=routing_protocol)
        self.routing_protocol._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _routing_protocol = self.routing_protocol
        if _routing_protocol is not None:
            children['routing-protocol'] = _routing_protocol.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol.from_gdata(n.get_opt_list("routing-protocol")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol.from_xml(yang.gdata.get_xml_children(n, "routing-protocol")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:routing-protocol' or point == 'routing-protocol':
            child = {'routing-protocol': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_routing_protocol_full = jd.get('l3vpn-svc:routing-protocol')
    child_routing_protocol = child_routing_protocol_full if child_routing_protocol_full is not None else jd.get('routing-protocol')
    if child_routing_protocol is not None and isinstance(child_routing_protocol, list):
        children['routing-protocol'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(child_routing_protocol)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_routing_protocol = n.children.get('routing-protocol')
    if child_routing_protocol is not None:
        if isinstance(child_routing_protocol, yang.gdata.List):
            children['routing-protocol'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(child_routing_protocol)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.group_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id=n.get_str("group-id"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id=yang.gdata.from_xml_str(n, "group-id"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['group-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_group_id_full = jd.get('l3vpn-svc:group-id')
    child_group_id = child_group_id_full if child_group_id_full is not None else jd.get('group-id')
    if child_group_id is not None:
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(child_group_id)
    return yang.gdata.ListElement([str(child_group_id if child_group_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_group_id = n.children.get('group-id')
    if child_group_id is not None:
        if isinstance(child_group_id, yang.gdata.Leaf):
            children['group-id'] = child_group_id.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(elements=group)
        self.group._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group.from_gdata(n.get_opt_list("group")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group.from_xml(yang.gdata.get_xml_children(n, "group")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:group' or point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group_full = jd.get('l3vpn-svc:group')
    child_group = child_group_full if child_group_full is not None else jd.get('group')
    if child_group is not None and isinstance(child_group, list):
        children['group'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(child_group)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_group = n.children.get('group')
    if child_group is not None:
        if isinstance(child_group, yang.gdata.List):
            children['group'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(child_group)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.group_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id=n.get_str("group-id"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id=yang.gdata.from_xml_str(n, "group-id"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['group-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_group_id_full = jd.get('l3vpn-svc:group-id')
    child_group_id = child_group_id_full if child_group_id_full is not None else jd.get('group-id')
    if child_group_id is not None:
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(child_group_id)
    return yang.gdata.ListElement([str(child_group_id if child_group_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_group_id = n.children.get('group-id')
    if child_group_id is not None:
        if isinstance(child_group_id, yang.gdata.Leaf):
            children['group-id'] = child_group_id.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(e))
    return elements

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group
    all_other_accesses: ?bool
    all_other_groups: ?bool

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]=[], all_other_accesses: ?bool, all_other_groups: ?bool):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(elements=group)
        self.group._parent = self
        self.all_other_accesses = all_other_accesses
        self.all_other_groups = all_other_groups

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        _all_other_accesses = self.all_other_accesses
        _all_other_groups = self.all_other_groups
        if _group is not None:
            children['group'] = _group.to_gdata()
        if _all_other_accesses is not None:
            children['all-other-accesses'] = yang.gdata.Leaf('empty', _all_other_accesses)
        if _all_other_groups is not None:
            children['all-other-groups'] = yang.gdata.Leaf('empty', _all_other_groups)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group.from_gdata(n.get_opt_list("group")), all_other_accesses=n.get_opt_bool("all-other-accesses"), all_other_groups=n.get_opt_bool("all-other-groups"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group.from_xml(yang.gdata.get_xml_children(n, "group")), all_other_accesses=yang.gdata.from_xml_opt_bool(n, "all-other-accesses"), all_other_groups=yang.gdata.from_xml_opt_bool(n, "all-other-groups"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:group' or point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:all-other-accesses' or point == 'all-other-accesses':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:all-other-groups' or point == 'all-other-groups':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group_full = jd.get('l3vpn-svc:group')
    child_group = child_group_full if child_group_full is not None else jd.get('group')
    if child_group is not None and isinstance(child_group, list):
        children['group'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(child_group)
    child_all_other_accesses_full = jd.get('l3vpn-svc:all-other-accesses')
    child_all_other_accesses = child_all_other_accesses_full if child_all_other_accesses_full is not None else jd.get('all-other-accesses')
    if child_all_other_accesses is not None:
        children['all-other-accesses'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses(child_all_other_accesses)
    child_all_other_groups_full = jd.get('l3vpn-svc:all-other-groups')
    child_all_other_groups = child_all_other_groups_full if child_all_other_groups_full is not None else jd.get('all-other-groups')
    if child_all_other_groups is not None:
        children['all-other-groups'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups(child_all_other_groups)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_group = n.children.get('group')
    if child_group is not None:
        if isinstance(child_group, yang.gdata.List):
            children['group'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(child_group)
    child_all_other_accesses = n.children.get('all-other-accesses')
    if child_all_other_accesses is not None:
        if isinstance(child_all_other_accesses, yang.gdata.Leaf):
            children['all-other-accesses'] = child_all_other_accesses.val
    child_all_other_groups = n.children.get('all-other-groups')
    if child_all_other_groups is not None:
        if isinstance(child_all_other_groups, yang.gdata.Leaf):
            children['all-other-groups'] = child_all_other_groups.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(yang.adata.MNode):
    constraint_type: str
    target: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target

    mut def __init__(self, constraint_type: str, target: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.constraint_type = constraint_type
        if target is not None:
            self.target = target
        else:
            self.target = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()
        self_target = self.target
        if self_target is not None:
            self_target._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _constraint_type = self.constraint_type
        _target = self.target
        if _constraint_type is not None:
            children['constraint-type'] = yang.gdata.Leaf('identityref', _constraint_type)
        if _target is not None:
            children['target'] = _target.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.constraint_type)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type=n.get_str("constraint-type"), target=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target.from_gdata(n.get_opt_container("target")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type=yang.gdata.from_xml_str(n, "constraint-type"), target=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target.from_xml(yang.gdata.get_xml_opt_child(n, "target")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'constraint'
        self.elements = elements

    mut def create(self, constraint_type):
        for e in self.elements:
            match = True
            if e.constraint_type != constraint_type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['constraint-type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['constraint-type']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'target':
            children['target'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['constraint-type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['constraint-type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['constraint-type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_constraint_type_full = jd.get('l3vpn-svc:constraint-type')
    child_constraint_type = child_constraint_type_full if child_constraint_type_full is not None else jd.get('constraint-type')
    if child_constraint_type is not None:
        children['constraint-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(child_constraint_type)
    child_target_full = jd.get('l3vpn-svc:target')
    child_target = child_target_full if child_target_full is not None else jd.get('target')
    if child_target is not None and isinstance(child_target, dict):
        children['target'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(child_target)
    return yang.gdata.ListElement([str(child_constraint_type if child_constraint_type is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(e))
    return yang.gdata.List(keys=['constraint-type'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_constraint_type = n.children.get('constraint-type')
    if child_constraint_type is not None:
        if isinstance(child_constraint_type, yang.gdata.Leaf):
            children['constraint-type'] = child_constraint_type.val
    child_target = n.children.get('target')
    if child_target is not None:
        if isinstance(child_target, yang.gdata.Container):
            children['target'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(child_target)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(yang.adata.MNode):
    constraint: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint

    mut def __init__(self, constraint: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.constraint = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(elements=constraint)
        self.constraint._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _constraint = self.constraint
        if _constraint is not None:
            children['constraint'] = _constraint.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(constraint=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint.from_gdata(n.get_opt_list("constraint")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(constraint=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint.from_xml(yang.gdata.get_xml_children(n, "constraint")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:constraint' or point == 'constraint':
            child = {'constraint': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_constraint_full = jd.get('l3vpn-svc:constraint')
    child_constraint = child_constraint_full if child_constraint_full is not None else jd.get('constraint')
    if child_constraint is not None and isinstance(child_constraint, list):
        children['constraint'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(child_constraint)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_constraint = n.children.get('constraint')
    if child_constraint is not None:
        if isinstance(child_constraint, yang.gdata.List):
            children['constraint'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(child_constraint)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups
    constraints: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups=None, constraints: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if groups is not None:
            self.groups = groups
        else:
            self.groups = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()
        self_groups = self.groups
        if self_groups is not None:
            self_groups._parent = self
        if constraints is not None:
            self.constraints = constraints
        else:
            self.constraints = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()
        self_constraints = self.constraints
        if self_constraints is not None:
            self_constraints._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _groups = self.groups
        _constraints = self.constraints
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        if _constraints is not None:
            children['constraints'] = _constraints.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups.from_gdata(n.get_opt_container("groups")), constraints=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints.from_gdata(n.get_opt_container("constraints")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups.from_xml(yang.gdata.get_xml_opt_child(n, "groups")), constraints=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints.from_xml(yang.gdata.get_xml_opt_child(n, "constraints")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:groups' or point == 'groups':
            child = {'groups': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:constraints' or point == 'constraints':
            child = {'constraints': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_groups_full = jd.get('l3vpn-svc:groups')
    child_groups = child_groups_full if child_groups_full is not None else jd.get('groups')
    if child_groups is not None and isinstance(child_groups, dict):
        children['groups'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(child_groups)
    child_constraints_full = jd.get('l3vpn-svc:constraints')
    child_constraints = child_constraints_full if child_constraints_full is not None else jd.get('constraints')
    if child_constraints is not None and isinstance(child_constraints, dict):
        children['constraints'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(child_constraints)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_groups = n.children.get('groups')
    if child_groups is not None:
        if isinstance(child_groups, yang.gdata.Container):
            children['groups'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(child_groups)
    child_constraints = n.children.get('constraints')
    if child_constraints is not None:
        if isinstance(child_constraints, yang.gdata.Container):
            children['constraints'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(child_constraints)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(yang.adata.MNode):
    requested_type: ?str
    strict: ?bool

    mut def __init__(self, requested_type: ?str, strict: ?bool):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.requested_type = requested_type
        self.strict = strict

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _requested_type = self.requested_type
        _strict = self.strict
        if _requested_type is not None:
            children['requested-type'] = yang.gdata.Leaf('string', _requested_type)
        if _strict is not None:
            children['strict'] = yang.gdata.Leaf('boolean', _strict)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(requested_type=n.get_opt_str("requested-type"), strict=n.get_opt_bool("strict"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(requested_type=yang.gdata.from_xml_opt_str(n, "requested-type"), strict=yang.gdata.from_xml_opt_bool(n, "strict"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:requested-type' or point == 'requested-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:strict' or point == 'strict':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_requested_type_full = jd.get('l3vpn-svc:requested-type')
    child_requested_type = child_requested_type_full if child_requested_type_full is not None else jd.get('requested-type')
    if child_requested_type is not None:
        children['requested-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type(child_requested_type)
    child_strict_full = jd.get('l3vpn-svc:strict')
    child_strict = child_strict_full if child_strict_full is not None else jd.get('strict')
    if child_strict is not None:
        children['strict'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict(child_strict)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_requested_type = n.children.get('requested-type')
    if child_requested_type is not None:
        if isinstance(child_requested_type, yang.gdata.Leaf):
            children['requested-type'] = child_requested_type.val
    child_strict = n.children.get('strict')
    if child_strict is not None:
        if isinstance(child_strict, yang.gdata.Leaf):
            children['strict'] = child_strict.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(yang.adata.MNode):
    requested_type: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type
    always_on: ?bool
    bearer_reference: ?str

    mut def __init__(self, requested_type: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type=None, always_on: ?bool, bearer_reference: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if requested_type is not None:
            self.requested_type = requested_type
        else:
            self.requested_type = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()
        self_requested_type = self.requested_type
        if self_requested_type is not None:
            self_requested_type._parent = self
        self.always_on = always_on
        self.bearer_reference = bearer_reference

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _requested_type = self.requested_type
        _always_on = self.always_on
        _bearer_reference = self.bearer_reference
        if _requested_type is not None:
            children['requested-type'] = _requested_type.to_gdata()
        if _always_on is not None:
            children['always-on'] = yang.gdata.Leaf('boolean', _always_on)
        if _bearer_reference is not None:
            children['bearer-reference'] = yang.gdata.Leaf('string', _bearer_reference)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(requested_type=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type.from_gdata(n.get_opt_container("requested-type")), always_on=n.get_opt_bool("always-on"), bearer_reference=n.get_opt_str("bearer-reference"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(requested_type=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type.from_xml(yang.gdata.get_xml_opt_child(n, "requested-type")), always_on=yang.gdata.from_xml_opt_bool(n, "always-on"), bearer_reference=yang.gdata.from_xml_opt_str(n, "bearer-reference"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:requested-type' or point == 'requested-type':
            child = {'requested-type': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:always-on' or point == 'always-on':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:bearer-reference' or point == 'bearer-reference':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_requested_type_full = jd.get('l3vpn-svc:requested-type')
    child_requested_type = child_requested_type_full if child_requested_type_full is not None else jd.get('requested-type')
    if child_requested_type is not None and isinstance(child_requested_type, dict):
        children['requested-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(child_requested_type)
    child_always_on_full = jd.get('l3vpn-svc:always-on')
    child_always_on = child_always_on_full if child_always_on_full is not None else jd.get('always-on')
    if child_always_on is not None:
        children['always-on'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on(child_always_on)
    child_bearer_reference_full = jd.get('l3vpn-svc:bearer-reference')
    child_bearer_reference = child_bearer_reference_full if child_bearer_reference_full is not None else jd.get('bearer-reference')
    if child_bearer_reference is not None:
        children['bearer-reference'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference(child_bearer_reference)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_requested_type = n.children.get('requested-type')
    if child_requested_type is not None:
        if isinstance(child_requested_type, yang.gdata.Container):
            children['requested-type'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(child_requested_type)
    child_always_on = n.children.get('always-on')
    if child_always_on is not None:
        if isinstance(child_always_on, yang.gdata.Leaf):
            children['always-on'] = child_always_on.val
    child_bearer_reference = n.children.get('bearer-reference')
    if child_bearer_reference is not None:
        if isinstance(child_bearer_reference, yang.gdata.Leaf):
            children['bearer-reference'] = child_bearer_reference.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        _start_address = self.start_address
        _end_address = self.end_address
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        if _start_address is not None:
            children['start-address'] = yang.gdata.Leaf('string', _start_address)
        if _end_address is not None:
            children['end-address'] = yang.gdata.Leaf('string', _end_address)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.group_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str("group-id"), start_address=n.get_opt_str("start-address"), end_address=n.get_opt_str("end-address"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id=yang.gdata.from_xml_str(n, "group-id"), start_address=yang.gdata.from_xml_opt_str(n, "start-address"), end_address=yang.gdata.from_xml_opt_str(n, "end-address"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['group-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'start-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_group_id_full = jd.get('l3vpn-svc:group-id')
    child_group_id = child_group_id_full if child_group_id_full is not None else jd.get('group-id')
    if child_group_id is not None:
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(child_group_id)
    child_start_address_full = jd.get('l3vpn-svc:start-address')
    child_start_address = child_start_address_full if child_start_address_full is not None else jd.get('start-address')
    if child_start_address is not None:
        children['start-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address(child_start_address)
    child_end_address_full = jd.get('l3vpn-svc:end-address')
    child_end_address = child_end_address_full if child_end_address_full is not None else jd.get('end-address')
    if child_end_address is not None:
        children['end-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address(child_end_address)
    return yang.gdata.ListElement([str(child_group_id if child_group_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_group_id = n.children.get('group-id')
    if child_group_id is not None:
        if isinstance(child_group_id, yang.gdata.Leaf):
            children['group-id'] = child_group_id.val
    child_start_address = n.children.get('start-address')
    if child_start_address is not None:
        if isinstance(child_start_address, yang.gdata.Leaf):
            children['start-address'] = child_start_address.val
    child_end_address = n.children.get('end-address')
    if child_end_address is not None:
        if isinstance(child_end_address, yang.gdata.Leaf):
            children['end-address'] = child_end_address.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(elements=address_group)
        self.address_group._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_group = self.address_group
        if _address_group is not None:
            children['address-group'] = _address_group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list("address-group")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group.from_xml(yang.gdata.get_xml_children(n, "address-group")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-group' or point == 'address-group':
            child = {'address-group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_group_full = jd.get('l3vpn-svc:address-group')
    child_address_group = child_address_group_full if child_address_group_full is not None else jd.get('address-group')
    if child_address_group is not None and isinstance(child_address_group, list):
        children['address-group'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(child_address_group)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_group = n.children.get('address-group')
    if child_address_group is not None:
        if isinstance(child_address_group, yang.gdata.List):
            children['address-group'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(child_address_group)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    number_of_dynamic_address: ?int
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, number_of_dynamic_address: ?int, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address
        if customer_addresses is not None:
            self.customer_addresses = customer_addresses
        else:
            self.customer_addresses = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()
        self_customer_addresses = self.customer_addresses
        if self_customer_addresses is not None:
            self_customer_addresses._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        _prefix_length = self.prefix_length
        _number_of_dynamic_address = self.number_of_dynamic_address
        _customer_addresses = self.customer_addresses
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        if _number_of_dynamic_address is not None:
            children['number-of-dynamic-address'] = yang.gdata.Leaf('uint16', _number_of_dynamic_address)
        if _customer_addresses is not None:
            children['customer-addresses'] = _customer_addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(provider_address=n.get_opt_str("provider-address"), prefix_length=n.get_opt_int("prefix-length"), number_of_dynamic_address=n.get_opt_int("number-of-dynamic-address"), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses.from_gdata(n.get_opt_container("customer-addresses")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(provider_address=yang.gdata.from_xml_opt_str(n, "provider-address"), prefix_length=yang.gdata.from_xml_opt_int(n, "prefix-length"), number_of_dynamic_address=yang.gdata.from_xml_opt_int(n, "number-of-dynamic-address"), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses.from_xml(yang.gdata.get_xml_opt_child(n, "customer-addresses")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:provider-address' or point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:prefix-length' or point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:number-of-dynamic-address' or point == 'number-of-dynamic-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:customer-addresses' or point == 'customer-addresses':
            child = {'customer-addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address_full = jd.get('l3vpn-svc:provider-address')
    child_provider_address = child_provider_address_full if child_provider_address_full is not None else jd.get('provider-address')
    if child_provider_address is not None:
        children['provider-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address(child_provider_address)
    child_prefix_length_full = jd.get('l3vpn-svc:prefix-length')
    child_prefix_length = child_prefix_length_full if child_prefix_length_full is not None else jd.get('prefix-length')
    if child_prefix_length is not None:
        children['prefix-length'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length(child_prefix_length)
    child_number_of_dynamic_address_full = jd.get('l3vpn-svc:number-of-dynamic-address')
    child_number_of_dynamic_address = child_number_of_dynamic_address_full if child_number_of_dynamic_address_full is not None else jd.get('number-of-dynamic-address')
    if child_number_of_dynamic_address is not None:
        children['number-of-dynamic-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address(child_number_of_dynamic_address)
    child_customer_addresses_full = jd.get('l3vpn-svc:customer-addresses')
    child_customer_addresses = child_customer_addresses_full if child_customer_addresses_full is not None else jd.get('customer-addresses')
    if child_customer_addresses is not None and isinstance(child_customer_addresses, dict):
        children['customer-addresses'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(child_customer_addresses)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_provider_address = n.children.get('provider-address')
    if child_provider_address is not None:
        if isinstance(child_provider_address, yang.gdata.Leaf):
            children['provider-address'] = child_provider_address.val
    child_prefix_length = n.children.get('prefix-length')
    if child_prefix_length is not None:
        if isinstance(child_prefix_length, yang.gdata.Leaf):
            children['prefix-length'] = child_prefix_length.val
    child_number_of_dynamic_address = n.children.get('number-of-dynamic-address')
    if child_number_of_dynamic_address is not None:
        if isinstance(child_number_of_dynamic_address, yang.gdata.Leaf):
            children['number-of-dynamic-address'] = child_number_of_dynamic_address.val
    child_customer_addresses = n.children.get('customer-addresses')
    if child_customer_addresses is not None:
        if isinstance(child_customer_addresses, yang.gdata.Container):
            children['customer-addresses'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(child_customer_addresses)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if server_ip_address is not None:
            self.server_ip_address = server_ip_address
        else:
            self.server_ip_address = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['server-ip-address'] = yang.gdata.LeafList(self.server_ip_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs("server-ip-address"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(server_ip_address=yang.gdata.from_xml_opt_strs(n, "server-ip-address"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:server-ip-address' or point == 'server-ip-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_server_ip_address_full = jd.get('l3vpn-svc:server-ip-address')
    child_server_ip_address = child_server_ip_address_full if child_server_ip_address_full is not None else jd.get('server-ip-address')
    if child_server_ip_address is not None and isinstance(child_server_ip_address, list):
        children['server-ip-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address(child_server_ip_address)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_server_ip_address = n.children.get('server-ip-address')
    if child_server_ip_address is not None:
        if isinstance(child_server_ip_address, yang.gdata.LeafList):
            children['server-ip-address'] = child_server_ip_address.vals
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        if customer_dhcp_servers is not None:
            self.customer_dhcp_servers = customer_dhcp_servers
        else:
            self.customer_dhcp_servers = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()
        self_customer_dhcp_servers = self.customer_dhcp_servers
        if self_customer_dhcp_servers is not None:
            self_customer_dhcp_servers._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        _prefix_length = self.prefix_length
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        if _customer_dhcp_servers is not None:
            children['customer-dhcp-servers'] = _customer_dhcp_servers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(provider_address=n.get_opt_str("provider-address"), prefix_length=n.get_opt_int("prefix-length"), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_container("customer-dhcp-servers")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(provider_address=yang.gdata.from_xml_opt_str(n, "provider-address"), prefix_length=yang.gdata.from_xml_opt_int(n, "prefix-length"), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers.from_xml(yang.gdata.get_xml_opt_child(n, "customer-dhcp-servers")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:provider-address' or point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:prefix-length' or point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:customer-dhcp-servers' or point == 'customer-dhcp-servers':
            child = {'customer-dhcp-servers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address_full = jd.get('l3vpn-svc:provider-address')
    child_provider_address = child_provider_address_full if child_provider_address_full is not None else jd.get('provider-address')
    if child_provider_address is not None:
        children['provider-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address(child_provider_address)
    child_prefix_length_full = jd.get('l3vpn-svc:prefix-length')
    child_prefix_length = child_prefix_length_full if child_prefix_length_full is not None else jd.get('prefix-length')
    if child_prefix_length is not None:
        children['prefix-length'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length(child_prefix_length)
    child_customer_dhcp_servers_full = jd.get('l3vpn-svc:customer-dhcp-servers')
    child_customer_dhcp_servers = child_customer_dhcp_servers_full if child_customer_dhcp_servers_full is not None else jd.get('customer-dhcp-servers')
    if child_customer_dhcp_servers is not None and isinstance(child_customer_dhcp_servers, dict):
        children['customer-dhcp-servers'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_provider_address = n.children.get('provider-address')
    if child_provider_address is not None:
        if isinstance(child_provider_address, yang.gdata.Leaf):
            children['provider-address'] = child_provider_address.val
    child_prefix_length = n.children.get('prefix-length')
    if child_prefix_length is not None:
        if isinstance(child_prefix_length, yang.gdata.Leaf):
            children['prefix-length'] = child_prefix_length.val
    child_customer_dhcp_servers = n.children.get('customer-dhcp-servers')
    if child_customer_dhcp_servers is not None:
        if isinstance(child_customer_dhcp_servers, yang.gdata.Container):
            children['customer-dhcp-servers'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(child_customer_dhcp_servers)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?int

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        _customer_address = self.customer_address
        _prefix_length = self.prefix_length
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        if _customer_address is not None:
            children['customer-address'] = yang.gdata.Leaf('string', _customer_address)
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(provider_address=n.get_opt_str("provider-address"), customer_address=n.get_opt_str("customer-address"), prefix_length=n.get_opt_int("prefix-length"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(provider_address=yang.gdata.from_xml_opt_str(n, "provider-address"), customer_address=yang.gdata.from_xml_opt_str(n, "customer-address"), prefix_length=yang.gdata.from_xml_opt_int(n, "prefix-length"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:provider-address' or point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:customer-address' or point == 'customer-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:prefix-length' or point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address_full = jd.get('l3vpn-svc:provider-address')
    child_provider_address = child_provider_address_full if child_provider_address_full is not None else jd.get('provider-address')
    if child_provider_address is not None:
        children['provider-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address(child_provider_address)
    child_customer_address_full = jd.get('l3vpn-svc:customer-address')
    child_customer_address = child_customer_address_full if child_customer_address_full is not None else jd.get('customer-address')
    if child_customer_address is not None:
        children['customer-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address(child_customer_address)
    child_prefix_length_full = jd.get('l3vpn-svc:prefix-length')
    child_prefix_length = child_prefix_length_full if child_prefix_length_full is not None else jd.get('prefix-length')
    if child_prefix_length is not None:
        children['prefix-length'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length(child_prefix_length)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_provider_address = n.children.get('provider-address')
    if child_provider_address is not None:
        if isinstance(child_provider_address, yang.gdata.Leaf):
            children['provider-address'] = child_provider_address.val
    child_customer_address = n.children.get('customer-address')
    if child_customer_address is not None:
        if isinstance(child_customer_address, yang.gdata.Leaf):
            children['customer-address'] = child_customer_address.val
    child_prefix_length = n.children.get('prefix-length')
    if child_prefix_length is not None:
        if isinstance(child_prefix_length, yang.gdata.Leaf):
            children['prefix-length'] = child_prefix_length.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(yang.adata.MNode):
    address_allocation_type: ?str
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses

    mut def __init__(self, address_allocation_type: ?str, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.address_allocation_type = address_allocation_type
        if provider_dhcp is not None:
            self.provider_dhcp = provider_dhcp
        else:
            self.provider_dhcp = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()
        self_provider_dhcp = self.provider_dhcp
        if self_provider_dhcp is not None:
            self_provider_dhcp._parent = self
        if dhcp_relay is not None:
            self.dhcp_relay = dhcp_relay
        else:
            self.dhcp_relay = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()
        self_dhcp_relay = self.dhcp_relay
        if self_dhcp_relay is not None:
            self_dhcp_relay._parent = self
        if addresses is not None:
            self.addresses = addresses
        else:
            self.addresses = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()
        self_addresses = self.addresses
        if self_addresses is not None:
            self_addresses._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_allocation_type = self.address_allocation_type
        _provider_dhcp = self.provider_dhcp
        _dhcp_relay = self.dhcp_relay
        _addresses = self.addresses
        if _address_allocation_type is not None:
            children['address-allocation-type'] = yang.gdata.Leaf('identityref', _address_allocation_type)
        if _provider_dhcp is not None:
            children['provider-dhcp'] = _provider_dhcp.to_gdata()
        if _dhcp_relay is not None:
            children['dhcp-relay'] = _dhcp_relay.to_gdata()
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(address_allocation_type=n.get_opt_str("address-allocation-type"), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp.from_gdata(n.get_opt_container("provider-dhcp")), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay.from_gdata(n.get_opt_container("dhcp-relay")), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses.from_gdata(n.get_opt_container("addresses")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(address_allocation_type=yang.gdata.from_xml_opt_str(n, "address-allocation-type"), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp.from_xml(yang.gdata.get_xml_opt_child(n, "provider-dhcp")), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay.from_xml(yang.gdata.get_xml_opt_child(n, "dhcp-relay")), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses.from_xml(yang.gdata.get_xml_opt_child(n, "addresses")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-allocation-type' or point == 'address-allocation-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:provider-dhcp' or point == 'provider-dhcp':
            child = {'provider-dhcp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:dhcp-relay' or point == 'dhcp-relay':
            child = {'dhcp-relay': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:addresses' or point == 'addresses':
            child = {'addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type_full = jd.get('l3vpn-svc:address-allocation-type')
    child_address_allocation_type = child_address_allocation_type_full if child_address_allocation_type_full is not None else jd.get('address-allocation-type')
    if child_address_allocation_type is not None:
        children['address-allocation-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type(child_address_allocation_type)
    child_provider_dhcp_full = jd.get('l3vpn-svc:provider-dhcp')
    child_provider_dhcp = child_provider_dhcp_full if child_provider_dhcp_full is not None else jd.get('provider-dhcp')
    if child_provider_dhcp is not None and isinstance(child_provider_dhcp, dict):
        children['provider-dhcp'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(child_provider_dhcp)
    child_dhcp_relay_full = jd.get('l3vpn-svc:dhcp-relay')
    child_dhcp_relay = child_dhcp_relay_full if child_dhcp_relay_full is not None else jd.get('dhcp-relay')
    if child_dhcp_relay is not None and isinstance(child_dhcp_relay, dict):
        children['dhcp-relay'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(child_dhcp_relay)
    child_addresses_full = jd.get('l3vpn-svc:addresses')
    child_addresses = child_addresses_full if child_addresses_full is not None else jd.get('addresses')
    if child_addresses is not None and isinstance(child_addresses, dict):
        children['addresses'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(child_addresses)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_allocation_type = n.children.get('address-allocation-type')
    if child_address_allocation_type is not None:
        if isinstance(child_address_allocation_type, yang.gdata.Leaf):
            children['address-allocation-type'] = child_address_allocation_type.val
    child_provider_dhcp = n.children.get('provider-dhcp')
    if child_provider_dhcp is not None:
        if isinstance(child_provider_dhcp, yang.gdata.Container):
            children['provider-dhcp'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(child_provider_dhcp)
    child_dhcp_relay = n.children.get('dhcp-relay')
    if child_dhcp_relay is not None:
        if isinstance(child_dhcp_relay, yang.gdata.Container):
            children['dhcp-relay'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(child_dhcp_relay)
    child_addresses = n.children.get('addresses')
    if child_addresses is not None:
        if isinstance(child_addresses, yang.gdata.Container):
            children['addresses'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(child_addresses)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        _start_address = self.start_address
        _end_address = self.end_address
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        if _start_address is not None:
            children['start-address'] = yang.gdata.Leaf('string', _start_address)
        if _end_address is not None:
            children['end-address'] = yang.gdata.Leaf('string', _end_address)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.group_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str("group-id"), start_address=n.get_opt_str("start-address"), end_address=n.get_opt_str("end-address"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id=yang.gdata.from_xml_str(n, "group-id"), start_address=yang.gdata.from_xml_opt_str(n, "start-address"), end_address=yang.gdata.from_xml_opt_str(n, "end-address"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['group-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'start-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_group_id_full = jd.get('l3vpn-svc:group-id')
    child_group_id = child_group_id_full if child_group_id_full is not None else jd.get('group-id')
    if child_group_id is not None:
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(child_group_id)
    child_start_address_full = jd.get('l3vpn-svc:start-address')
    child_start_address = child_start_address_full if child_start_address_full is not None else jd.get('start-address')
    if child_start_address is not None:
        children['start-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address(child_start_address)
    child_end_address_full = jd.get('l3vpn-svc:end-address')
    child_end_address = child_end_address_full if child_end_address_full is not None else jd.get('end-address')
    if child_end_address is not None:
        children['end-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address(child_end_address)
    return yang.gdata.ListElement([str(child_group_id if child_group_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_group_id = n.children.get('group-id')
    if child_group_id is not None:
        if isinstance(child_group_id, yang.gdata.Leaf):
            children['group-id'] = child_group_id.val
    child_start_address = n.children.get('start-address')
    if child_start_address is not None:
        if isinstance(child_start_address, yang.gdata.Leaf):
            children['start-address'] = child_start_address.val
    child_end_address = n.children.get('end-address')
    if child_end_address is not None:
        if isinstance(child_end_address, yang.gdata.Leaf):
            children['end-address'] = child_end_address.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(elements=address_group)
        self.address_group._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_group = self.address_group
        if _address_group is not None:
            children['address-group'] = _address_group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list("address-group")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group.from_xml(yang.gdata.get_xml_children(n, "address-group")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-group' or point == 'address-group':
            child = {'address-group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_group_full = jd.get('l3vpn-svc:address-group')
    child_address_group = child_address_group_full if child_address_group_full is not None else jd.get('address-group')
    if child_address_group is not None and isinstance(child_address_group, list):
        children['address-group'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(child_address_group)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_group = n.children.get('address-group')
    if child_address_group is not None:
        if isinstance(child_address_group, yang.gdata.List):
            children['address-group'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(child_address_group)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    number_of_dynamic_address: ?int
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, number_of_dynamic_address: ?int, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address
        if customer_addresses is not None:
            self.customer_addresses = customer_addresses
        else:
            self.customer_addresses = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()
        self_customer_addresses = self.customer_addresses
        if self_customer_addresses is not None:
            self_customer_addresses._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        _prefix_length = self.prefix_length
        _number_of_dynamic_address = self.number_of_dynamic_address
        _customer_addresses = self.customer_addresses
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        if _number_of_dynamic_address is not None:
            children['number-of-dynamic-address'] = yang.gdata.Leaf('uint16', _number_of_dynamic_address)
        if _customer_addresses is not None:
            children['customer-addresses'] = _customer_addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(provider_address=n.get_opt_str("provider-address"), prefix_length=n.get_opt_int("prefix-length"), number_of_dynamic_address=n.get_opt_int("number-of-dynamic-address"), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses.from_gdata(n.get_opt_container("customer-addresses")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(provider_address=yang.gdata.from_xml_opt_str(n, "provider-address"), prefix_length=yang.gdata.from_xml_opt_int(n, "prefix-length"), number_of_dynamic_address=yang.gdata.from_xml_opt_int(n, "number-of-dynamic-address"), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses.from_xml(yang.gdata.get_xml_opt_child(n, "customer-addresses")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:provider-address' or point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:prefix-length' or point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:number-of-dynamic-address' or point == 'number-of-dynamic-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:customer-addresses' or point == 'customer-addresses':
            child = {'customer-addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address_full = jd.get('l3vpn-svc:provider-address')
    child_provider_address = child_provider_address_full if child_provider_address_full is not None else jd.get('provider-address')
    if child_provider_address is not None:
        children['provider-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address(child_provider_address)
    child_prefix_length_full = jd.get('l3vpn-svc:prefix-length')
    child_prefix_length = child_prefix_length_full if child_prefix_length_full is not None else jd.get('prefix-length')
    if child_prefix_length is not None:
        children['prefix-length'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length(child_prefix_length)
    child_number_of_dynamic_address_full = jd.get('l3vpn-svc:number-of-dynamic-address')
    child_number_of_dynamic_address = child_number_of_dynamic_address_full if child_number_of_dynamic_address_full is not None else jd.get('number-of-dynamic-address')
    if child_number_of_dynamic_address is not None:
        children['number-of-dynamic-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address(child_number_of_dynamic_address)
    child_customer_addresses_full = jd.get('l3vpn-svc:customer-addresses')
    child_customer_addresses = child_customer_addresses_full if child_customer_addresses_full is not None else jd.get('customer-addresses')
    if child_customer_addresses is not None and isinstance(child_customer_addresses, dict):
        children['customer-addresses'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(child_customer_addresses)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_provider_address = n.children.get('provider-address')
    if child_provider_address is not None:
        if isinstance(child_provider_address, yang.gdata.Leaf):
            children['provider-address'] = child_provider_address.val
    child_prefix_length = n.children.get('prefix-length')
    if child_prefix_length is not None:
        if isinstance(child_prefix_length, yang.gdata.Leaf):
            children['prefix-length'] = child_prefix_length.val
    child_number_of_dynamic_address = n.children.get('number-of-dynamic-address')
    if child_number_of_dynamic_address is not None:
        if isinstance(child_number_of_dynamic_address, yang.gdata.Leaf):
            children['number-of-dynamic-address'] = child_number_of_dynamic_address.val
    child_customer_addresses = n.children.get('customer-addresses')
    if child_customer_addresses is not None:
        if isinstance(child_customer_addresses, yang.gdata.Container):
            children['customer-addresses'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(child_customer_addresses)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if server_ip_address is not None:
            self.server_ip_address = server_ip_address
        else:
            self.server_ip_address = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['server-ip-address'] = yang.gdata.LeafList(self.server_ip_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs("server-ip-address"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(server_ip_address=yang.gdata.from_xml_opt_strs(n, "server-ip-address"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:server-ip-address' or point == 'server-ip-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_server_ip_address_full = jd.get('l3vpn-svc:server-ip-address')
    child_server_ip_address = child_server_ip_address_full if child_server_ip_address_full is not None else jd.get('server-ip-address')
    if child_server_ip_address is not None and isinstance(child_server_ip_address, list):
        children['server-ip-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address(child_server_ip_address)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_server_ip_address = n.children.get('server-ip-address')
    if child_server_ip_address is not None:
        if isinstance(child_server_ip_address, yang.gdata.LeafList):
            children['server-ip-address'] = child_server_ip_address.vals
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        if customer_dhcp_servers is not None:
            self.customer_dhcp_servers = customer_dhcp_servers
        else:
            self.customer_dhcp_servers = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()
        self_customer_dhcp_servers = self.customer_dhcp_servers
        if self_customer_dhcp_servers is not None:
            self_customer_dhcp_servers._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        _prefix_length = self.prefix_length
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        if _customer_dhcp_servers is not None:
            children['customer-dhcp-servers'] = _customer_dhcp_servers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(provider_address=n.get_opt_str("provider-address"), prefix_length=n.get_opt_int("prefix-length"), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_container("customer-dhcp-servers")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(provider_address=yang.gdata.from_xml_opt_str(n, "provider-address"), prefix_length=yang.gdata.from_xml_opt_int(n, "prefix-length"), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers.from_xml(yang.gdata.get_xml_opt_child(n, "customer-dhcp-servers")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:provider-address' or point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:prefix-length' or point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:customer-dhcp-servers' or point == 'customer-dhcp-servers':
            child = {'customer-dhcp-servers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address_full = jd.get('l3vpn-svc:provider-address')
    child_provider_address = child_provider_address_full if child_provider_address_full is not None else jd.get('provider-address')
    if child_provider_address is not None:
        children['provider-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address(child_provider_address)
    child_prefix_length_full = jd.get('l3vpn-svc:prefix-length')
    child_prefix_length = child_prefix_length_full if child_prefix_length_full is not None else jd.get('prefix-length')
    if child_prefix_length is not None:
        children['prefix-length'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length(child_prefix_length)
    child_customer_dhcp_servers_full = jd.get('l3vpn-svc:customer-dhcp-servers')
    child_customer_dhcp_servers = child_customer_dhcp_servers_full if child_customer_dhcp_servers_full is not None else jd.get('customer-dhcp-servers')
    if child_customer_dhcp_servers is not None and isinstance(child_customer_dhcp_servers, dict):
        children['customer-dhcp-servers'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_provider_address = n.children.get('provider-address')
    if child_provider_address is not None:
        if isinstance(child_provider_address, yang.gdata.Leaf):
            children['provider-address'] = child_provider_address.val
    child_prefix_length = n.children.get('prefix-length')
    if child_prefix_length is not None:
        if isinstance(child_prefix_length, yang.gdata.Leaf):
            children['prefix-length'] = child_prefix_length.val
    child_customer_dhcp_servers = n.children.get('customer-dhcp-servers')
    if child_customer_dhcp_servers is not None:
        if isinstance(child_customer_dhcp_servers, yang.gdata.Container):
            children['customer-dhcp-servers'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(child_customer_dhcp_servers)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?int

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        _customer_address = self.customer_address
        _prefix_length = self.prefix_length
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        if _customer_address is not None:
            children['customer-address'] = yang.gdata.Leaf('string', _customer_address)
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(provider_address=n.get_opt_str("provider-address"), customer_address=n.get_opt_str("customer-address"), prefix_length=n.get_opt_int("prefix-length"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(provider_address=yang.gdata.from_xml_opt_str(n, "provider-address"), customer_address=yang.gdata.from_xml_opt_str(n, "customer-address"), prefix_length=yang.gdata.from_xml_opt_int(n, "prefix-length"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:provider-address' or point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:customer-address' or point == 'customer-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:prefix-length' or point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address_full = jd.get('l3vpn-svc:provider-address')
    child_provider_address = child_provider_address_full if child_provider_address_full is not None else jd.get('provider-address')
    if child_provider_address is not None:
        children['provider-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address(child_provider_address)
    child_customer_address_full = jd.get('l3vpn-svc:customer-address')
    child_customer_address = child_customer_address_full if child_customer_address_full is not None else jd.get('customer-address')
    if child_customer_address is not None:
        children['customer-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address(child_customer_address)
    child_prefix_length_full = jd.get('l3vpn-svc:prefix-length')
    child_prefix_length = child_prefix_length_full if child_prefix_length_full is not None else jd.get('prefix-length')
    if child_prefix_length is not None:
        children['prefix-length'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length(child_prefix_length)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_provider_address = n.children.get('provider-address')
    if child_provider_address is not None:
        if isinstance(child_provider_address, yang.gdata.Leaf):
            children['provider-address'] = child_provider_address.val
    child_customer_address = n.children.get('customer-address')
    if child_customer_address is not None:
        if isinstance(child_customer_address, yang.gdata.Leaf):
            children['customer-address'] = child_customer_address.val
    child_prefix_length = n.children.get('prefix-length')
    if child_prefix_length is not None:
        if isinstance(child_prefix_length, yang.gdata.Leaf):
            children['prefix-length'] = child_prefix_length.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(yang.adata.MNode):
    address_allocation_type: ?str
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses

    mut def __init__(self, address_allocation_type: ?str, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.address_allocation_type = address_allocation_type
        if provider_dhcp is not None:
            self.provider_dhcp = provider_dhcp
        else:
            self.provider_dhcp = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()
        self_provider_dhcp = self.provider_dhcp
        if self_provider_dhcp is not None:
            self_provider_dhcp._parent = self
        if dhcp_relay is not None:
            self.dhcp_relay = dhcp_relay
        else:
            self.dhcp_relay = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()
        self_dhcp_relay = self.dhcp_relay
        if self_dhcp_relay is not None:
            self_dhcp_relay._parent = self
        if addresses is not None:
            self.addresses = addresses
        else:
            self.addresses = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()
        self_addresses = self.addresses
        if self_addresses is not None:
            self_addresses._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_allocation_type = self.address_allocation_type
        _provider_dhcp = self.provider_dhcp
        _dhcp_relay = self.dhcp_relay
        _addresses = self.addresses
        if _address_allocation_type is not None:
            children['address-allocation-type'] = yang.gdata.Leaf('identityref', _address_allocation_type)
        if _provider_dhcp is not None:
            children['provider-dhcp'] = _provider_dhcp.to_gdata()
        if _dhcp_relay is not None:
            children['dhcp-relay'] = _dhcp_relay.to_gdata()
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(address_allocation_type=n.get_opt_str("address-allocation-type"), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp.from_gdata(n.get_opt_container("provider-dhcp")), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay.from_gdata(n.get_opt_container("dhcp-relay")), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses.from_gdata(n.get_opt_container("addresses")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(address_allocation_type=yang.gdata.from_xml_opt_str(n, "address-allocation-type"), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp.from_xml(yang.gdata.get_xml_opt_child(n, "provider-dhcp")), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay.from_xml(yang.gdata.get_xml_opt_child(n, "dhcp-relay")), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses.from_xml(yang.gdata.get_xml_opt_child(n, "addresses")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-allocation-type' or point == 'address-allocation-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:provider-dhcp' or point == 'provider-dhcp':
            child = {'provider-dhcp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:dhcp-relay' or point == 'dhcp-relay':
            child = {'dhcp-relay': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:addresses' or point == 'addresses':
            child = {'addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type_full = jd.get('l3vpn-svc:address-allocation-type')
    child_address_allocation_type = child_address_allocation_type_full if child_address_allocation_type_full is not None else jd.get('address-allocation-type')
    if child_address_allocation_type is not None:
        children['address-allocation-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type(child_address_allocation_type)
    child_provider_dhcp_full = jd.get('l3vpn-svc:provider-dhcp')
    child_provider_dhcp = child_provider_dhcp_full if child_provider_dhcp_full is not None else jd.get('provider-dhcp')
    if child_provider_dhcp is not None and isinstance(child_provider_dhcp, dict):
        children['provider-dhcp'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(child_provider_dhcp)
    child_dhcp_relay_full = jd.get('l3vpn-svc:dhcp-relay')
    child_dhcp_relay = child_dhcp_relay_full if child_dhcp_relay_full is not None else jd.get('dhcp-relay')
    if child_dhcp_relay is not None and isinstance(child_dhcp_relay, dict):
        children['dhcp-relay'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(child_dhcp_relay)
    child_addresses_full = jd.get('l3vpn-svc:addresses')
    child_addresses = child_addresses_full if child_addresses_full is not None else jd.get('addresses')
    if child_addresses is not None and isinstance(child_addresses, dict):
        children['addresses'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(child_addresses)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_allocation_type = n.children.get('address-allocation-type')
    if child_address_allocation_type is not None:
        if isinstance(child_address_allocation_type, yang.gdata.Leaf):
            children['address-allocation-type'] = child_address_allocation_type.val
    child_provider_dhcp = n.children.get('provider-dhcp')
    if child_provider_dhcp is not None:
        if isinstance(child_provider_dhcp, yang.gdata.Container):
            children['provider-dhcp'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(child_provider_dhcp)
    child_dhcp_relay = n.children.get('dhcp-relay')
    if child_dhcp_relay is not None:
        if isinstance(child_dhcp_relay, yang.gdata.Container):
            children['dhcp-relay'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(child_dhcp_relay)
    child_addresses = n.children.get('addresses')
    if child_addresses is not None:
        if isinstance(child_addresses, yang.gdata.Container):
            children['addresses'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(child_addresses)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(yang.adata.MNode):
    enabled: ?bool
    fixed_value: ?int
    profile_name: ?str

    mut def __init__(self, enabled: ?bool, fixed_value: ?int, profile_name: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.enabled = enabled
        self.fixed_value = fixed_value
        self.profile_name = profile_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        _fixed_value = self.fixed_value
        _profile_name = self.profile_name
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        if _fixed_value is not None:
            children['fixed-value'] = yang.gdata.Leaf('uint32', _fixed_value)
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(enabled=n.get_opt_bool("enabled"), fixed_value=n.get_opt_int("fixed-value"), profile_name=n.get_opt_str("profile-name"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(enabled=yang.gdata.from_xml_opt_bool(n, "enabled"), fixed_value=yang.gdata.from_xml_opt_int(n, "fixed-value"), profile_name=yang.gdata.from_xml_opt_str(n, "profile-name"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:enabled' or point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:fixed-value' or point == 'fixed-value':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:profile-name' or point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled_full = jd.get('l3vpn-svc:enabled')
    child_enabled = child_enabled_full if child_enabled_full is not None else jd.get('enabled')
    if child_enabled is not None:
        children['enabled'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled(child_enabled)
    child_fixed_value_full = jd.get('l3vpn-svc:fixed-value')
    child_fixed_value = child_fixed_value_full if child_fixed_value_full is not None else jd.get('fixed-value')
    if child_fixed_value is not None:
        children['fixed-value'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value(child_fixed_value)
    child_profile_name_full = jd.get('l3vpn-svc:profile-name')
    child_profile_name = child_profile_name_full if child_profile_name_full is not None else jd.get('profile-name')
    if child_profile_name is not None:
        children['profile-name'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name(child_profile_name)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_enabled = n.children.get('enabled')
    if child_enabled is not None:
        if isinstance(child_enabled, yang.gdata.Leaf):
            children['enabled'] = child_enabled.val
    child_fixed_value = n.children.get('fixed-value')
    if child_fixed_value is not None:
        if isinstance(child_fixed_value, yang.gdata.Leaf):
            children['fixed-value'] = child_fixed_value.val
    child_profile_name = n.children.get('profile-name')
    if child_profile_name is not None:
        if isinstance(child_profile_name, yang.gdata.Leaf):
            children['profile-name'] = child_profile_name.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(yang.adata.MNode):
    bfd: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd

    mut def __init__(self, bfd: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if bfd is not None:
            self.bfd = bfd
        else:
            self.bfd = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()
        self_bfd = self.bfd
        if self_bfd is not None:
            self_bfd._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bfd = self.bfd
        if _bfd is not None:
            children['bfd'] = _bfd.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(bfd=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd.from_gdata(n.get_opt_container("bfd")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(bfd=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd.from_xml(yang.gdata.get_xml_opt_child(n, "bfd")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:bfd' or point == 'bfd':
            child = {'bfd': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_bfd_full = jd.get('l3vpn-svc:bfd')
    child_bfd = child_bfd_full if child_bfd_full is not None else jd.get('bfd')
    if child_bfd is not None and isinstance(child_bfd, dict):
        children['bfd'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(child_bfd)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_bfd = n.children.get('bfd')
    if child_bfd is not None:
        if isinstance(child_bfd, yang.gdata.Container):
            children['bfd'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(child_bfd)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(yang.adata.MNode):
    ipv4: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4
    ipv6: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6
    oam: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam

    mut def __init__(self, ipv4: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4=None, ipv6: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6=None, oam: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if ipv4 is not None:
            self.ipv4 = ipv4
        else:
            self.ipv4 = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()
        self_ipv4 = self.ipv4
        if self_ipv4 is not None:
            self_ipv4._parent = self
        if ipv6 is not None:
            self.ipv6 = ipv6
        else:
            self.ipv6 = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()
        self_ipv6 = self.ipv6
        if self_ipv6 is not None:
            self_ipv6._parent = self
        if oam is not None:
            self.oam = oam
        else:
            self.oam = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()
        self_oam = self.oam
        if self_oam is not None:
            self_oam._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        _ipv6 = self.ipv6
        _oam = self.oam
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        if _oam is not None:
            children['oam'] = _oam.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(ipv4=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4.from_gdata(n.get_opt_container("ipv4")), ipv6=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6.from_gdata(n.get_opt_container("ipv6")), oam=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam.from_gdata(n.get_opt_container("oam")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(ipv4=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4.from_xml(yang.gdata.get_xml_opt_child(n, "ipv4")), ipv6=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6.from_xml(yang.gdata.get_xml_opt_child(n, "ipv6")), oam=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam.from_xml(yang.gdata.get_xml_opt_child(n, "oam")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:ipv4' or point == 'ipv4':
            child = {'ipv4': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:ipv6' or point == 'ipv6':
            child = {'ipv6': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:oam' or point == 'oam':
            child = {'oam': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_full = jd.get('l3vpn-svc:ipv4')
    child_ipv4 = child_ipv4_full if child_ipv4_full is not None else jd.get('ipv4')
    if child_ipv4 is not None and isinstance(child_ipv4, dict):
        children['ipv4'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(child_ipv4)
    child_ipv6_full = jd.get('l3vpn-svc:ipv6')
    child_ipv6 = child_ipv6_full if child_ipv6_full is not None else jd.get('ipv6')
    if child_ipv6 is not None and isinstance(child_ipv6, dict):
        children['ipv6'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(child_ipv6)
    child_oam_full = jd.get('l3vpn-svc:oam')
    child_oam = child_oam_full if child_oam_full is not None else jd.get('oam')
    if child_oam is not None and isinstance(child_oam, dict):
        children['oam'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(child_oam)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_ipv4 = n.children.get('ipv4')
    if child_ipv4 is not None:
        if isinstance(child_ipv4, yang.gdata.Container):
            children['ipv4'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(child_ipv4)
    child_ipv6 = n.children.get('ipv6')
    if child_ipv6 is not None:
        if isinstance(child_ipv6, yang.gdata.Container):
            children['ipv6'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(child_ipv6)
    child_oam = n.children.get('oam')
    if child_oam is not None:
        if isinstance(child_oam, yang.gdata.Container):
            children['oam'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(child_oam)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile_name = self.profile_name
        _algorithm = self.algorithm
        _preshared_key = self.preshared_key
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('string', _algorithm)
        if _preshared_key is not None:
            children['preshared-key'] = yang.gdata.Leaf('string', _preshared_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(profile_name=n.get_opt_str("profile-name"), algorithm=n.get_opt_str("algorithm"), preshared_key=n.get_opt_str("preshared-key"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(profile_name=yang.gdata.from_xml_opt_str(n, "profile-name"), algorithm=yang.gdata.from_xml_opt_str(n, "algorithm"), preshared_key=yang.gdata.from_xml_opt_str(n, "preshared-key"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:profile-name' or point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:algorithm' or point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:preshared-key' or point == 'preshared-key':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_name_full = jd.get('l3vpn-svc:profile-name')
    child_profile_name = child_profile_name_full if child_profile_name_full is not None else jd.get('profile-name')
    if child_profile_name is not None:
        children['profile-name'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name(child_profile_name)
    child_algorithm_full = jd.get('l3vpn-svc:algorithm')
    child_algorithm = child_algorithm_full if child_algorithm_full is not None else jd.get('algorithm')
    if child_algorithm is not None:
        children['algorithm'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm(child_algorithm)
    child_preshared_key_full = jd.get('l3vpn-svc:preshared-key')
    child_preshared_key = child_preshared_key_full if child_preshared_key_full is not None else jd.get('preshared-key')
    if child_preshared_key is not None:
        children['preshared-key'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key(child_preshared_key)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_profile_name = n.children.get('profile-name')
    if child_profile_name is not None:
        if isinstance(child_profile_name, yang.gdata.Leaf):
            children['profile-name'] = child_profile_name.val
    child_algorithm = n.children.get('algorithm')
    if child_algorithm is not None:
        if isinstance(child_algorithm, yang.gdata.Leaf):
            children['algorithm'] = child_algorithm.val
    child_preshared_key = n.children.get('preshared-key')
    if child_preshared_key is not None:
        if isinstance(child_preshared_key, yang.gdata.Leaf):
            children['preshared-key'] = child_preshared_key.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(yang.adata.MNode):
    enabled: ?bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.enabled = enabled
        self.layer = layer
        if encryption_profile is not None:
            self.encryption_profile = encryption_profile
        else:
            self.encryption_profile = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()
        self_encryption_profile = self.encryption_profile
        if self_encryption_profile is not None:
            self_encryption_profile._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        _layer = self.layer
        _encryption_profile = self.encryption_profile
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        if _layer is not None:
            children['layer'] = yang.gdata.Leaf('enumeration', _layer)
        if _encryption_profile is not None:
            children['encryption-profile'] = _encryption_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(enabled=n.get_opt_bool("enabled"), layer=n.get_opt_str("layer"), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile.from_gdata(n.get_opt_container("encryption-profile")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(enabled=yang.gdata.from_xml_opt_bool(n, "enabled"), layer=yang.gdata.from_xml_opt_str(n, "layer"), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile.from_xml(yang.gdata.get_xml_opt_child(n, "encryption-profile")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:enabled' or point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:layer' or point == 'layer':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:encryption-profile' or point == 'encryption-profile':
            child = {'encryption-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled_full = jd.get('l3vpn-svc:enabled')
    child_enabled = child_enabled_full if child_enabled_full is not None else jd.get('enabled')
    if child_enabled is not None:
        children['enabled'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled(child_enabled)
    child_layer_full = jd.get('l3vpn-svc:layer')
    child_layer = child_layer_full if child_layer_full is not None else jd.get('layer')
    if child_layer is not None:
        children['layer'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer(child_layer)
    child_encryption_profile_full = jd.get('l3vpn-svc:encryption-profile')
    child_encryption_profile = child_encryption_profile_full if child_encryption_profile_full is not None else jd.get('encryption-profile')
    if child_encryption_profile is not None and isinstance(child_encryption_profile, dict):
        children['encryption-profile'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(child_encryption_profile)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_enabled = n.children.get('enabled')
    if child_enabled is not None:
        if isinstance(child_enabled, yang.gdata.Leaf):
            children['enabled'] = child_enabled.val
    child_layer = n.children.get('layer')
    if child_layer is not None:
        if isinstance(child_layer, yang.gdata.Leaf):
            children['layer'] = child_layer.val
    child_encryption_profile = n.children.get('encryption-profile')
    if child_encryption_profile is not None:
        if isinstance(child_encryption_profile, yang.gdata.Container):
            children['encryption-profile'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(child_encryption_profile)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if authentication is not None:
            self.authentication = authentication
        else:
            self.authentication = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        self_authentication = self.authentication
        if self_authentication is not None:
            self_authentication._parent = self
        if encryption is not None:
            self.encryption = encryption
        else:
            self.encryption = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()
        self_encryption = self.encryption
        if self_encryption is not None:
            self_encryption._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _authentication = self.authentication
        _encryption = self.encryption
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        if _encryption is not None:
            children['encryption'] = _encryption.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication.from_gdata(n.get_opt_container("authentication")), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption.from_gdata(n.get_opt_container("encryption")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication.from_xml(yang.gdata.get_xml_opt_child(n, "authentication")), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption.from_xml(yang.gdata.get_xml_opt_child(n, "encryption")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:authentication' or point == 'authentication':
            child = {'authentication': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:encryption' or point == 'encryption':
            child = {'encryption': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_authentication_full = jd.get('l3vpn-svc:authentication')
    child_authentication = child_authentication_full if child_authentication_full is not None else jd.get('authentication')
    if child_authentication is not None and isinstance(child_authentication, dict):
        children['authentication'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(child_authentication)
    child_encryption_full = jd.get('l3vpn-svc:encryption')
    child_encryption = child_encryption_full if child_encryption_full is not None else jd.get('encryption')
    if child_encryption is not None and isinstance(child_encryption, dict):
        children['encryption'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(child_encryption)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_authentication = n.children.get('authentication')
    if child_authentication is not None:
        if isinstance(child_authentication, yang.gdata.Container):
            children['authentication'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(child_authentication)
    child_encryption = n.children.get('encryption')
    if child_encryption is not None:
        if isinstance(child_encryption, yang.gdata.Container):
            children['encryption'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(child_encryption)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint64", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint64", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint8", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        _upper_port = self.upper_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_int("lower-port"), upper_port=n.get_opt_int("upper-port"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=yang.gdata.from_xml_opt_int(n, "lower-port"), upper_port=yang.gdata.from_xml_opt_int(n, "upper-port"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:lower-port' or point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:upper-port' or point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port_full = jd.get('l3vpn-svc:lower-port')
    child_lower_port = child_lower_port_full if child_lower_port_full is not None else jd.get('lower-port')
    if child_lower_port is not None:
        children['lower-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(child_lower_port)
    child_upper_port_full = jd.get('l3vpn-svc:upper-port')
    child_upper_port = child_upper_port_full if child_upper_port_full is not None else jd.get('upper-port')
    if child_upper_port is not None:
        children['upper-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(child_upper_port)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_lower_port = n.children.get('lower-port')
    if child_lower_port is not None:
        if isinstance(child_lower_port, yang.gdata.Leaf):
            children['lower-port'] = child_lower_port.val
    child_upper_port = n.children.get('upper-port')
    if child_upper_port is not None:
        if isinstance(child_upper_port, yang.gdata.Leaf):
            children['upper-port'] = child_upper_port.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        _upper_port = self.upper_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_int("lower-port"), upper_port=n.get_opt_int("upper-port"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=yang.gdata.from_xml_opt_int(n, "lower-port"), upper_port=yang.gdata.from_xml_opt_int(n, "upper-port"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:lower-port' or point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:upper-port' or point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port_full = jd.get('l3vpn-svc:lower-port')
    child_lower_port = child_lower_port_full if child_lower_port_full is not None else jd.get('lower-port')
    if child_lower_port is not None:
        children['lower-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(child_lower_port)
    child_upper_port_full = jd.get('l3vpn-svc:upper-port')
    child_upper_port = child_upper_port_full if child_upper_port_full is not None else jd.get('upper-port')
    if child_upper_port is not None:
        children['upper-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(child_upper_port)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_lower_port = n.children.get('lower-port')
    if child_lower_port is not None:
        if isinstance(child_lower_port, yang.gdata.Leaf):
            children['lower-port'] = child_lower_port.val
    child_upper_port = n.children.get('upper-port')
    if child_upper_port is not None:
        if isinstance(child_upper_port, yang.gdata.Leaf):
            children['upper-port'] = child_upper_port.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("union", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?int
    dot1p: ?int
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?int
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?int
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?int, dot1p: ?int, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?int, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?int, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        if target_sites is not None:
            self.target_sites = target_sites
        else:
            self.target_sites = []
        if l4_src_port_range is not None:
            self.l4_src_port_range = l4_src_port_range
        else:
            self.l4_src_port_range = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self_l4_src_port_range = self.l4_src_port_range
        if self_l4_src_port_range is not None:
            self_l4_src_port_range._parent = self
        self.l4_dst_port = l4_dst_port
        if l4_dst_port_range is not None:
            self.l4_dst_port_range = l4_dst_port_range
        else:
            self.l4_dst_port_range = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self_l4_dst_port_range = self.l4_dst_port_range
        if self_l4_dst_port_range is not None:
            self_l4_dst_port_range._parent = self
        self.protocol_field = protocol_field

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _dscp = self.dscp
        _dot1p = self.dot1p
        _ipv4_src_prefix = self.ipv4_src_prefix
        _ipv6_src_prefix = self.ipv6_src_prefix
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        _l4_src_port = self.l4_src_port
        _l4_src_port_range = self.l4_src_port_range
        _l4_dst_port = self.l4_dst_port
        _l4_dst_port_range = self.l4_dst_port_range
        _protocol_field = self.protocol_field
        if _dscp is not None:
            children['dscp'] = yang.gdata.Leaf('uint8', _dscp)
        if _dot1p is not None:
            children['dot1p'] = yang.gdata.Leaf('uint8', _dot1p)
        if _ipv4_src_prefix is not None:
            children['ipv4-src-prefix'] = yang.gdata.Leaf('string', _ipv4_src_prefix)
        if _ipv6_src_prefix is not None:
            children['ipv6-src-prefix'] = yang.gdata.Leaf('string', _ipv6_src_prefix)
        if _ipv4_dst_prefix is not None:
            children['ipv4-dst-prefix'] = yang.gdata.Leaf('string', _ipv4_dst_prefix)
        if _ipv6_dst_prefix is not None:
            children['ipv6-dst-prefix'] = yang.gdata.Leaf('string', _ipv6_dst_prefix)
        if _l4_src_port is not None:
            children['l4-src-port'] = yang.gdata.Leaf('uint16', _l4_src_port)
        children['target-sites'] = yang.gdata.LeafList(self.target_sites)
        if _l4_src_port_range is not None:
            children['l4-src-port-range'] = _l4_src_port_range.to_gdata()
        if _l4_dst_port is not None:
            children['l4-dst-port'] = yang.gdata.Leaf('uint16', _l4_dst_port)
        if _l4_dst_port_range is not None:
            children['l4-dst-port-range'] = _l4_dst_port_range.to_gdata()
        if _protocol_field is not None:
            children['protocol-field'] = yang.gdata.Leaf('union', _protocol_field)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_int("dscp"), dot1p=n.get_opt_int("dot1p"), ipv4_src_prefix=n.get_opt_str("ipv4-src-prefix"), ipv6_src_prefix=n.get_opt_str("ipv6-src-prefix"), ipv4_dst_prefix=n.get_opt_str("ipv4-dst-prefix"), ipv6_dst_prefix=n.get_opt_str("ipv6-dst-prefix"), l4_src_port=n.get_opt_int("l4-src-port"), target_sites=n.get_opt_strs("target-sites"), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_container("l4-src-port-range")), l4_dst_port=n.get_opt_int("l4-dst-port"), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_container("l4-dst-port-range")), protocol_field=n.get_opt_value("protocol-field"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(dscp=yang.gdata.from_xml_opt_int(n, "dscp"), dot1p=yang.gdata.from_xml_opt_int(n, "dot1p"), ipv4_src_prefix=yang.gdata.from_xml_opt_str(n, "ipv4-src-prefix"), ipv6_src_prefix=yang.gdata.from_xml_opt_str(n, "ipv6-src-prefix"), ipv4_dst_prefix=yang.gdata.from_xml_opt_str(n, "ipv4-dst-prefix"), ipv6_dst_prefix=yang.gdata.from_xml_opt_str(n, "ipv6-dst-prefix"), l4_src_port=yang.gdata.from_xml_opt_int(n, "l4-src-port"), target_sites=yang.gdata.from_xml_opt_strs(n, "target-sites"), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_xml(yang.gdata.get_xml_opt_child(n, "l4-src-port-range")), l4_dst_port=yang.gdata.from_xml_opt_int(n, "l4-dst-port"), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_xml(yang.gdata.get_xml_opt_child(n, "l4-dst-port-range")), protocol_field=yang.gdata.from_xml_opt_value(n, "protocol-field"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:dscp' or point == 'dscp':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:dot1p' or point == 'dot1p':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv4-src-prefix' or point == 'ipv4-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv6-src-prefix' or point == 'ipv6-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv4-dst-prefix' or point == 'ipv4-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv6-dst-prefix' or point == 'ipv6-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:l4-src-port' or point == 'l4-src-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:target-sites' or point == 'target-sites':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:l4-src-port-range' or point == 'l4-src-port-range':
            child = {'l4-src-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:l4-dst-port' or point == 'l4-dst-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:l4-dst-port-range' or point == 'l4-dst-port-range':
            child = {'l4-dst-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:protocol-field' or point == 'protocol-field':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_dscp_full = jd.get('l3vpn-svc:dscp')
    child_dscp = child_dscp_full if child_dscp_full is not None else jd.get('dscp')
    if child_dscp is not None:
        children['dscp'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp(child_dscp)
    child_dot1p_full = jd.get('l3vpn-svc:dot1p')
    child_dot1p = child_dot1p_full if child_dot1p_full is not None else jd.get('dot1p')
    if child_dot1p is not None:
        children['dot1p'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p(child_dot1p)
    child_ipv4_src_prefix_full = jd.get('l3vpn-svc:ipv4-src-prefix')
    child_ipv4_src_prefix = child_ipv4_src_prefix_full if child_ipv4_src_prefix_full is not None else jd.get('ipv4-src-prefix')
    if child_ipv4_src_prefix is not None:
        children['ipv4-src-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(child_ipv4_src_prefix)
    child_ipv6_src_prefix_full = jd.get('l3vpn-svc:ipv6-src-prefix')
    child_ipv6_src_prefix = child_ipv6_src_prefix_full if child_ipv6_src_prefix_full is not None else jd.get('ipv6-src-prefix')
    if child_ipv6_src_prefix is not None:
        children['ipv6-src-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(child_ipv6_src_prefix)
    child_ipv4_dst_prefix_full = jd.get('l3vpn-svc:ipv4-dst-prefix')
    child_ipv4_dst_prefix = child_ipv4_dst_prefix_full if child_ipv4_dst_prefix_full is not None else jd.get('ipv4-dst-prefix')
    if child_ipv4_dst_prefix is not None:
        children['ipv4-dst-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(child_ipv4_dst_prefix)
    child_ipv6_dst_prefix_full = jd.get('l3vpn-svc:ipv6-dst-prefix')
    child_ipv6_dst_prefix = child_ipv6_dst_prefix_full if child_ipv6_dst_prefix_full is not None else jd.get('ipv6-dst-prefix')
    if child_ipv6_dst_prefix is not None:
        children['ipv6-dst-prefix'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(child_ipv6_dst_prefix)
    child_l4_src_port_full = jd.get('l3vpn-svc:l4-src-port')
    child_l4_src_port = child_l4_src_port_full if child_l4_src_port_full is not None else jd.get('l4-src-port')
    if child_l4_src_port is not None:
        children['l4-src-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(child_l4_src_port)
    child_target_sites_full = jd.get('l3vpn-svc:target-sites')
    child_target_sites = child_target_sites_full if child_target_sites_full is not None else jd.get('target-sites')
    if child_target_sites is not None and isinstance(child_target_sites, list):
        children['target-sites'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites(child_target_sites)
    child_l4_src_port_range_full = jd.get('l3vpn-svc:l4-src-port-range')
    child_l4_src_port_range = child_l4_src_port_range_full if child_l4_src_port_range_full is not None else jd.get('l4-src-port-range')
    if child_l4_src_port_range is not None and isinstance(child_l4_src_port_range, dict):
        children['l4-src-port-range'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(child_l4_src_port_range)
    child_l4_dst_port_full = jd.get('l3vpn-svc:l4-dst-port')
    child_l4_dst_port = child_l4_dst_port_full if child_l4_dst_port_full is not None else jd.get('l4-dst-port')
    if child_l4_dst_port is not None:
        children['l4-dst-port'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(child_l4_dst_port)
    child_l4_dst_port_range_full = jd.get('l3vpn-svc:l4-dst-port-range')
    child_l4_dst_port_range = child_l4_dst_port_range_full if child_l4_dst_port_range_full is not None else jd.get('l4-dst-port-range')
    if child_l4_dst_port_range is not None and isinstance(child_l4_dst_port_range, dict):
        children['l4-dst-port-range'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(child_l4_dst_port_range)
    child_protocol_field_full = jd.get('l3vpn-svc:protocol-field')
    child_protocol_field = child_protocol_field_full if child_protocol_field_full is not None else jd.get('protocol-field')
    if child_protocol_field is not None:
        children['protocol-field'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field(child_protocol_field)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_dscp = n.children.get('dscp')
    if child_dscp is not None:
        if isinstance(child_dscp, yang.gdata.Leaf):
            children['dscp'] = child_dscp.val
    child_dot1p = n.children.get('dot1p')
    if child_dot1p is not None:
        if isinstance(child_dot1p, yang.gdata.Leaf):
            children['dot1p'] = child_dot1p.val
    child_ipv4_src_prefix = n.children.get('ipv4-src-prefix')
    if child_ipv4_src_prefix is not None:
        if isinstance(child_ipv4_src_prefix, yang.gdata.Leaf):
            children['ipv4-src-prefix'] = child_ipv4_src_prefix.val
    child_ipv6_src_prefix = n.children.get('ipv6-src-prefix')
    if child_ipv6_src_prefix is not None:
        if isinstance(child_ipv6_src_prefix, yang.gdata.Leaf):
            children['ipv6-src-prefix'] = child_ipv6_src_prefix.val
    child_ipv4_dst_prefix = n.children.get('ipv4-dst-prefix')
    if child_ipv4_dst_prefix is not None:
        if isinstance(child_ipv4_dst_prefix, yang.gdata.Leaf):
            children['ipv4-dst-prefix'] = child_ipv4_dst_prefix.val
    child_ipv6_dst_prefix = n.children.get('ipv6-dst-prefix')
    if child_ipv6_dst_prefix is not None:
        if isinstance(child_ipv6_dst_prefix, yang.gdata.Leaf):
            children['ipv6-dst-prefix'] = child_ipv6_dst_prefix.val
    child_l4_src_port = n.children.get('l4-src-port')
    if child_l4_src_port is not None:
        if isinstance(child_l4_src_port, yang.gdata.Leaf):
            children['l4-src-port'] = child_l4_src_port.val
    child_target_sites = n.children.get('target-sites')
    if child_target_sites is not None:
        if isinstance(child_target_sites, yang.gdata.LeafList):
            children['target-sites'] = child_target_sites.vals
    child_l4_src_port_range = n.children.get('l4-src-port-range')
    if child_l4_src_port_range is not None:
        if isinstance(child_l4_src_port_range, yang.gdata.Container):
            children['l4-src-port-range'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(child_l4_src_port_range)
    child_l4_dst_port = n.children.get('l4-dst-port')
    if child_l4_dst_port is not None:
        if isinstance(child_l4_dst_port, yang.gdata.Leaf):
            children['l4-dst-port'] = child_l4_dst_port.val
    child_l4_dst_port_range = n.children.get('l4-dst-port-range')
    if child_l4_dst_port_range is not None:
        if isinstance(child_l4_dst_port_range, yang.gdata.Container):
            children['l4-dst-port-range'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(child_l4_dst_port_range)
    child_protocol_field = n.children.get('protocol-field')
    if child_protocol_field is not None:
        if isinstance(child_protocol_field, yang.gdata.Leaf):
            children['protocol-field'] = child_protocol_field.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?str
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?str, target_class_id: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.id = id
        if match_flow is not None:
            self.match_flow = match_flow
        else:
            self.match_flow = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()
        self_match_flow = self.match_flow
        if self_match_flow is not None:
            self_match_flow._parent = self
        self.match_application = match_application
        self.target_class_id = target_class_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        _match_flow = self.match_flow
        _match_application = self.match_application
        _target_class_id = self.target_class_id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        if _match_flow is not None:
            children['match-flow'] = _match_flow.to_gdata()
        if _match_application is not None:
            children['match-application'] = yang.gdata.Leaf('identityref', _match_application)
        if _target_class_id is not None:
            children['target-class-id'] = yang.gdata.Leaf('string', _target_class_id)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id=n.get_str("id"), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_container("match-flow")), match_application=n.get_opt_str("match-application"), target_class_id=n.get_opt_str("target-class-id"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id=yang.gdata.from_xml_str(n, "id"), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow.from_xml(yang.gdata.get_xml_opt_child(n, "match-flow")), match_application=yang.gdata.from_xml_opt_str(n, "match-application"), target_class_id=yang.gdata.from_xml_opt_str(n, "target-class-id"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'match-flow':
            children['match-flow'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd, rest_path, op)
        if point == 'match-application':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-class-id':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_id_full = jd.get('l3vpn-svc:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(child_id)
    child_match_flow_full = jd.get('l3vpn-svc:match-flow')
    child_match_flow = child_match_flow_full if child_match_flow_full is not None else jd.get('match-flow')
    if child_match_flow is not None and isinstance(child_match_flow, dict):
        children['match-flow'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(child_match_flow)
    child_match_application_full = jd.get('l3vpn-svc:match-application')
    child_match_application = child_match_application_full if child_match_application_full is not None else jd.get('match-application')
    if child_match_application is not None:
        children['match-application'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application(child_match_application)
    child_target_class_id_full = jd.get('l3vpn-svc:target-class-id')
    child_target_class_id = child_target_class_id_full if child_target_class_id_full is not None else jd.get('target-class-id')
    if child_target_class_id is not None:
        children['target-class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id(child_target_class_id)
    return yang.gdata.ListElement([str(child_id if child_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    child_match_flow = n.children.get('match-flow')
    if child_match_flow is not None:
        if isinstance(child_match_flow, yang.gdata.Container):
            children['match-flow'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(child_match_flow)
    child_match_application = n.children.get('match-application')
    if child_match_application is not None:
        if isinstance(child_match_application, yang.gdata.Leaf):
            children['match-application'] = child_match_application.val
    child_target_class_id = n.children.get('target-class-id')
    if child_target_class_id is not None:
        if isinstance(child_target_class_id, yang.gdata.Leaf):
            children['target-class-id'] = child_target_class_id.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(elements=rule)
        self.rule._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rule = self.rule
        if _rule is not None:
            children['rule'] = _rule.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list("rule")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule.from_xml(yang.gdata.get_xml_children(n, "rule")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:rule' or point == 'rule':
            child = {'rule': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rule_full = jd.get('l3vpn-svc:rule')
    child_rule = child_rule_full if child_rule_full is not None else jd.get('rule')
    if child_rule is not None and isinstance(child_rule, list):
        children['rule'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(child_rule)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_rule = n.children.get('rule')
    if child_rule is not None:
        if isinstance(child_rule, yang.gdata.List):
            children['rule'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(child_rule)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("decimal64", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: ?int

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_latency = self.use_lowest_latency
        _latency_boundary = self.latency_boundary
        if _use_lowest_latency is not None:
            children['use-lowest-latency'] = yang.gdata.Leaf('empty', _use_lowest_latency)
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint16', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_bool("use-lowest-latency"), latency_boundary=n.get_opt_int("latency-boundary"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(use_lowest_latency=yang.gdata.from_xml_opt_bool(n, "use-lowest-latency"), latency_boundary=yang.gdata.from_xml_opt_int(n, "latency-boundary"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:use-lowest-latency' or point == 'use-lowest-latency':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:latency-boundary' or point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency_full = jd.get('l3vpn-svc:use-lowest-latency')
    child_use_lowest_latency = child_use_lowest_latency_full if child_use_lowest_latency_full is not None else jd.get('use-lowest-latency')
    if child_use_lowest_latency is not None:
        children['use-lowest-latency'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency(child_use_lowest_latency)
    child_latency_boundary_full = jd.get('l3vpn-svc:latency-boundary')
    child_latency_boundary = child_latency_boundary_full if child_latency_boundary_full is not None else jd.get('latency-boundary')
    if child_latency_boundary is not None:
        children['latency-boundary'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary(child_latency_boundary)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_use_lowest_latency = n.children.get('use-lowest-latency')
    if child_use_lowest_latency is not None:
        if isinstance(child_use_lowest_latency, yang.gdata.Leaf):
            children['use-lowest-latency'] = child_use_lowest_latency.val
    child_latency_boundary = n.children.get('latency-boundary')
    if child_latency_boundary is not None:
        if isinstance(child_latency_boundary, yang.gdata.Leaf):
            children['latency-boundary'] = child_latency_boundary.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: ?int

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_jitter = self.use_lowest_jitter
        _latency_boundary = self.latency_boundary
        if _use_lowest_jitter is not None:
            children['use-lowest-jitter'] = yang.gdata.Leaf('empty', _use_lowest_jitter)
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint32', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_bool("use-lowest-jitter"), latency_boundary=n.get_opt_int("latency-boundary"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=yang.gdata.from_xml_opt_bool(n, "use-lowest-jitter"), latency_boundary=yang.gdata.from_xml_opt_int(n, "latency-boundary"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:use-lowest-jitter' or point == 'use-lowest-jitter':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:latency-boundary' or point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter_full = jd.get('l3vpn-svc:use-lowest-jitter')
    child_use_lowest_jitter = child_use_lowest_jitter_full if child_use_lowest_jitter_full is not None else jd.get('use-lowest-jitter')
    if child_use_lowest_jitter is not None:
        children['use-lowest-jitter'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(child_use_lowest_jitter)
    child_latency_boundary_full = jd.get('l3vpn-svc:latency-boundary')
    child_latency_boundary = child_latency_boundary_full if child_latency_boundary_full is not None else jd.get('latency-boundary')
    if child_latency_boundary is not None:
        children['latency-boundary'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary(child_latency_boundary)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_use_lowest_jitter = n.children.get('use-lowest-jitter')
    if child_use_lowest_jitter is not None:
        if isinstance(child_use_lowest_jitter, yang.gdata.Leaf):
            children['use-lowest-jitter'] = child_use_lowest_jitter.val
    child_latency_boundary = n.children.get('latency-boundary')
    if child_latency_boundary is not None:
        if isinstance(child_latency_boundary, yang.gdata.Leaf):
            children['latency-boundary'] = child_latency_boundary.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("decimal64", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: ?float
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: ?float, end_to_end: ?bool):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _guaranteed_bw_percent = self.guaranteed_bw_percent
        _end_to_end = self.end_to_end
        if _guaranteed_bw_percent is not None:
            children['guaranteed-bw-percent'] = yang.gdata.Leaf('decimal64', _guaranteed_bw_percent)
        if _end_to_end is not None:
            children['end-to-end'] = yang.gdata.Leaf('empty', _end_to_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_opt_float("guaranteed-bw-percent"), end_to_end=n.get_opt_bool("end-to-end"))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth")

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=yang.gdata.from_xml_opt_float(n, "guaranteed-bw-percent"), end_to_end=yang.gdata.from_xml_opt_bool(n, "end-to-end"))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth")


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:guaranteed-bw-percent' or point == 'guaranteed-bw-percent':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:end-to-end' or point == 'end-to-end':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent_full = jd.get('l3vpn-svc:guaranteed-bw-percent')
    child_guaranteed_bw_percent = child_guaranteed_bw_percent_full if child_guaranteed_bw_percent_full is not None else jd.get('guaranteed-bw-percent')
    if child_guaranteed_bw_percent is not None:
        children['guaranteed-bw-percent'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(child_guaranteed_bw_percent)
    child_end_to_end_full = jd.get('l3vpn-svc:end-to-end')
    child_end_to_end = child_end_to_end_full if child_end_to_end_full is not None else jd.get('end-to-end')
    if child_end_to_end is not None:
        children['end-to-end'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end(child_end_to_end)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_guaranteed_bw_percent = n.children.get('guaranteed-bw-percent')
    if child_guaranteed_bw_percent is not None:
        if isinstance(child_guaranteed_bw_percent, yang.gdata.Leaf):
            children['guaranteed-bw-percent'] = child_guaranteed_bw_percent.val
    child_end_to_end = n.children.get('end-to-end')
    if child_end_to_end is not None:
        if isinstance(child_end_to_end, yang.gdata.Leaf):
            children['end-to-end'] = child_end_to_end.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: ?str
    rate_limit: ?float
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, direction: ?str, rate_limit: ?float, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter=None, bandwidth: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.class_id = class_id
        self.direction = direction
        self.rate_limit = rate_limit
        if latency is not None:
            self.latency = latency
        else:
            self.latency = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()
        self_latency = self.latency
        if self_latency is not None:
            self_latency._parent = self
        if jitter is not None:
            self.jitter = jitter
        else:
            self.jitter = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()
        self_jitter = self.jitter
        if self_jitter is not None:
            self_jitter._parent = self
        if bandwidth is not None:
            self.bandwidth = bandwidth
        else:
            self.bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth()
        self_bandwidth = self.bandwidth
        if self_bandwidth is not None:
            self_bandwidth._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_id = self.class_id
        _direction = self.direction
        _rate_limit = self.rate_limit
        _latency = self.latency
        _jitter = self.jitter
        _bandwidth = self.bandwidth
        if _class_id is not None:
            children['class-id'] = yang.gdata.Leaf('string', _class_id)
        if _direction is not None:
            children['direction'] = yang.gdata.Leaf('identityref', _direction)
        if _rate_limit is not None:
            children['rate-limit'] = yang.gdata.Leaf('decimal64', _rate_limit)
        if _latency is not None:
            children['latency'] = _latency.to_gdata()
        if _jitter is not None:
            children['jitter'] = _jitter.to_gdata()
        if _bandwidth is not None:
            children['bandwidth'] = _bandwidth.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.class_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id=n.get_str("class-id"), direction=n.get_opt_str("direction"), rate_limit=n.get_opt_float("rate-limit"), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_container("latency")), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_container("jitter")), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_opt_container("bandwidth")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id=yang.gdata.from_xml_str(n, "class-id"), direction=yang.gdata.from_xml_opt_str(n, "direction"), rate_limit=yang.gdata.from_xml_opt_float(n, "rate-limit"), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency.from_xml(yang.gdata.get_xml_opt_child(n, "latency")), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter.from_xml(yang.gdata.get_xml_opt_child(n, "jitter")), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth.from_xml(yang.gdata.get_xml_opt_child(n, "bandwidth")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id):
        for e in self.elements:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['class-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['class-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'direction':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rate-limit':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency':
            children['latency'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd, rest_path, op)
        if point == 'jitter':
            children['jitter'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd, rest_path, op)
        if point == 'bandwidth':
            children['bandwidth'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['class-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['class-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['class-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_class_id_full = jd.get('l3vpn-svc:class-id')
    child_class_id = child_class_id_full if child_class_id_full is not None else jd.get('class-id')
    if child_class_id is not None:
        children['class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(child_class_id)
    child_direction_full = jd.get('l3vpn-svc:direction')
    child_direction = child_direction_full if child_direction_full is not None else jd.get('direction')
    if child_direction is not None:
        children['direction'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction(child_direction)
    child_rate_limit_full = jd.get('l3vpn-svc:rate-limit')
    child_rate_limit = child_rate_limit_full if child_rate_limit_full is not None else jd.get('rate-limit')
    if child_rate_limit is not None:
        children['rate-limit'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit(child_rate_limit)
    child_latency_full = jd.get('l3vpn-svc:latency')
    child_latency = child_latency_full if child_latency_full is not None else jd.get('latency')
    if child_latency is not None and isinstance(child_latency, dict):
        children['latency'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(child_latency)
    child_jitter_full = jd.get('l3vpn-svc:jitter')
    child_jitter = child_jitter_full if child_jitter_full is not None else jd.get('jitter')
    if child_jitter is not None and isinstance(child_jitter, dict):
        children['jitter'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(child_jitter)
    child_bandwidth_full = jd.get('l3vpn-svc:bandwidth')
    child_bandwidth = child_bandwidth_full if child_bandwidth_full is not None else jd.get('bandwidth')
    if child_bandwidth is not None and isinstance(child_bandwidth, dict):
        children['bandwidth'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(child_bandwidth)
    return yang.gdata.ListElement([str(child_class_id if child_class_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(e))
    return yang.gdata.List(keys=['class-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_class_id = n.children.get('class-id')
    if child_class_id is not None:
        if isinstance(child_class_id, yang.gdata.Leaf):
            children['class-id'] = child_class_id.val
    child_direction = n.children.get('direction')
    if child_direction is not None:
        if isinstance(child_direction, yang.gdata.Leaf):
            children['direction'] = child_direction.val
    child_rate_limit = n.children.get('rate-limit')
    if child_rate_limit is not None:
        if isinstance(child_rate_limit, yang.gdata.Leaf):
            children['rate-limit'] = child_rate_limit.val
    child_latency = n.children.get('latency')
    if child_latency is not None:
        if isinstance(child_latency, yang.gdata.Container):
            children['latency'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(child_latency)
    child_jitter = n.children.get('jitter')
    if child_jitter is not None:
        if isinstance(child_jitter, yang.gdata.Container):
            children['jitter'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(child_jitter)
    child_bandwidth = n.children.get('bandwidth')
    if child_bandwidth is not None:
        if isinstance(child_bandwidth, yang.gdata.Container):
            children['bandwidth'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(child_bandwidth)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(elements=class_)
        self.class_._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_ = self.class_
        if _class_ is not None:
            children['class'] = _class_.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list("class")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class.from_xml(yang.gdata.get_xml_children(n, "class")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:class' or point == 'class':
            child = {'class': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_class__full = jd.get('l3vpn-svc:class')
    child_class_ = child_class__full if child_class__full is not None else jd.get('class')
    if child_class_ is not None and isinstance(child_class_, list):
        children['class'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(child_class_)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_class_ = n.children.get('class')
    if child_class_ is not None:
        if isinstance(child_class_, yang.gdata.List):
            children['class'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(child_class_)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.profile = profile
        if classes is not None:
            self.classes = classes
        else:
            self.classes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()
        self_classes = self.classes
        if self_classes is not None:
            self_classes._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile = self.profile
        _classes = self.classes
        if _profile is not None:
            children['profile'] = yang.gdata.Leaf('leafref', _profile)
        if _classes is not None:
            children['classes'] = _classes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(profile=n.get_opt_str("profile"), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes.from_gdata(n.get_opt_container("classes")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(profile=yang.gdata.from_xml_opt_str(n, "profile"), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes.from_xml(yang.gdata.get_xml_opt_child(n, "classes")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:profile' or point == 'profile':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:classes' or point == 'classes':
            child = {'classes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_full = jd.get('l3vpn-svc:profile')
    child_profile = child_profile_full if child_profile_full is not None else jd.get('profile')
    if child_profile is not None:
        children['profile'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile(child_profile)
    child_classes_full = jd.get('l3vpn-svc:classes')
    child_classes = child_classes_full if child_classes_full is not None else jd.get('classes')
    if child_classes is not None and isinstance(child_classes, dict):
        children['classes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(child_classes)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_profile = n.children.get('profile')
    if child_profile is not None:
        if isinstance(child_profile, yang.gdata.Leaf):
            children['profile'] = child_profile.val
    child_classes = n.children.get('classes')
    if child_classes is not None:
        if isinstance(child_classes, yang.gdata.Container):
            children['classes'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(child_classes)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if qos_classification_policy is not None:
            self.qos_classification_policy = qos_classification_policy
        else:
            self.qos_classification_policy = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()
        self_qos_classification_policy = self.qos_classification_policy
        if self_qos_classification_policy is not None:
            self_qos_classification_policy._parent = self
        if qos_profile is not None:
            self.qos_profile = qos_profile
        else:
            self.qos_profile = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()
        self_qos_profile = self.qos_profile
        if self_qos_profile is not None:
            self_qos_profile._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos_classification_policy = self.qos_classification_policy
        _qos_profile = self.qos_profile
        if _qos_classification_policy is not None:
            children['qos-classification-policy'] = _qos_classification_policy.to_gdata()
        if _qos_profile is not None:
            children['qos-profile'] = _qos_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy.from_gdata(n.get_opt_container("qos-classification-policy")), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile.from_gdata(n.get_opt_container("qos-profile")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy.from_xml(yang.gdata.get_xml_opt_child(n, "qos-classification-policy")), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile.from_xml(yang.gdata.get_xml_opt_child(n, "qos-profile")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:qos-classification-policy' or point == 'qos-classification-policy':
            child = {'qos-classification-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:qos-profile' or point == 'qos-profile':
            child = {'qos-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy_full = jd.get('l3vpn-svc:qos-classification-policy')
    child_qos_classification_policy = child_qos_classification_policy_full if child_qos_classification_policy_full is not None else jd.get('qos-classification-policy')
    if child_qos_classification_policy is not None and isinstance(child_qos_classification_policy, dict):
        children['qos-classification-policy'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(child_qos_classification_policy)
    child_qos_profile_full = jd.get('l3vpn-svc:qos-profile')
    child_qos_profile = child_qos_profile_full if child_qos_profile_full is not None else jd.get('qos-profile')
    if child_qos_profile is not None and isinstance(child_qos_profile, dict):
        children['qos-profile'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(child_qos_profile)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_qos_classification_policy = n.children.get('qos-classification-policy')
    if child_qos_classification_policy is not None:
        if isinstance(child_qos_classification_policy, yang.gdata.Container):
            children['qos-classification-policy'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(child_qos_classification_policy)
    child_qos_profile = n.children.get('qos-profile')
    if child_qos_profile is not None:
        if isinstance(child_qos_profile, yang.gdata.Container):
            children['qos-profile'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(child_qos_profile)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(yang.adata.MNode):
    signalling_type: ?str

    mut def __init__(self, signalling_type: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.signalling_type = signalling_type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            children['signalling-type'] = yang.gdata.Leaf('enumeration', _signalling_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(signalling_type=n.get_opt_str("signalling-type"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(signalling_type=yang.gdata.from_xml_opt_str(n, "signalling-type"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:signalling-type' or point == 'signalling-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_signalling_type_full = jd.get('l3vpn-svc:signalling-type')
    child_signalling_type = child_signalling_type_full if child_signalling_type_full is not None else jd.get('signalling-type')
    if child_signalling_type is not None:
        children['signalling-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type(child_signalling_type)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_signalling_type = n.children.get('signalling-type')
    if child_signalling_type is not None:
        if isinstance(child_signalling_type, yang.gdata.Leaf):
            children['signalling-type'] = child_signalling_type.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("boolean", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: ?bool
    ipv6: ?bool

    mut def __init__(self, ipv4: ?bool, ipv6: ?bool):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.ipv4 = ipv4
        self.ipv6 = ipv6

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        _ipv6 = self.ipv6
        if _ipv4 is not None:
            children['ipv4'] = yang.gdata.Leaf('boolean', _ipv4)
        if _ipv6 is not None:
            children['ipv6'] = yang.gdata.Leaf('boolean', _ipv6)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(ipv4=n.get_opt_bool("ipv4"), ipv6=n.get_opt_bool("ipv6"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(ipv4=yang.gdata.from_xml_opt_bool(n, "ipv4"), ipv6=yang.gdata.from_xml_opt_bool(n, "ipv6"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:ipv4' or point == 'ipv4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:ipv6' or point == 'ipv6':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_full = jd.get('l3vpn-svc:ipv4')
    child_ipv4 = child_ipv4_full if child_ipv4_full is not None else jd.get('ipv4')
    if child_ipv4 is not None:
        children['ipv4'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4(child_ipv4)
    child_ipv6_full = jd.get('l3vpn-svc:ipv6')
    child_ipv6 = child_ipv6_full if child_ipv6_full is not None else jd.get('ipv6')
    if child_ipv6 is not None:
        children['ipv6'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6(child_ipv6)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_ipv4 = n.children.get('ipv4')
    if child_ipv4 is not None:
        if isinstance(child_ipv4, yang.gdata.Leaf):
            children['ipv4'] = child_ipv4.val
    child_ipv6 = n.children.get('ipv6')
    if child_ipv6 is not None:
        if isinstance(child_ipv6, yang.gdata.Leaf):
            children['ipv6'] = child_ipv6.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("enumeration", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(yang.adata.MNode):
    multicast_site_type: ?str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family
    protocol_type: ?str

    mut def __init__(self, multicast_site_type: ?str, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family=None, protocol_type: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.multicast_site_type = multicast_site_type
        if multicast_address_family is not None:
            self.multicast_address_family = multicast_address_family
        else:
            self.multicast_address_family = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()
        self_multicast_address_family = self.multicast_address_family
        if self_multicast_address_family is not None:
            self_multicast_address_family._parent = self
        self.protocol_type = protocol_type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _multicast_site_type = self.multicast_site_type
        _multicast_address_family = self.multicast_address_family
        _protocol_type = self.protocol_type
        if _multicast_site_type is not None:
            children['multicast-site-type'] = yang.gdata.Leaf('enumeration', _multicast_site_type)
        if _multicast_address_family is not None:
            children['multicast-address-family'] = _multicast_address_family.to_gdata()
        if _protocol_type is not None:
            children['protocol-type'] = yang.gdata.Leaf('enumeration', _protocol_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(multicast_site_type=n.get_opt_str("multicast-site-type"), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family.from_gdata(n.get_opt_container("multicast-address-family")), protocol_type=n.get_opt_str("protocol-type"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(multicast_site_type=yang.gdata.from_xml_opt_str(n, "multicast-site-type"), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family.from_xml(yang.gdata.get_xml_opt_child(n, "multicast-address-family")), protocol_type=yang.gdata.from_xml_opt_str(n, "protocol-type"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:multicast-site-type' or point == 'multicast-site-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:multicast-address-family' or point == 'multicast-address-family':
            child = {'multicast-address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:protocol-type' or point == 'protocol-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type_full = jd.get('l3vpn-svc:multicast-site-type')
    child_multicast_site_type = child_multicast_site_type_full if child_multicast_site_type_full is not None else jd.get('multicast-site-type')
    if child_multicast_site_type is not None:
        children['multicast-site-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type(child_multicast_site_type)
    child_multicast_address_family_full = jd.get('l3vpn-svc:multicast-address-family')
    child_multicast_address_family = child_multicast_address_family_full if child_multicast_address_family_full is not None else jd.get('multicast-address-family')
    if child_multicast_address_family is not None and isinstance(child_multicast_address_family, dict):
        children['multicast-address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(child_multicast_address_family)
    child_protocol_type_full = jd.get('l3vpn-svc:protocol-type')
    child_protocol_type = child_protocol_type_full if child_protocol_type_full is not None else jd.get('protocol-type')
    if child_protocol_type is not None:
        children['protocol-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type(child_protocol_type)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_multicast_site_type = n.children.get('multicast-site-type')
    if child_multicast_site_type is not None:
        if isinstance(child_multicast_site_type, yang.gdata.Leaf):
            children['multicast-site-type'] = child_multicast_site_type.val
    child_multicast_address_family = n.children.get('multicast-address-family')
    if child_multicast_address_family is not None:
        if isinstance(child_multicast_address_family, yang.gdata.Container):
            children['multicast-address-family'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(child_multicast_address_family)
    child_protocol_type = n.children.get('protocol-type')
    if child_protocol_type is not None:
        if isinstance(child_protocol_type, yang.gdata.Leaf):
            children['protocol-type'] = child_protocol_type.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(yang.adata.MNode):
    svc_input_bandwidth: ?int
    svc_output_bandwidth: ?int
    svc_mtu: ?int
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast

    mut def __init__(self, svc_input_bandwidth: ?int, svc_output_bandwidth: ?int, svc_mtu: ?int, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.svc_input_bandwidth = svc_input_bandwidth
        self.svc_output_bandwidth = svc_output_bandwidth
        self.svc_mtu = svc_mtu
        if qos is not None:
            self.qos = qos
        else:
            self.qos = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()
        self_qos = self.qos
        if self_qos is not None:
            self_qos._parent = self
        if carrierscarrier is not None:
            self.carrierscarrier = carrierscarrier
        else:
            self.carrierscarrier = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()
        self_carrierscarrier = self.carrierscarrier
        if self_carrierscarrier is not None:
            self_carrierscarrier._parent = self
        if multicast is not None:
            self.multicast = multicast
        else:
            self.multicast = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()
        self_multicast = self.multicast
        if self_multicast is not None:
            self_multicast._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _svc_input_bandwidth = self.svc_input_bandwidth
        _svc_output_bandwidth = self.svc_output_bandwidth
        _svc_mtu = self.svc_mtu
        _qos = self.qos
        _carrierscarrier = self.carrierscarrier
        _multicast = self.multicast
        if _svc_input_bandwidth is not None:
            children['svc-input-bandwidth'] = yang.gdata.Leaf('uint64', _svc_input_bandwidth)
        if _svc_output_bandwidth is not None:
            children['svc-output-bandwidth'] = yang.gdata.Leaf('uint64', _svc_output_bandwidth)
        if _svc_mtu is not None:
            children['svc-mtu'] = yang.gdata.Leaf('uint16', _svc_mtu)
        if _qos is not None:
            children['qos'] = _qos.to_gdata()
        if _carrierscarrier is not None:
            children['carrierscarrier'] = _carrierscarrier.to_gdata()
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(svc_input_bandwidth=n.get_opt_int("svc-input-bandwidth"), svc_output_bandwidth=n.get_opt_int("svc-output-bandwidth"), svc_mtu=n.get_opt_int("svc-mtu"), qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos.from_gdata(n.get_opt_container("qos")), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier.from_gdata(n.get_opt_container("carrierscarrier")), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast.from_gdata(n.get_opt_container("multicast")))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service")

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(svc_input_bandwidth=yang.gdata.from_xml_opt_int(n, "svc-input-bandwidth"), svc_output_bandwidth=yang.gdata.from_xml_opt_int(n, "svc-output-bandwidth"), svc_mtu=yang.gdata.from_xml_opt_int(n, "svc-mtu"), qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos.from_xml(yang.gdata.get_xml_opt_child(n, "qos")), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier.from_xml(yang.gdata.get_xml_opt_child(n, "carrierscarrier")), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast.from_xml(yang.gdata.get_xml_opt_child(n, "multicast")))
        raise ValueError("Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service")


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:svc-input-bandwidth' or point == 'svc-input-bandwidth':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:svc-output-bandwidth' or point == 'svc-output-bandwidth':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:svc-mtu' or point == 'svc-mtu':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:qos' or point == 'qos':
            child = {'qos': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:carrierscarrier' or point == 'carrierscarrier':
            child = {'carrierscarrier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:multicast' or point == 'multicast':
            child = {'multicast': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_svc_input_bandwidth_full = jd.get('l3vpn-svc:svc-input-bandwidth')
    child_svc_input_bandwidth = child_svc_input_bandwidth_full if child_svc_input_bandwidth_full is not None else jd.get('svc-input-bandwidth')
    if child_svc_input_bandwidth is not None:
        children['svc-input-bandwidth'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth(child_svc_input_bandwidth)
    child_svc_output_bandwidth_full = jd.get('l3vpn-svc:svc-output-bandwidth')
    child_svc_output_bandwidth = child_svc_output_bandwidth_full if child_svc_output_bandwidth_full is not None else jd.get('svc-output-bandwidth')
    if child_svc_output_bandwidth is not None:
        children['svc-output-bandwidth'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth(child_svc_output_bandwidth)
    child_svc_mtu_full = jd.get('l3vpn-svc:svc-mtu')
    child_svc_mtu = child_svc_mtu_full if child_svc_mtu_full is not None else jd.get('svc-mtu')
    if child_svc_mtu is not None:
        children['svc-mtu'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu(child_svc_mtu)
    child_qos_full = jd.get('l3vpn-svc:qos')
    child_qos = child_qos_full if child_qos_full is not None else jd.get('qos')
    if child_qos is not None and isinstance(child_qos, dict):
        children['qos'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(child_qos)
    child_carrierscarrier_full = jd.get('l3vpn-svc:carrierscarrier')
    child_carrierscarrier = child_carrierscarrier_full if child_carrierscarrier_full is not None else jd.get('carrierscarrier')
    if child_carrierscarrier is not None and isinstance(child_carrierscarrier, dict):
        children['carrierscarrier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(child_carrierscarrier)
    child_multicast_full = jd.get('l3vpn-svc:multicast')
    child_multicast = child_multicast_full if child_multicast_full is not None else jd.get('multicast')
    if child_multicast is not None and isinstance(child_multicast, dict):
        children['multicast'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(child_multicast)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_svc_input_bandwidth = n.children.get('svc-input-bandwidth')
    if child_svc_input_bandwidth is not None:
        if isinstance(child_svc_input_bandwidth, yang.gdata.Leaf):
            children['svc-input-bandwidth'] = child_svc_input_bandwidth.val
    child_svc_output_bandwidth = n.children.get('svc-output-bandwidth')
    if child_svc_output_bandwidth is not None:
        if isinstance(child_svc_output_bandwidth, yang.gdata.Leaf):
            children['svc-output-bandwidth'] = child_svc_output_bandwidth.val
    child_svc_mtu = n.children.get('svc-mtu')
    if child_svc_mtu is not None:
        if isinstance(child_svc_mtu, yang.gdata.Leaf):
            children['svc-mtu'] = child_svc_mtu.val
    child_qos = n.children.get('qos')
    if child_qos is not None:
        if isinstance(child_qos, yang.gdata.Container):
            children['qos'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(child_qos)
    child_carrierscarrier = n.children.get('carrierscarrier')
    if child_carrierscarrier is not None:
        if isinstance(child_carrierscarrier, yang.gdata.Container):
            children['carrierscarrier'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(child_carrierscarrier)
    child_multicast = n.children.get('multicast')
    if child_multicast is not None:
        if isinstance(child_multicast, yang.gdata.Container):
            children['multicast'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(child_multicast)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint16", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: ?int

    mut def __init__(self, target_site: str, metric: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.target_site = target_site
        self.metric = metric

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _target_site = self.target_site
        _metric = self.metric
        if _target_site is not None:
            children['target-site'] = yang.gdata.Leaf('string', _target_site)
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.target_site)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str("target-site"), metric=n.get_opt_int("metric"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=yang.gdata.from_xml_str(n, "target-site"), metric=yang.gdata.from_xml_opt_int(n, "metric"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self.elements:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['target-site'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['target-site']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['target-site']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['target-site'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['target-site'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_target_site_full = jd.get('l3vpn-svc:target-site')
    child_target_site = child_target_site_full if child_target_site_full is not None else jd.get('target-site')
    if child_target_site is not None:
        children['target-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(child_target_site)
    child_metric_full = jd.get('l3vpn-svc:metric')
    child_metric = child_metric_full if child_metric_full is not None else jd.get('metric')
    if child_metric is not None:
        children['metric'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(child_metric)
    return yang.gdata.ListElement([str(child_target_site if child_target_site is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e))
    return yang.gdata.List(keys=['target-site'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_target_site = n.children.get('target-site')
    if child_target_site is not None:
        if isinstance(child_target_site, yang.gdata.Leaf):
            children['target-site'] = child_target_site.val
    child_metric = n.children.get('metric')
    if child_metric is not None:
        if isinstance(child_metric, yang.gdata.Leaf):
            children['metric'] = child_metric.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)
        self.sham_link._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sham_link = self.sham_link
        if _sham_link is not None:
            children['sham-link'] = _sham_link.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list("sham-link")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_xml(yang.gdata.get_xml_children(n, "sham-link")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:sham-link' or point == 'sham-link':
            child = {'sham-link': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_sham_link_full = jd.get('l3vpn-svc:sham-link')
    child_sham_link = child_sham_link_full if child_sham_link_full is not None else jd.get('sham-link')
    if child_sham_link is not None and isinstance(child_sham_link, list):
        children['sham-link'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(child_sham_link)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_sham_link = n.children.get('sham-link')
    if child_sham_link is not None:
        if isinstance(child_sham_link, yang.gdata.List):
            children['sham-link'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(child_sham_link)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: ?str
    metric: ?int
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, address_family: ?list[str]=None, area_address: ?str, metric: ?int, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if address_family is not None:
            self.address_family = address_family
        else:
            self.address_family = []
        self.area_address = area_address
        self.metric = metric
        if sham_links is not None:
            self.sham_links = sham_links
        else:
            self.sham_links = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()
        self_sham_links = self.sham_links
        if self_sham_links is not None:
            self_sham_links._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _area_address = self.area_address
        _metric = self.metric
        _sham_links = self.sham_links
        children['address-family'] = yang.gdata.LeafList(self.address_family)
        if _area_address is not None:
            children['area-address'] = yang.gdata.Leaf('string', _area_address)
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        if _sham_links is not None:
            children['sham-links'] = _sham_links.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(address_family=n.get_opt_strs("address-family"), area_address=n.get_opt_str("area-address"), metric=n.get_opt_int("metric"), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_container("sham-links")))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(address_family=yang.gdata.from_xml_opt_strs(n, "address-family"), area_address=yang.gdata.from_xml_opt_str(n, "area-address"), metric=yang.gdata.from_xml_opt_int(n, "metric"), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links.from_xml(yang.gdata.get_xml_opt_child(n, "sham-links")))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:area-address' or point == 'area-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:metric' or point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:sham-links' or point == 'sham-links':
            child = {'sham-links': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, list):
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family(child_address_family)
    child_area_address_full = jd.get('l3vpn-svc:area-address')
    child_area_address = child_area_address_full if child_area_address_full is not None else jd.get('area-address')
    if child_area_address is not None:
        children['area-address'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address(child_area_address)
    child_metric_full = jd.get('l3vpn-svc:metric')
    child_metric = child_metric_full if child_metric_full is not None else jd.get('metric')
    if child_metric is not None:
        children['metric'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric(child_metric)
    child_sham_links_full = jd.get('l3vpn-svc:sham-links')
    child_sham_links = child_sham_links_full if child_sham_links_full is not None else jd.get('sham-links')
    if child_sham_links is not None and isinstance(child_sham_links, dict):
        children['sham-links'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(child_sham_links)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.LeafList):
            children['address-family'] = child_address_family.vals
    child_area_address = n.children.get('area-address')
    if child_area_address is not None:
        if isinstance(child_area_address, yang.gdata.Leaf):
            children['area-address'] = child_area_address.val
    child_metric = n.children.get('metric')
    if child_metric is not None:
        if isinstance(child_metric, yang.gdata.Leaf):
            children['metric'] = child_metric.val
    child_sham_links = n.children.get('sham-links')
    if child_sham_links is not None:
        if isinstance(child_sham_links, yang.gdata.Container):
            children['sham-links'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(child_sham_links)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: ?int
    address_family: list[str]

    mut def __init__(self, autonomous_system: ?int, address_family: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.autonomous_system = autonomous_system
        if address_family is not None:
            self.address_family = address_family
        else:
            self.address_family = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            children['autonomous-system'] = yang.gdata.Leaf('uint32', _autonomous_system)
        children['address-family'] = yang.gdata.LeafList(self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_opt_int("autonomous-system"), address_family=n.get_opt_strs("address-family"))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system=yang.gdata.from_xml_opt_int(n, "autonomous-system"), address_family=yang.gdata.from_xml_opt_strs(n, "address-family"))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:autonomous-system' or point == 'autonomous-system':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_autonomous_system_full = jd.get('l3vpn-svc:autonomous-system')
    child_autonomous_system = child_autonomous_system_full if child_autonomous_system_full is not None else jd.get('autonomous-system')
    if child_autonomous_system is not None:
        children['autonomous-system'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system(child_autonomous_system)
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, list):
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family(child_address_family)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_autonomous_system = n.children.get('autonomous-system')
    if child_autonomous_system is not None:
        if isinstance(child_autonomous_system, yang.gdata.Leaf):
            children['autonomous-system'] = child_autonomous_system.val
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.LeafList):
            children['address-family'] = child_address_family.vals
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        _next_hop = self.next_hop
        _lan_tag = self.lan_tag
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.lan), yang.gdata.yang_str(self.next_hop)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str("lan"), next_hop=n.get_str("next-hop"), lan_tag=n.get_opt_str("lan-tag"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=yang.gdata.from_xml_str(n, "lan"), next_hop=yang.gdata.from_xml_str(n, "next-hop"), lan_tag=yang.gdata.from_xml_opt_str(n, "lan-tag"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['lan', 'next-hop']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_lan_full = jd.get('l3vpn-svc:lan')
    child_lan = child_lan_full if child_lan_full is not None else jd.get('lan')
    if child_lan is not None:
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(child_lan)
    child_next_hop_full = jd.get('l3vpn-svc:next-hop')
    child_next_hop = child_next_hop_full if child_next_hop_full is not None else jd.get('next-hop')
    if child_next_hop is not None:
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(child_next_hop)
    child_lan_tag_full = jd.get('l3vpn-svc:lan-tag')
    child_lan_tag = child_lan_tag_full if child_lan_tag_full is not None else jd.get('lan-tag')
    if child_lan_tag is not None:
        children['lan-tag'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(child_lan_tag)
    return yang.gdata.ListElement([str(child_lan if child_lan is not None else ""), str(child_next_hop if child_next_hop is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e))
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_lan = n.children.get('lan')
    if child_lan is not None:
        if isinstance(child_lan, yang.gdata.Leaf):
            children['lan'] = child_lan.val
    child_next_hop = n.children.get('next-hop')
    if child_next_hop is not None:
        if isinstance(child_next_hop, yang.gdata.Leaf):
            children['next-hop'] = child_next_hop.val
    child_lan_tag = n.children.get('lan-tag')
    if child_lan_tag is not None:
        if isinstance(child_lan_tag, yang.gdata.Leaf):
            children['lan-tag'] = child_lan_tag.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e))
    return elements

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        _next_hop = self.next_hop
        _lan_tag = self.lan_tag
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.lan), yang.gdata.yang_str(self.next_hop)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str("lan"), next_hop=n.get_str("next-hop"), lan_tag=n.get_opt_str("lan-tag"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=yang.gdata.from_xml_str(n, "lan"), next_hop=yang.gdata.from_xml_str(n, "next-hop"), lan_tag=yang.gdata.from_xml_opt_str(n, "lan-tag"))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['lan', 'next-hop']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_lan_full = jd.get('l3vpn-svc:lan')
    child_lan = child_lan_full if child_lan_full is not None else jd.get('lan')
    if child_lan is not None:
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(child_lan)
    child_next_hop_full = jd.get('l3vpn-svc:next-hop')
    child_next_hop = child_next_hop_full if child_next_hop_full is not None else jd.get('next-hop')
    if child_next_hop is not None:
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(child_next_hop)
    child_lan_tag_full = jd.get('l3vpn-svc:lan-tag')
    child_lan_tag = child_lan_tag_full if child_lan_tag_full is not None else jd.get('lan-tag')
    if child_lan_tag is not None:
        children['lan-tag'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(child_lan_tag)
    return yang.gdata.ListElement([str(child_lan if child_lan is not None else ""), str(child_next_hop if child_next_hop is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e))
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_lan = n.children.get('lan')
    if child_lan is not None:
        if isinstance(child_lan, yang.gdata.Leaf):
            children['lan'] = child_lan.val
    child_next_hop = n.children.get('next-hop')
    if child_next_hop is not None:
        if isinstance(child_next_hop, yang.gdata.Leaf):
            children['next-hop'] = child_next_hop.val
    child_lan_tag = n.children.get('lan-tag')
    if child_lan_tag is not None:
        if isinstance(child_lan_tag, yang.gdata.Leaf):
            children['lan-tag'] = child_lan_tag.val
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv4_lan_prefixes._parent = self
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)
        self.ipv6_lan_prefixes._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        if _ipv4_lan_prefixes is not None:
            children['ipv4-lan-prefixes'] = _ipv4_lan_prefixes.to_gdata()
        if _ipv6_lan_prefixes is not None:
            children['ipv6-lan-prefixes'] = _ipv6_lan_prefixes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list("ipv4-lan-prefixes")), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list("ipv6-lan-prefixes")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_xml(yang.gdata.get_xml_children(n, "ipv4-lan-prefixes")), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_xml(yang.gdata.get_xml_children(n, "ipv6-lan-prefixes")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:ipv4-lan-prefixes' or point == 'ipv4-lan-prefixes':
            child = {'ipv4-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:ipv6-lan-prefixes' or point == 'ipv6-lan-prefixes':
            child = {'ipv6-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes_full = jd.get('l3vpn-svc:ipv4-lan-prefixes')
    child_ipv4_lan_prefixes = child_ipv4_lan_prefixes_full if child_ipv4_lan_prefixes_full is not None else jd.get('ipv4-lan-prefixes')
    if child_ipv4_lan_prefixes is not None and isinstance(child_ipv4_lan_prefixes, list):
        children['ipv4-lan-prefixes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes_full = jd.get('l3vpn-svc:ipv6-lan-prefixes')
    child_ipv6_lan_prefixes = child_ipv6_lan_prefixes_full if child_ipv6_lan_prefixes_full is not None else jd.get('ipv6-lan-prefixes')
    if child_ipv6_lan_prefixes is not None and isinstance(child_ipv6_lan_prefixes, list):
        children['ipv6-lan-prefixes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_ipv4_lan_prefixes = n.children.get('ipv4-lan-prefixes')
    if child_ipv4_lan_prefixes is not None:
        if isinstance(child_ipv4_lan_prefixes, yang.gdata.List):
            children['ipv4-lan-prefixes'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = n.children.get('ipv6-lan-prefixes')
    if child_ipv6_lan_prefixes is not None:
        if isinstance(child_ipv6_lan_prefixes, yang.gdata.List):
            children['ipv6-lan-prefixes'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(child_ipv6_lan_prefixes)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if cascaded_lan_prefixes is not None:
            self.cascaded_lan_prefixes = cascaded_lan_prefixes
        else:
            self.cascaded_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()
        self_cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if self_cascaded_lan_prefixes is not None:
            self_cascaded_lan_prefixes._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            children['cascaded-lan-prefixes'] = _cascaded_lan_prefixes.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_container("cascaded-lan-prefixes")))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_xml(yang.gdata.get_xml_opt_child(n, "cascaded-lan-prefixes")))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:cascaded-lan-prefixes' or point == 'cascaded-lan-prefixes':
            child = {'cascaded-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes_full = jd.get('l3vpn-svc:cascaded-lan-prefixes')
    child_cascaded_lan_prefixes = child_cascaded_lan_prefixes_full if child_cascaded_lan_prefixes_full is not None else jd.get('cascaded-lan-prefixes')
    if child_cascaded_lan_prefixes is not None and isinstance(child_cascaded_lan_prefixes, dict):
        children['cascaded-lan-prefixes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(child_cascaded_lan_prefixes)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_cascaded_lan_prefixes = n.children.get('cascaded-lan-prefixes')
    if child_cascaded_lan_prefixes is not None:
        if isinstance(child_cascaded_lan_prefixes, yang.gdata.Container):
            children['cascaded-lan-prefixes'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(child_cascaded_lan_prefixes)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if address_family is not None:
            self.address_family = address_family
        else:
            self.address_family = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList(self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(address_family=n.get_opt_strs("address-family"))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(address_family=yang.gdata.from_xml_opt_strs(n, "address-family"))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, list):
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family(child_address_family)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.LeafList):
            children['address-family'] = child_address_family.vals
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if address_family is not None:
            self.address_family = address_family
        else:
            self.address_family = []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList(self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(address_family=n.get_opt_strs("address-family"))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(address_family=yang.gdata.from_xml_opt_strs(n, "address-family"))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:address-family' or point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family_full = jd.get('l3vpn-svc:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, list):
        children['address-family'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family(child_address_family)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.LeafList):
            children['address-family'] = child_address_family.vals
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: str
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: str, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.type = type
        self.ospf = ospf
        self_ospf = self.ospf
        if self_ospf is not None:
            self_ospf._parent = self
        self.bgp = bgp
        self_bgp = self.bgp
        if self_bgp is not None:
            self_bgp._parent = self
        self.static = static
        self_static = self.static
        if self_static is not None:
            self_static._parent = self
        self.rip = rip
        self_rip = self.rip
        if self_rip is not None:
            self_rip._parent = self
        self.vrrp = vrrp
        self_vrrp = self.vrrp
        if self_vrrp is not None:
            self_vrrp._parent = self

    mut def create_ospf(self, area_address):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        _ospf = self.ospf
        _bgp = self.bgp
        _static = self.static
        _rip = self.rip
        _vrrp = self.vrrp
        if _type is not None:
            children['type'] = yang.gdata.Leaf('identityref', _type)
        if _ospf is not None:
            children['ospf'] = _ospf.to_gdata()
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        if _static is not None:
            children['static'] = _static.to_gdata()
        if _rip is not None:
            children['rip'] = _rip.to_gdata()
        if _vrrp is not None:
            children['vrrp'] = _vrrp.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.type)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type=n.get_str("type"), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_container("ospf")), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_container("bgp")), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_container("static")), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_container("rip")), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_container("vrrp")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type=yang.gdata.from_xml_str(n, "type"), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.from_xml(yang.gdata.get_xml_opt_child(n, "ospf")), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.from_xml(yang.gdata.get_xml_opt_child(n, "bgp")), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.from_xml(yang.gdata.get_xml_opt_child(n, "static")), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.from_xml(yang.gdata.get_xml_opt_child(n, "rip")), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.from_xml(yang.gdata.get_xml_opt_child(n, "vrrp")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self.elements:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['type']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'ospf':
            children['ospf'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd, rest_path, op)
        if point == 'bgp':
            children['bgp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd, rest_path, op)
        if point == 'static':
            children['static'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd, rest_path, op)
        if point == 'rip':
            children['rip'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd, rest_path, op)
        if point == 'vrrp':
            children['vrrp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_type_full = jd.get('l3vpn-svc:type')
    child_type = child_type_full if child_type_full is not None else jd.get('type')
    if child_type is not None:
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(child_type)
    child_ospf_full = jd.get('l3vpn-svc:ospf')
    child_ospf = child_ospf_full if child_ospf_full is not None else jd.get('ospf')
    if child_ospf is not None and isinstance(child_ospf, dict):
        children['ospf'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(child_ospf)
    child_bgp_full = jd.get('l3vpn-svc:bgp')
    child_bgp = child_bgp_full if child_bgp_full is not None else jd.get('bgp')
    if child_bgp is not None and isinstance(child_bgp, dict):
        children['bgp'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(child_bgp)
    child_static_full = jd.get('l3vpn-svc:static')
    child_static = child_static_full if child_static_full is not None else jd.get('static')
    if child_static is not None and isinstance(child_static, dict):
        children['static'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(child_static)
    child_rip_full = jd.get('l3vpn-svc:rip')
    child_rip = child_rip_full if child_rip_full is not None else jd.get('rip')
    if child_rip is not None and isinstance(child_rip, dict):
        children['rip'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(child_rip)
    child_vrrp_full = jd.get('l3vpn-svc:vrrp')
    child_vrrp = child_vrrp_full if child_vrrp_full is not None else jd.get('vrrp')
    if child_vrrp is not None and isinstance(child_vrrp, dict):
        children['vrrp'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(child_vrrp)
    return yang.gdata.ListElement([str(child_type if child_type is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(e))
    return yang.gdata.List(keys=['type'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_type = n.children.get('type')
    if child_type is not None:
        if isinstance(child_type, yang.gdata.Leaf):
            children['type'] = child_type.val
    child_ospf = n.children.get('ospf')
    if child_ospf is not None:
        if isinstance(child_ospf, yang.gdata.Container):
            children['ospf'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(child_ospf)
    child_bgp = n.children.get('bgp')
    if child_bgp is not None:
        if isinstance(child_bgp, yang.gdata.Container):
            children['bgp'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(child_bgp)
    child_static = n.children.get('static')
    if child_static is not None:
        if isinstance(child_static, yang.gdata.Container):
            children['static'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(child_static)
    child_rip = n.children.get('rip')
    if child_rip is not None:
        if isinstance(child_rip, yang.gdata.Container):
            children['rip'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(child_rip)
    child_vrrp = n.children.get('vrrp')
    if child_vrrp is not None:
        if isinstance(child_vrrp, yang.gdata.Container):
            children['vrrp'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(child_vrrp)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(elements=routing_protocol)
        self.routing_protocol._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _routing_protocol = self.routing_protocol
        if _routing_protocol is not None:
            children['routing-protocol'] = _routing_protocol.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol.from_gdata(n.get_opt_list("routing-protocol")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol.from_xml(yang.gdata.get_xml_children(n, "routing-protocol")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:routing-protocol' or point == 'routing-protocol':
            child = {'routing-protocol': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_routing_protocol_full = jd.get('l3vpn-svc:routing-protocol')
    child_routing_protocol = child_routing_protocol_full if child_routing_protocol_full is not None else jd.get('routing-protocol')
    if child_routing_protocol is not None and isinstance(child_routing_protocol, list):
        children['routing-protocol'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(child_routing_protocol)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_routing_protocol = n.children.get('routing-protocol')
    if child_routing_protocol is not None:
        if isinstance(child_routing_protocol, yang.gdata.List):
            children['routing-protocol'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(child_routing_protocol)
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(yang.adata.MNode):
    access_priority: ?int

    mut def __init__(self, access_priority: ?int):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.access_priority = access_priority

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _access_priority = self.access_priority
        if _access_priority is not None:
            children['access-priority'] = yang.gdata.Leaf('uint32', _access_priority)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(access_priority=n.get_opt_int("access-priority"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(access_priority=yang.gdata.from_xml_opt_int(n, "access-priority"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:access-priority' or point == 'access-priority':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_access_priority_full = jd.get('l3vpn-svc:access-priority')
    child_access_priority = child_access_priority_full if child_access_priority_full is not None else jd.get('access-priority')
    if child_access_priority is not None:
        children['access-priority'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority(child_access_priority)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_access_priority = n.children.get('access-priority')
    if child_access_priority is not None:
        if isinstance(child_access_priority, yang.gdata.Leaf):
            children['access-priority'] = child_access_priority.val
    return children

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("leafref", val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("identityref", val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(yang.adata.MNode):
    vpn_policy_id: ?str
    vpn_id: ?str
    site_role: ?str

    mut def __init__(self, vpn_policy_id: ?str, vpn_id: ?str, site_role: ?str):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.vpn_policy_id = vpn_policy_id
        self.vpn_id = vpn_id
        self.site_role = site_role

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy_id = self.vpn_policy_id
        _vpn_id = self.vpn_id
        _site_role = self.site_role
        if _vpn_policy_id is not None:
            children['vpn-policy-id'] = yang.gdata.Leaf('leafref', _vpn_policy_id)
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('leafref', _vpn_id)
        if _site_role is not None:
            children['site-role'] = yang.gdata.Leaf('identityref', _site_role)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(vpn_policy_id=n.get_opt_str("vpn-policy-id"), vpn_id=n.get_opt_str("vpn-id"), site_role=n.get_opt_str("site-role"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(vpn_policy_id=yang.gdata.from_xml_opt_str(n, "vpn-policy-id"), vpn_id=yang.gdata.from_xml_opt_str(n, "vpn-id"), site_role=yang.gdata.from_xml_opt_str(n, "site-role"))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:vpn-policy-id' or point == 'vpn-policy-id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:vpn-id' or point == 'vpn-id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3vpn-svc:site-role' or point == 'site-role':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_policy_id_full = jd.get('l3vpn-svc:vpn-policy-id')
    child_vpn_policy_id = child_vpn_policy_id_full if child_vpn_policy_id_full is not None else jd.get('vpn-policy-id')
    if child_vpn_policy_id is not None:
        children['vpn-policy-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id(child_vpn_policy_id)
    child_vpn_id_full = jd.get('l3vpn-svc:vpn-id')
    child_vpn_id = child_vpn_id_full if child_vpn_id_full is not None else jd.get('vpn-id')
    if child_vpn_id is not None:
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id(child_vpn_id)
    child_site_role_full = jd.get('l3vpn-svc:site-role')
    child_site_role = child_site_role_full if child_site_role_full is not None else jd.get('site-role')
    if child_site_role is not None:
        children['site-role'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role(child_site_role)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_vpn_policy_id = n.children.get('vpn-policy-id')
    if child_vpn_policy_id is not None:
        if isinstance(child_vpn_policy_id, yang.gdata.Leaf):
            children['vpn-policy-id'] = child_vpn_policy_id.val
    child_vpn_id = n.children.get('vpn-id')
    if child_vpn_id is not None:
        if isinstance(child_vpn_id, yang.gdata.Leaf):
            children['vpn-id'] = child_vpn_id.val
    child_site_role = n.children.get('site-role')
    if child_site_role is not None:
        if isinstance(child_site_role, yang.gdata.Leaf):
            children['site-role'] = child_site_role.val
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(yang.adata.MNode):
    site_network_access_id: str
    site_network_access_type: ?str
    location_reference: ?str
    device_reference: ?str
    access_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity
    bearer: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer
    ip_connection: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols
    availability: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability
    vpn_attachment: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment

    mut def __init__(self, site_network_access_id: str, site_network_access_type: ?str, location_reference: ?str, device_reference: ?str, access_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity=None, bearer: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer=None, ip_connection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security=None, service: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols=None, availability: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability=None, vpn_attachment: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.site_network_access_id = site_network_access_id
        self.site_network_access_type = site_network_access_type
        self.location_reference = location_reference
        self.device_reference = device_reference
        if access_diversity is not None:
            self.access_diversity = access_diversity
        else:
            self.access_diversity = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()
        self_access_diversity = self.access_diversity
        if self_access_diversity is not None:
            self_access_diversity._parent = self
        if bearer is not None:
            self.bearer = bearer
        else:
            self.bearer = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()
        self_bearer = self.bearer
        if self_bearer is not None:
            self_bearer._parent = self
        if ip_connection is not None:
            self.ip_connection = ip_connection
        else:
            self.ip_connection = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()
        self_ip_connection = self.ip_connection
        if self_ip_connection is not None:
            self_ip_connection._parent = self
        if security is not None:
            self.security = security
        else:
            self.security = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()
        self_security = self.security
        if self_security is not None:
            self_security._parent = self
        if service is not None:
            self.service = service
        else:
            self.service = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service()
        self_service = self.service
        if self_service is not None:
            self_service._parent = self
        if routing_protocols is not None:
            self.routing_protocols = routing_protocols
        else:
            self.routing_protocols = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()
        self_routing_protocols = self.routing_protocols
        if self_routing_protocols is not None:
            self_routing_protocols._parent = self
        if availability is not None:
            self.availability = availability
        else:
            self.availability = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()
        self_availability = self.availability
        if self_availability is not None:
            self_availability._parent = self
        if vpn_attachment is not None:
            self.vpn_attachment = vpn_attachment
        else:
            self.vpn_attachment = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()
        self_vpn_attachment = self.vpn_attachment
        if self_vpn_attachment is not None:
            self_vpn_attachment._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_network_access_id = self.site_network_access_id
        _site_network_access_type = self.site_network_access_type
        _location_reference = self.location_reference
        _device_reference = self.device_reference
        _access_diversity = self.access_diversity
        _bearer = self.bearer
        _ip_connection = self.ip_connection
        _security = self.security
        _service = self.service
        _routing_protocols = self.routing_protocols
        _availability = self.availability
        _vpn_attachment = self.vpn_attachment
        if _site_network_access_id is not None:
            children['site-network-access-id'] = yang.gdata.Leaf('string', _site_network_access_id)
        if _site_network_access_type is not None:
            children['site-network-access-type'] = yang.gdata.Leaf('identityref', _site_network_access_type)
        if _location_reference is not None:
            children['location-reference'] = yang.gdata.Leaf('leafref', _location_reference)
        if _device_reference is not None:
            children['device-reference'] = yang.gdata.Leaf('leafref', _device_reference)
        if _access_diversity is not None:
            children['access-diversity'] = _access_diversity.to_gdata()
        if _bearer is not None:
            children['bearer'] = _bearer.to_gdata()
        if _ip_connection is not None:
            children['ip-connection'] = _ip_connection.to_gdata()
        if _security is not None:
            children['security'] = _security.to_gdata()
        if _service is not None:
            children['service'] = _service.to_gdata()
        if _routing_protocols is not None:
            children['routing-protocols'] = _routing_protocols.to_gdata()
        if _availability is not None:
            children['availability'] = _availability.to_gdata()
        if _vpn_attachment is not None:
            children['vpn-attachment'] = _vpn_attachment.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.site_network_access_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id=n.get_str("site-network-access-id"), site_network_access_type=n.get_opt_str("site-network-access-type"), location_reference=n.get_opt_str("location-reference"), device_reference=n.get_opt_str("device-reference"), access_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity.from_gdata(n.get_opt_container("access-diversity")), bearer=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer.from_gdata(n.get_opt_container("bearer")), ip_connection=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection.from_gdata(n.get_opt_container("ip-connection")), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security.from_gdata(n.get_opt_container("security")), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service.from_gdata(n.get_opt_container("service")), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols.from_gdata(n.get_opt_container("routing-protocols")), availability=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability.from_gdata(n.get_opt_container("availability")), vpn_attachment=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment.from_gdata(n.get_opt_container("vpn-attachment")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id=yang.gdata.from_xml_str(n, "site-network-access-id"), site_network_access_type=yang.gdata.from_xml_opt_str(n, "site-network-access-type"), location_reference=yang.gdata.from_xml_opt_str(n, "location-reference"), device_reference=yang.gdata.from_xml_opt_str(n, "device-reference"), access_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity.from_xml(yang.gdata.get_xml_opt_child(n, "access-diversity")), bearer=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer.from_xml(yang.gdata.get_xml_opt_child(n, "bearer")), ip_connection=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection.from_xml(yang.gdata.get_xml_opt_child(n, "ip-connection")), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security.from_xml(yang.gdata.get_xml_opt_child(n, "security")), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service.from_xml(yang.gdata.get_xml_opt_child(n, "service")), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols.from_xml(yang.gdata.get_xml_opt_child(n, "routing-protocols")), availability=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability.from_xml(yang.gdata.get_xml_opt_child(n, "availability")), vpn_attachment=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment.from_xml(yang.gdata.get_xml_opt_child(n, "vpn-attachment")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'site-network-access'
        self.elements = elements

    mut def create(self, site_network_access_id):
        for e in self.elements:
            match = True
            if e.site_network_access_id != site_network_access_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['site-network-access-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['site-network-access-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'site-network-access-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'location-reference':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'device-reference':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'access-diversity':
            children['access-diversity'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd, rest_path, op)
        if point == 'bearer':
            children['bearer'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd, rest_path, op)
        if point == 'ip-connection':
            children['ip-connection'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd, rest_path, op)
        if point == 'security':
            children['security'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd, rest_path, op)
        if point == 'service':
            children['service'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd, rest_path, op)
        if point == 'routing-protocols':
            children['routing-protocols'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd, rest_path, op)
        if point == 'availability':
            children['availability'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd, rest_path, op)
        if point == 'vpn-attachment':
            children['vpn-attachment'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['site-network-access-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['site-network-access-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['site-network-access-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_site_network_access_id_full = jd.get('l3vpn-svc:site-network-access-id')
    child_site_network_access_id = child_site_network_access_id_full if child_site_network_access_id_full is not None else jd.get('site-network-access-id')
    if child_site_network_access_id is not None:
        children['site-network-access-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(child_site_network_access_id)
    child_site_network_access_type_full = jd.get('l3vpn-svc:site-network-access-type')
    child_site_network_access_type = child_site_network_access_type_full if child_site_network_access_type_full is not None else jd.get('site-network-access-type')
    if child_site_network_access_type is not None:
        children['site-network-access-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type(child_site_network_access_type)
    child_location_reference_full = jd.get('l3vpn-svc:location-reference')
    child_location_reference = child_location_reference_full if child_location_reference_full is not None else jd.get('location-reference')
    if child_location_reference is not None:
        children['location-reference'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference(child_location_reference)
    child_device_reference_full = jd.get('l3vpn-svc:device-reference')
    child_device_reference = child_device_reference_full if child_device_reference_full is not None else jd.get('device-reference')
    if child_device_reference is not None:
        children['device-reference'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference(child_device_reference)
    child_access_diversity_full = jd.get('l3vpn-svc:access-diversity')
    child_access_diversity = child_access_diversity_full if child_access_diversity_full is not None else jd.get('access-diversity')
    if child_access_diversity is not None and isinstance(child_access_diversity, dict):
        children['access-diversity'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(child_access_diversity)
    child_bearer_full = jd.get('l3vpn-svc:bearer')
    child_bearer = child_bearer_full if child_bearer_full is not None else jd.get('bearer')
    if child_bearer is not None and isinstance(child_bearer, dict):
        children['bearer'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(child_bearer)
    child_ip_connection_full = jd.get('l3vpn-svc:ip-connection')
    child_ip_connection = child_ip_connection_full if child_ip_connection_full is not None else jd.get('ip-connection')
    if child_ip_connection is not None and isinstance(child_ip_connection, dict):
        children['ip-connection'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(child_ip_connection)
    child_security_full = jd.get('l3vpn-svc:security')
    child_security = child_security_full if child_security_full is not None else jd.get('security')
    if child_security is not None and isinstance(child_security, dict):
        children['security'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(child_security)
    child_service_full = jd.get('l3vpn-svc:service')
    child_service = child_service_full if child_service_full is not None else jd.get('service')
    if child_service is not None and isinstance(child_service, dict):
        children['service'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(child_service)
    child_routing_protocols_full = jd.get('l3vpn-svc:routing-protocols')
    child_routing_protocols = child_routing_protocols_full if child_routing_protocols_full is not None else jd.get('routing-protocols')
    if child_routing_protocols is not None and isinstance(child_routing_protocols, dict):
        children['routing-protocols'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(child_routing_protocols)
    child_availability_full = jd.get('l3vpn-svc:availability')
    child_availability = child_availability_full if child_availability_full is not None else jd.get('availability')
    if child_availability is not None and isinstance(child_availability, dict):
        children['availability'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(child_availability)
    child_vpn_attachment_full = jd.get('l3vpn-svc:vpn-attachment')
    child_vpn_attachment = child_vpn_attachment_full if child_vpn_attachment_full is not None else jd.get('vpn-attachment')
    if child_vpn_attachment is not None and isinstance(child_vpn_attachment, dict):
        children['vpn-attachment'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(child_vpn_attachment)
    return yang.gdata.ListElement([str(child_site_network_access_id if child_site_network_access_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(e))
    return yang.gdata.List(keys=['site-network-access-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_site_network_access_id = n.children.get('site-network-access-id')
    if child_site_network_access_id is not None:
        if isinstance(child_site_network_access_id, yang.gdata.Leaf):
            children['site-network-access-id'] = child_site_network_access_id.val
    child_site_network_access_type = n.children.get('site-network-access-type')
    if child_site_network_access_type is not None:
        if isinstance(child_site_network_access_type, yang.gdata.Leaf):
            children['site-network-access-type'] = child_site_network_access_type.val
    child_location_reference = n.children.get('location-reference')
    if child_location_reference is not None:
        if isinstance(child_location_reference, yang.gdata.Leaf):
            children['location-reference'] = child_location_reference.val
    child_device_reference = n.children.get('device-reference')
    if child_device_reference is not None:
        if isinstance(child_device_reference, yang.gdata.Leaf):
            children['device-reference'] = child_device_reference.val
    child_access_diversity = n.children.get('access-diversity')
    if child_access_diversity is not None:
        if isinstance(child_access_diversity, yang.gdata.Container):
            children['access-diversity'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(child_access_diversity)
    child_bearer = n.children.get('bearer')
    if child_bearer is not None:
        if isinstance(child_bearer, yang.gdata.Container):
            children['bearer'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(child_bearer)
    child_ip_connection = n.children.get('ip-connection')
    if child_ip_connection is not None:
        if isinstance(child_ip_connection, yang.gdata.Container):
            children['ip-connection'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(child_ip_connection)
    child_security = n.children.get('security')
    if child_security is not None:
        if isinstance(child_security, yang.gdata.Container):
            children['security'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(child_security)
    child_service = n.children.get('service')
    if child_service is not None:
        if isinstance(child_service, yang.gdata.Container):
            children['service'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(child_service)
    child_routing_protocols = n.children.get('routing-protocols')
    if child_routing_protocols is not None:
        if isinstance(child_routing_protocols, yang.gdata.Container):
            children['routing-protocols'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(child_routing_protocols)
    child_availability = n.children.get('availability')
    if child_availability is not None:
        if isinstance(child_availability, yang.gdata.Container):
            children['availability'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(child_availability)
    child_vpn_attachment = n.children.get('vpn-attachment')
    if child_vpn_attachment is not None:
        if isinstance(child_vpn_attachment, yang.gdata.Container):
            children['vpn-attachment'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(child_vpn_attachment)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(yang.adata.MNode):
    site_network_access: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access

    mut def __init__(self, site_network_access: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.site_network_access = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(elements=site_network_access)
        self.site_network_access._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_network_access = self.site_network_access
        if _site_network_access is not None:
            children['site-network-access'] = _site_network_access.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(site_network_access=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access.from_gdata(n.get_opt_list("site-network-access")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(site_network_access=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access.from_xml(yang.gdata.get_xml_children(n, "site-network-access")))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:site-network-access' or point == 'site-network-access':
            child = {'site-network-access': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_site_network_access_full = jd.get('l3vpn-svc:site-network-access')
    child_site_network_access = child_site_network_access_full if child_site_network_access_full is not None else jd.get('site-network-access')
    if child_site_network_access is not None and isinstance(child_site_network_access, list):
        children['site-network-access'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(child_site_network_access)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_site_network_access = n.children.get('site-network-access')
    if child_site_network_access is not None:
        if isinstance(child_site_network_access, yang.gdata.List):
            children['site-network-access'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(child_site_network_access)
    return children

class ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(yang.adata.MNode):
    site_id: str
    requested_site_start: ?str
    requested_site_stop: ?str
    locations: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations
    devices: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices
    site_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__management
    vpn_policies: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies
    site_vpn_flavor: ?str
    maximum_routes: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__service
    traffic_protection: ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols
    site_network_accesses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses

    mut def __init__(self, site_id: str, requested_site_start: ?str, requested_site_stop: ?str, locations: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__locations=None, devices: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__devices=None, site_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity=None, management: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__management=None, vpn_policies: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies=None, site_vpn_flavor: ?str, maximum_routes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security=None, service: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service=None, traffic_protection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols=None, site_network_accesses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.site_id = site_id
        self.requested_site_start = requested_site_start
        self.requested_site_stop = requested_site_stop
        if locations is not None:
            self.locations = locations
        else:
            self.locations = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()
        self_locations = self.locations
        if self_locations is not None:
            self_locations._parent = self
        if devices is not None:
            self.devices = devices
        else:
            self.devices = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()
        self_devices = self.devices
        if self_devices is not None:
            self_devices._parent = self
        if site_diversity is not None:
            self.site_diversity = site_diversity
        else:
            self.site_diversity = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()
        self_site_diversity = self.site_diversity
        if self_site_diversity is not None:
            self_site_diversity._parent = self
        if management is not None:
            self.management = management
        else:
            self.management = ietf_l3vpn_svc__l3vpn_svc__sites__site__management()
        self_management = self.management
        if self_management is not None:
            self_management._parent = self
        if vpn_policies is not None:
            self.vpn_policies = vpn_policies
        else:
            self.vpn_policies = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()
        self_vpn_policies = self.vpn_policies
        if self_vpn_policies is not None:
            self_vpn_policies._parent = self
        self.site_vpn_flavor = site_vpn_flavor
        if maximum_routes is not None:
            self.maximum_routes = maximum_routes
        else:
            self.maximum_routes = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()
        self_maximum_routes = self.maximum_routes
        if self_maximum_routes is not None:
            self_maximum_routes._parent = self
        if security is not None:
            self.security = security
        else:
            self.security = ietf_l3vpn_svc__l3vpn_svc__sites__site__security()
        self_security = self.security
        if self_security is not None:
            self_security._parent = self
        if service is not None:
            self.service = service
        else:
            self.service = ietf_l3vpn_svc__l3vpn_svc__sites__site__service()
        self_service = self.service
        if self_service is not None:
            self_service._parent = self
        if traffic_protection is not None:
            self.traffic_protection = traffic_protection
        else:
            self.traffic_protection = ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()
        self_traffic_protection = self.traffic_protection
        if self_traffic_protection is not None:
            self_traffic_protection._parent = self
        if routing_protocols is not None:
            self.routing_protocols = routing_protocols
        else:
            self.routing_protocols = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()
        self_routing_protocols = self.routing_protocols
        if self_routing_protocols is not None:
            self_routing_protocols._parent = self
        if site_network_accesses is not None:
            self.site_network_accesses = site_network_accesses
        else:
            self.site_network_accesses = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()
        self_site_network_accesses = self.site_network_accesses
        if self_site_network_accesses is not None:
            self_site_network_accesses._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_id = self.site_id
        _requested_site_start = self.requested_site_start
        _requested_site_stop = self.requested_site_stop
        _locations = self.locations
        _devices = self.devices
        _site_diversity = self.site_diversity
        _management = self.management
        _vpn_policies = self.vpn_policies
        _site_vpn_flavor = self.site_vpn_flavor
        _maximum_routes = self.maximum_routes
        _security = self.security
        _service = self.service
        _traffic_protection = self.traffic_protection
        _routing_protocols = self.routing_protocols
        _site_network_accesses = self.site_network_accesses
        if _site_id is not None:
            children['site-id'] = yang.gdata.Leaf('string', _site_id)
        if _requested_site_start is not None:
            children['requested-site-start'] = yang.gdata.Leaf('string', _requested_site_start)
        if _requested_site_stop is not None:
            children['requested-site-stop'] = yang.gdata.Leaf('string', _requested_site_stop)
        if _locations is not None:
            children['locations'] = _locations.to_gdata()
        if _devices is not None:
            children['devices'] = _devices.to_gdata()
        if _site_diversity is not None:
            children['site-diversity'] = _site_diversity.to_gdata()
        if _management is not None:
            children['management'] = _management.to_gdata()
        if _vpn_policies is not None:
            children['vpn-policies'] = _vpn_policies.to_gdata()
        if _site_vpn_flavor is not None:
            children['site-vpn-flavor'] = yang.gdata.Leaf('identityref', _site_vpn_flavor)
        if _maximum_routes is not None:
            children['maximum-routes'] = _maximum_routes.to_gdata()
        if _security is not None:
            children['security'] = _security.to_gdata()
        if _service is not None:
            children['service'] = _service.to_gdata()
        if _traffic_protection is not None:
            children['traffic-protection'] = _traffic_protection.to_gdata()
        if _routing_protocols is not None:
            children['routing-protocols'] = _routing_protocols.to_gdata()
        if _site_network_accesses is not None:
            children['site-network-accesses'] = _site_network_accesses.to_gdata()
        return yang.gdata.ListElement([yang.gdata.yang_str(self.site_id)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id=n.get_str("site-id"), requested_site_start=n.get_opt_str("requested-site-start"), requested_site_stop=n.get_opt_str("requested-site-stop"), locations=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations.from_gdata(n.get_opt_container("locations")), devices=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices.from_gdata(n.get_opt_container("devices")), site_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity.from_gdata(n.get_opt_container("site-diversity")), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__management.from_gdata(n.get_opt_container("management")), vpn_policies=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies.from_gdata(n.get_opt_container("vpn-policies")), site_vpn_flavor=n.get_opt_str("site-vpn-flavor"), maximum_routes=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes.from_gdata(n.get_opt_container("maximum-routes")), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__security.from_gdata(n.get_opt_container("security")), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__service.from_gdata(n.get_opt_container("service")), traffic_protection=ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection.from_gdata(n.get_opt_container("traffic-protection")), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols.from_gdata(n.get_opt_container("routing-protocols")), site_network_accesses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses.from_gdata(n.get_opt_container("site-network-accesses")))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id=yang.gdata.from_xml_str(n, "site-id"), requested_site_start=yang.gdata.from_xml_opt_str(n, "requested-site-start"), requested_site_stop=yang.gdata.from_xml_opt_str(n, "requested-site-stop"), locations=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations.from_xml(yang.gdata.get_xml_opt_child(n, "locations")), devices=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices.from_xml(yang.gdata.get_xml_opt_child(n, "devices")), site_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity.from_xml(yang.gdata.get_xml_opt_child(n, "site-diversity")), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__management.from_xml(yang.gdata.get_xml_opt_child(n, "management")), vpn_policies=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies.from_xml(yang.gdata.get_xml_opt_child(n, "vpn-policies")), site_vpn_flavor=yang.gdata.from_xml_opt_str(n, "site-vpn-flavor"), maximum_routes=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes.from_xml(yang.gdata.get_xml_opt_child(n, "maximum-routes")), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__security.from_xml(yang.gdata.get_xml_opt_child(n, "security")), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__service.from_xml(yang.gdata.get_xml_opt_child(n, "service")), traffic_protection=ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection.from_xml(yang.gdata.get_xml_opt_child(n, "traffic-protection")), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols.from_xml(yang.gdata.get_xml_opt_child(n, "routing-protocols")), site_network_accesses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses.from_xml(yang.gdata.get_xml_opt_child(n, "site-network-accesses")))

class ietf_l3vpn_svc__l3vpn_svc__sites__site(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]
    mut def __init__(self, elements=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self._name = 'site'
        self.elements = elements

    mut def create(self, site_id):
        for e in self.elements:
            match = True
            if e.site_id != site_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['site-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['site-id']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'requested-site-start':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'requested-site-stop':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'locations':
            children['locations'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd, rest_path, op)
        if point == 'devices':
            children['devices'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd, rest_path, op)
        if point == 'site-diversity':
            children['site-diversity'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd, rest_path, op)
        if point == 'management':
            children['management'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd, rest_path, op)
        if point == 'vpn-policies':
            children['vpn-policies'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd, rest_path, op)
        if point == 'site-vpn-flavor':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'maximum-routes':
            children['maximum-routes'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd, rest_path, op)
        if point == 'security':
            children['security'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd, rest_path, op)
        if point == 'service':
            children['service'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd, rest_path, op)
        if point == 'traffic-protection':
            children['traffic-protection'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd, rest_path, op)
        if point == 'routing-protocols':
            children['routing-protocols'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd, rest_path, op)
        if point == 'site-network-accesses':
            children['site-network-accesses'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd, rest_path, op)
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['site-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['site-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['site-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_site_id_full = jd.get('l3vpn-svc:site-id')
    child_site_id = child_site_id_full if child_site_id_full is not None else jd.get('site-id')
    if child_site_id is not None:
        children['site-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(child_site_id)
    child_requested_site_start_full = jd.get('l3vpn-svc:requested-site-start')
    child_requested_site_start = child_requested_site_start_full if child_requested_site_start_full is not None else jd.get('requested-site-start')
    if child_requested_site_start is not None:
        children['requested-site-start'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start(child_requested_site_start)
    child_requested_site_stop_full = jd.get('l3vpn-svc:requested-site-stop')
    child_requested_site_stop = child_requested_site_stop_full if child_requested_site_stop_full is not None else jd.get('requested-site-stop')
    if child_requested_site_stop is not None:
        children['requested-site-stop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop(child_requested_site_stop)
    child_locations_full = jd.get('l3vpn-svc:locations')
    child_locations = child_locations_full if child_locations_full is not None else jd.get('locations')
    if child_locations is not None and isinstance(child_locations, dict):
        children['locations'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(child_locations)
    child_devices_full = jd.get('l3vpn-svc:devices')
    child_devices = child_devices_full if child_devices_full is not None else jd.get('devices')
    if child_devices is not None and isinstance(child_devices, dict):
        children['devices'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(child_devices)
    child_site_diversity_full = jd.get('l3vpn-svc:site-diversity')
    child_site_diversity = child_site_diversity_full if child_site_diversity_full is not None else jd.get('site-diversity')
    if child_site_diversity is not None and isinstance(child_site_diversity, dict):
        children['site-diversity'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(child_site_diversity)
    child_management_full = jd.get('l3vpn-svc:management')
    child_management = child_management_full if child_management_full is not None else jd.get('management')
    if child_management is not None and isinstance(child_management, dict):
        children['management'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(child_management)
    child_vpn_policies_full = jd.get('l3vpn-svc:vpn-policies')
    child_vpn_policies = child_vpn_policies_full if child_vpn_policies_full is not None else jd.get('vpn-policies')
    if child_vpn_policies is not None and isinstance(child_vpn_policies, dict):
        children['vpn-policies'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(child_vpn_policies)
    child_site_vpn_flavor_full = jd.get('l3vpn-svc:site-vpn-flavor')
    child_site_vpn_flavor = child_site_vpn_flavor_full if child_site_vpn_flavor_full is not None else jd.get('site-vpn-flavor')
    if child_site_vpn_flavor is not None:
        children['site-vpn-flavor'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor(child_site_vpn_flavor)
    child_maximum_routes_full = jd.get('l3vpn-svc:maximum-routes')
    child_maximum_routes = child_maximum_routes_full if child_maximum_routes_full is not None else jd.get('maximum-routes')
    if child_maximum_routes is not None and isinstance(child_maximum_routes, dict):
        children['maximum-routes'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(child_maximum_routes)
    child_security_full = jd.get('l3vpn-svc:security')
    child_security = child_security_full if child_security_full is not None else jd.get('security')
    if child_security is not None and isinstance(child_security, dict):
        children['security'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(child_security)
    child_service_full = jd.get('l3vpn-svc:service')
    child_service = child_service_full if child_service_full is not None else jd.get('service')
    if child_service is not None and isinstance(child_service, dict):
        children['service'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(child_service)
    child_traffic_protection_full = jd.get('l3vpn-svc:traffic-protection')
    child_traffic_protection = child_traffic_protection_full if child_traffic_protection_full is not None else jd.get('traffic-protection')
    if child_traffic_protection is not None and isinstance(child_traffic_protection, dict):
        children['traffic-protection'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(child_traffic_protection)
    child_routing_protocols_full = jd.get('l3vpn-svc:routing-protocols')
    child_routing_protocols = child_routing_protocols_full if child_routing_protocols_full is not None else jd.get('routing-protocols')
    if child_routing_protocols is not None and isinstance(child_routing_protocols, dict):
        children['routing-protocols'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(child_routing_protocols)
    child_site_network_accesses_full = jd.get('l3vpn-svc:site-network-accesses')
    child_site_network_accesses = child_site_network_accesses_full if child_site_network_accesses_full is not None else jd.get('site-network-accesses')
    if child_site_network_accesses is not None and isinstance(child_site_network_accesses, dict):
        children['site-network-accesses'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(child_site_network_accesses)
    return yang.gdata.ListElement([str(child_site_id if child_site_id is not None else "")], children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(e))
    return yang.gdata.List(keys=['site-id'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_site_id = n.children.get('site-id')
    if child_site_id is not None:
        if isinstance(child_site_id, yang.gdata.Leaf):
            children['site-id'] = child_site_id.val
    child_requested_site_start = n.children.get('requested-site-start')
    if child_requested_site_start is not None:
        if isinstance(child_requested_site_start, yang.gdata.Leaf):
            children['requested-site-start'] = child_requested_site_start.val
    child_requested_site_stop = n.children.get('requested-site-stop')
    if child_requested_site_stop is not None:
        if isinstance(child_requested_site_stop, yang.gdata.Leaf):
            children['requested-site-stop'] = child_requested_site_stop.val
    child_locations = n.children.get('locations')
    if child_locations is not None:
        if isinstance(child_locations, yang.gdata.Container):
            children['locations'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(child_locations)
    child_devices = n.children.get('devices')
    if child_devices is not None:
        if isinstance(child_devices, yang.gdata.Container):
            children['devices'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(child_devices)
    child_site_diversity = n.children.get('site-diversity')
    if child_site_diversity is not None:
        if isinstance(child_site_diversity, yang.gdata.Container):
            children['site-diversity'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(child_site_diversity)
    child_management = n.children.get('management')
    if child_management is not None:
        if isinstance(child_management, yang.gdata.Container):
            children['management'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(child_management)
    child_vpn_policies = n.children.get('vpn-policies')
    if child_vpn_policies is not None:
        if isinstance(child_vpn_policies, yang.gdata.Container):
            children['vpn-policies'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(child_vpn_policies)
    child_site_vpn_flavor = n.children.get('site-vpn-flavor')
    if child_site_vpn_flavor is not None:
        if isinstance(child_site_vpn_flavor, yang.gdata.Leaf):
            children['site-vpn-flavor'] = child_site_vpn_flavor.val
    child_maximum_routes = n.children.get('maximum-routes')
    if child_maximum_routes is not None:
        if isinstance(child_maximum_routes, yang.gdata.Container):
            children['maximum-routes'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(child_maximum_routes)
    child_security = n.children.get('security')
    if child_security is not None:
        if isinstance(child_security, yang.gdata.Container):
            children['security'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(child_security)
    child_service = n.children.get('service')
    if child_service is not None:
        if isinstance(child_service, yang.gdata.Container):
            children['service'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(child_service)
    child_traffic_protection = n.children.get('traffic-protection')
    if child_traffic_protection is not None:
        if isinstance(child_traffic_protection, yang.gdata.Container):
            children['traffic-protection'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(child_traffic_protection)
    child_routing_protocols = n.children.get('routing-protocols')
    if child_routing_protocols is not None:
        if isinstance(child_routing_protocols, yang.gdata.Container):
            children['routing-protocols'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(child_routing_protocols)
    child_site_network_accesses = n.children.get('site-network-accesses')
    if child_site_network_accesses is not None:
        if isinstance(child_site_network_accesses, yang.gdata.Container):
            children['site-network-accesses'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(child_site_network_accesses)
    return children

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(e))
    return elements

class ietf_l3vpn_svc__l3vpn_svc__sites(yang.adata.MNode):
    site: ietf_l3vpn_svc__l3vpn_svc__sites__site

    mut def __init__(self, site: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]=[]):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        self.site = ietf_l3vpn_svc__l3vpn_svc__sites__site(elements=site)
        self.site._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site = self.site
        if _site is not None:
            children['site'] = _site.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites(site=ietf_l3vpn_svc__l3vpn_svc__sites__site.from_gdata(n.get_opt_list("site")))
        return ietf_l3vpn_svc__l3vpn_svc__sites()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites(site=ietf_l3vpn_svc__l3vpn_svc__sites__site.from_xml(yang.gdata.get_xml_children(n, "site")))
        return ietf_l3vpn_svc__l3vpn_svc__sites()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:site' or point == 'site':
            child = {'site': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_site_full = jd.get('l3vpn-svc:site')
    child_site = child_site_full if child_site_full is not None else jd.get('site')
    if child_site is not None and isinstance(child_site, list):
        children['site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site(child_site)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc__sites(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_site = n.children.get('site')
    if child_site is not None:
        if isinstance(child_site, yang.gdata.List):
            children['site'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites__site(child_site)
    return children

class ietf_l3vpn_svc__l3vpn_svc(yang.adata.MNode):
    vpn_profiles: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles
    vpn_services: ietf_l3vpn_svc__l3vpn_svc__vpn_services
    sites: ietf_l3vpn_svc__l3vpn_svc__sites

    mut def __init__(self, vpn_profiles: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles=None, vpn_services: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services=None, sites: ?ietf_l3vpn_svc__l3vpn_svc__sites=None):
        self._ns = "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc"
        if vpn_profiles is not None:
            self.vpn_profiles = vpn_profiles
        else:
            self.vpn_profiles = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()
        self_vpn_profiles = self.vpn_profiles
        if self_vpn_profiles is not None:
            self_vpn_profiles._parent = self
        if vpn_services is not None:
            self.vpn_services = vpn_services
        else:
            self.vpn_services = ietf_l3vpn_svc__l3vpn_svc__vpn_services()
        self_vpn_services = self.vpn_services
        if self_vpn_services is not None:
            self_vpn_services._parent = self
        if sites is not None:
            self.sites = sites
        else:
            self.sites = ietf_l3vpn_svc__l3vpn_svc__sites()
        self_sites = self.sites
        if self_sites is not None:
            self_sites._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_profiles = self.vpn_profiles
        _vpn_services = self.vpn_services
        _sites = self.sites
        if _vpn_profiles is not None:
            children['vpn-profiles'] = _vpn_profiles.to_gdata()
        if _vpn_services is not None:
            children['vpn-services'] = _vpn_services.to_gdata()
        if _sites is not None:
            children['sites'] = _sites.to_gdata()
        return yang.gdata.Container(children, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc(vpn_profiles=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles.from_gdata(n.get_opt_container("vpn-profiles")), vpn_services=ietf_l3vpn_svc__l3vpn_svc__vpn_services.from_gdata(n.get_opt_container("vpn-services")), sites=ietf_l3vpn_svc__l3vpn_svc__sites.from_gdata(n.get_opt_container("sites")))
        return ietf_l3vpn_svc__l3vpn_svc()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc(vpn_profiles=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles.from_xml(yang.gdata.get_xml_opt_child(n, "vpn-profiles")), vpn_services=ietf_l3vpn_svc__l3vpn_svc__vpn_services.from_xml(yang.gdata.get_xml_opt_child(n, "vpn-services")), sites=ietf_l3vpn_svc__l3vpn_svc__sites.from_xml(yang.gdata.get_xml_opt_child(n, "sites")))
        return ietf_l3vpn_svc__l3vpn_svc()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn-svc:vpn-profiles' or point == 'vpn-profiles':
            child = {'vpn-profiles': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:vpn-services' or point == 'vpn-services':
            child = {'vpn-services': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-svc:sites' or point == 'sites':
            child = {'sites': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_profiles_full = jd.get('l3vpn-svc:vpn-profiles')
    child_vpn_profiles = child_vpn_profiles_full if child_vpn_profiles_full is not None else jd.get('vpn-profiles')
    if child_vpn_profiles is not None and isinstance(child_vpn_profiles, dict):
        children['vpn-profiles'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(child_vpn_profiles)
    child_vpn_services_full = jd.get('l3vpn-svc:vpn-services')
    child_vpn_services = child_vpn_services_full if child_vpn_services_full is not None else jd.get('vpn-services')
    if child_vpn_services is not None and isinstance(child_vpn_services, dict):
        children['vpn-services'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(child_vpn_services)
    child_sites_full = jd.get('l3vpn-svc:sites')
    child_sites = child_sites_full if child_sites_full is not None else jd.get('sites')
    if child_sites is not None and isinstance(child_sites, dict):
        children['sites'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites(child_sites)
    return yang.gdata.Container(children)

mut def to_json_ietf_l3vpn_svc__l3vpn_svc(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_vpn_profiles = n.children.get('vpn-profiles')
    if child_vpn_profiles is not None:
        if isinstance(child_vpn_profiles, yang.gdata.Container):
            children['vpn-profiles'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(child_vpn_profiles)
    child_vpn_services = n.children.get('vpn-services')
    if child_vpn_services is not None:
        if isinstance(child_vpn_services, yang.gdata.Container):
            children['vpn-services'] = to_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(child_vpn_services)
    child_sites = n.children.get('sites')
    if child_sites is not None:
        if isinstance(child_sites, yang.gdata.Container):
            children['sites'] = to_json_ietf_l3vpn_svc__l3vpn_svc__sites(child_sites)
    return children

class root(yang.adata.MNode):
    netinfra: netinfra__netinfra
    l3vpn_svc: ietf_l3vpn_svc__l3vpn_svc

    mut def __init__(self, netinfra: ?netinfra__netinfra=None, l3vpn_svc: ?ietf_l3vpn_svc__l3vpn_svc=None):
        self._ns = ""
        if netinfra is not None:
            self.netinfra = netinfra
        else:
            self.netinfra = netinfra__netinfra()
        self_netinfra = self.netinfra
        if self_netinfra is not None:
            self_netinfra._parent = self
        if l3vpn_svc is not None:
            self.l3vpn_svc = l3vpn_svc
        else:
            self.l3vpn_svc = ietf_l3vpn_svc__l3vpn_svc()
        self_l3vpn_svc = self.l3vpn_svc
        if self_l3vpn_svc is not None:
            self_l3vpn_svc._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _netinfra = self.netinfra
        _l3vpn_svc = self.l3vpn_svc
        if _netinfra is not None:
            children['netinfra'] = _netinfra.to_gdata()
        if _l3vpn_svc is not None:
            children['l3vpn-svc'] = _l3vpn_svc.to_gdata()
        return yang.gdata.Root(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n != None:
            return root(netinfra=netinfra__netinfra.from_gdata(n.get_opt_container("netinfra")), l3vpn_svc=ietf_l3vpn_svc__l3vpn_svc.from_gdata(n.get_opt_container("l3vpn-svc")))
        return root()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> root:
        if n != None:
            return root(netinfra=netinfra__netinfra.from_xml(yang.gdata.get_xml_opt_child(n, "netinfra", "http://example.com/netinfra")), l3vpn_svc=ietf_l3vpn_svc__l3vpn_svc.from_xml(yang.gdata.get_xml_opt_child(n, "l3vpn-svc", "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc")))
        return root()


mut def from_json_path(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'netinfra:netinfra':
            child = {'netinfra': from_json_path_netinfra__netinfra(jd, rest_path, op) }
            return yang.gdata.Root(child)
        if point == 'l3vpn-svc:l3vpn-svc':
            child = {'l3vpn-svc': from_json_path_ietf_l3vpn_svc__l3vpn_svc(jd, rest_path, op) }
            return yang.gdata.Root(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Root:
    children = {}
    child_netinfra = jd.get('netinfra:netinfra')
    if child_netinfra is not None and isinstance(child_netinfra, dict):
        children['netinfra'] = from_json_netinfra__netinfra(child_netinfra)
    child_l3vpn_svc = jd.get('l3vpn-svc:l3vpn-svc')
    if child_l3vpn_svc is not None and isinstance(child_l3vpn_svc, dict):
        children['l3vpn-svc'] = from_json_ietf_l3vpn_svc__l3vpn_svc(child_l3vpn_svc)
    return yang.gdata.Root(children)

mut def to_json(n: yang.gdata.Root) -> dict[str, ?value]:
    children = {}
    child_netinfra = n.children.get('netinfra')
    if child_netinfra is not None:
        if isinstance(child_netinfra, yang.gdata.Container):
            children['netinfra:netinfra'] = to_json_netinfra__netinfra(child_netinfra)
    child_l3vpn_svc = n.children.get('l3vpn-svc')
    if child_l3vpn_svc is not None:
        if isinstance(child_l3vpn_svc, yang.gdata.Container):
            children['l3vpn-svc:l3vpn-svc'] = to_json_ietf_l3vpn_svc__l3vpn_svc(child_l3vpn_svc)
    return children

schema_namespaces: set[str] = {
    "http://example.com/netinfra",
    "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc",
}
